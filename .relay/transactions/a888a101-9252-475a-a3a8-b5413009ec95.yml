uuid: a888a101-9252-475a-a3a8-b5413009ec95
projectId: scn-ts-core
createdAt: '2025-09-04T17:20:02.662Z'
linesAdded: 104
linesRemoved: 27
gitCommitMsg: 'feat: add extensive formatting options for granular SCN output control'
promptSummary: >-
  User requested a resend of a previous change
  (44e73b2c-63d1-429f-856c-0e77d2008f5d) using the `multi-search-replace`
  strategy. The changes introduce granular controls for SCN output to manage
  token usage, including toggles for icons, visibility prefixes, modifiers,
  tags, and symbol IDs.
reasoning:
  - >-
    bet. you want the same changes but with `multi-search-replace`. more
    surgical, i dig it. here's the patch, rebuilt from the ground up to use
    precise replacements.
  - >-
    First, I'll update `src/types.ts` to expand the `FormattingOptions`
    interface with all the new toggles.
  - >-
    Next, I'll update `src/formatter.ts`. This involves two larger replacements
    for the `formatSymbol` and `formatFile` functions to inject the new
    conditional logic.
  - >-
    Finally, I'll update the web demo UI in
    `packages/scn-ts-web-demo/src/App.tsx` with the new control panel.
  - '---'
operations:
  - type: write
    path: src/types.ts
    content: |-
      <<<<<<< SEARCH
      /**
       * Options to control the SCN output format.
       */
      export interface FormattingOptions {
          showOutgoing?: boolean; // default true
          showIncoming?: boolean; // default true
      }
      =======
      /**
       * Options to control the SCN output format.
       */
      export interface FormattingOptions {
          showOutgoing?: boolean;
          showIncoming?: boolean;
          showIcons?: boolean;
          showVisibility?: boolean; // +/- prefixes
          showModifiers?: boolean; // ..., !, o
          showTags?: boolean;      // [generated], [styled], etc.
          showSymbolIds?: boolean; // (1.2) identifiers
      }
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/formatter.ts
    content: >-
      <<<<<<< SEARCH

      const formatSymbol = (symbol: CodeSymbol, allFiles: SourceFile[], options:
      FormattingOptions): string[] => {
          let icon = ICONS[symbol.kind] || ICONS.default || '?';
          const prefix = symbol.isExported ? SCN_SYMBOLS.EXPORTED_PREFIX : SCN_SYMBOLS.PRIVATE_PREFIX;
          let name = symbol.name === '<anonymous>' ? '' : symbol.name;
          if (symbol.kind === 'variable' && name.trim() === 'default') name = '';
          
          // Handle styled components: ~div ComponentName, ~h1 ComponentName, etc.
          if (symbol.kind === 'styled_component' && (symbol as any)._styledTag) {
              const tagName = (symbol as any)._styledTag;
              icon = `~${tagName}`;
          }

          const mods: string[] = [];
          if (symbol.isAbstract) mods.push(SCN_SYMBOLS.TAG_ABSTRACT.slice(1, -1));
          if (symbol.isStatic) mods.push(SCN_SYMBOLS.TAG_STATIC.slice(1, -1));
          const modStr = mods.length > 0 ? ` [${mods.join(' ')}]` : '';

          const suffixParts: string[] = [];
          if (symbol.signature) name += symbol.name === '<anonymous>' ? symbol.signature : `${symbol.signature}`;
          if (symbol.typeAnnotation) name += `: ${symbol.typeAnnotation}`;
          if (symbol.typeAliasValue) name += ` ${symbol.typeAliasValue}`;
          // Merge async + throws into a single token
          const asyncToken = symbol.isAsync ? SCN_SYMBOLS.ASYNC : '';
          const throwsToken = symbol.throws ? SCN_SYMBOLS.THROWS : '';
          const asyncThrows = (asyncToken + throwsToken) || '';
          if (asyncThrows) suffixParts.push(asyncThrows);
          if (symbol.isPure) suffixParts.push(SCN_SYMBOLS.PURE);
          if (symbol.labels && symbol.labels.length > 0) suffixParts.push(...symbol.labels.map(l => `[${l}]`));
          const suffix = suffixParts.join(' ');

          // Build ID portion conditionally
          const file = allFiles.find(f => f.id === symbol.fileId)!;
          const idPart = formatSymbolIdDisplay(file, symbol);
          const idText = (symbol.kind === 'property' || symbol.kind === 'constructor') ? null : (idPart ?? null);
          const segments: string[] = [prefix, icon];
          if (idText) segments.push(idText);
          if (name) segments.push(name.trim());
          if (modStr) segments.push(modStr);
          if (suffix) segments.push(suffix);
          const line = `  ${segments.filter(Boolean).join(' ')}`;
          const result = [line];

          const { showOutgoing = true, showIncoming = true } = options;

          const outgoing = new Map<number, Set<string>>();
          const unresolvedDeps: string[] = [];
          symbol.dependencies.forEach(dep => {
              if (dep.resolvedFileId !== undefined && dep.resolvedFileId !== symbol.fileId) {
                  if (!outgoing.has(dep.resolvedFileId)) outgoing.set(dep.resolvedFileId, new Set());
                  if (dep.resolvedSymbolId) {
                      const targetFile = allFiles.find(f => f.id === dep.resolvedFileId);
                      const targetSymbol = targetFile?.symbols.find(s => s.id === dep.resolvedSymbolId);
                      if (targetSymbol) {
                          const displayId = formatSymbolIdDisplay(targetFile!, targetSymbol);
                          let text = displayId ?? `(${targetFile!.id}.0)`;
                          if (dep.kind === 'goroutine') {
                              text += ` ${SCN_SYMBOLS.TAG_GOROUTINE}`;
                          }
                          outgoing.get(dep.resolvedFileId)!.add(text);
                      }
                  } else {
                      let text = `(${dep.resolvedFileId}.0)`;
                      if (dep.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                      outgoing.get(dep.resolvedFileId)!.add(text);
                  }
              } else if (dep.resolvedFileId === undefined) {
                  if (dep.kind === 'macro') {
                      unresolvedDeps.push(`${dep.targetName} ${SCN_SYMBOLS.TAG_MACRO}`);
                  }
              }
          });

          const outgoingParts: string[] = [];
          if (outgoing.size > 0) {
              const resolvedParts = Array.from(outgoing.entries())
                  .sort((a, b) => a[0] - b[0])
                  .map(([fileId, symbolIds]) => {
                      const items = Array.from(symbolIds).sort();
                      return items.length > 0 ? `${items.join(', ')}` : `(${fileId}.0)`;
                  });
              outgoingParts.push(...resolvedParts);
          }
          outgoingParts.push(...unresolvedDeps);

          if (showOutgoing && outgoingParts.length > 0) {
              result.push(`    ${SCN_SYMBOLS.OUTGOING_ARROW} ${outgoingParts.join(', ')}`);
          }
          
          if (!showIncoming) return result;

          const incoming = new Map<number, Set<string>>();
          allFiles.forEach(file => {
              file.symbols.forEach(s => {
                  s.dependencies.forEach(d => {
                      if (d.resolvedFileId === symbol.fileId && d.resolvedSymbolId === symbol.id && s !== symbol) {
                          if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                          // Suppress same-file incoming for properties
                          if (file.id === symbol.fileId && symbol.kind === 'property') return;
                          const disp = formatSymbolIdDisplay(file, s) ?? `(${file.id}.0)`;
                          incoming.get(file.id)!.add(disp);
                      }
                  });
              });
              // Include file-level imports to this file as incoming for exported symbols
              // but only if there is no symbol-level incoming from that file already
              if (file.id !== symbol.fileId && symbol.isExported) {
                  file.fileRelationships?.forEach(rel => {
                      if (rel.resolvedFileId === symbol.fileId) {
                          const already = incoming.get(file.id);
                          if (!already || already.size === 0) {
                              if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                              incoming.get(file.id)!.add(`(${file.id}.0)`);
                          }
                      }
                  });
              }
          });

          if (incoming.size > 0) {
              const parts = Array.from(incoming.entries()).map(([_fileId, symbolIds]) => Array.from(symbolIds).join(', '));
              result.push(`    ${SCN_SYMBOLS.INCOMING_ARROW} ${parts.join(', ')}`);
          }

          return result;
      };

      =======

      const formatSymbol = (symbol: CodeSymbol, allFiles: SourceFile[], options:
      FormattingOptions): string[] => {
          const { 
              showOutgoing = true, 
              showIncoming = true,
              showIcons = true,
              showVisibility = true,
              showModifiers = true,
              showTags = true,
              showSymbolIds = true,
          } = options;
          let icon = showIcons ? (ICONS[symbol.kind] || ICONS.default || '?') : '';
          const prefix = showVisibility ? (symbol.isExported ? SCN_SYMBOLS.EXPORTED_PREFIX : SCN_SYMBOLS.PRIVATE_PREFIX) : '';
          let name = symbol.name === '<anonymous>' ? '' : symbol.name;
          if (symbol.kind === 'variable' && name.trim() === 'default') name = '';
          
          // Handle styled components: ~div ComponentName, ~h1 ComponentName, etc.
          if (showIcons && symbol.kind === 'styled_component' && (symbol as any)._styledTag) {
              const tagName = (symbol as any)._styledTag;
              icon = `~${tagName}`;
          }

          const mods: string[] = [];
          if (showTags) {
              if (symbol.isAbstract) mods.push(SCN_SYMBOLS.TAG_ABSTRACT.slice(1, -1));
              if (symbol.isStatic) mods.push(SCN_SYMBOLS.TAG_STATIC.slice(1, -1));
          }
          const modStr = mods.length > 0 ? ` [${mods.join(' ')}]` : '';

          const suffixParts: string[] = [];
          if (symbol.signature) name += symbol.name === '<anonymous>' ? symbol.signature : `${symbol.signature}`;
          if (symbol.typeAnnotation) name += `: ${symbol.typeAnnotation}`;
          if (symbol.typeAliasValue) name += ` ${symbol.typeAliasValue}`;
          // Merge async + throws into a single token
          if (showModifiers) {
              const asyncToken = symbol.isAsync ? SCN_SYMBOLS.ASYNC : '';
              const throwsToken = symbol.throws ? SCN_SYMBOLS.THROWS : '';
              const asyncThrows = (asyncToken + throwsToken) || '';
              if (asyncThrows) suffixParts.push(asyncThrows);
              if (symbol.isPure) suffixParts.push(SCN_SYMBOLS.PURE);
          }
          if (showTags && symbol.labels && symbol.labels.length > 0) suffixParts.push(...symbol.labels.map(l => `[${l}]`));
          const suffix = suffixParts.join(' ');

          // Build ID portion conditionally
          const file = allFiles.find(f => f.id === symbol.fileId)!;
          const idPart = showSymbolIds ? formatSymbolIdDisplay(file, symbol) : null;
          const idText = (symbol.kind === 'property' || symbol.kind === 'constructor') ? null : (idPart ?? null);
          const segments: string[] = [prefix, icon];
          if (idText) segments.push(idText);
          if (name) segments.push(name.trim());
          if (modStr) segments.push(modStr);
          if (suffix) segments.push(suffix);
          const line = `  ${segments.filter(Boolean).join(' ')}`;
          const result = [line];

          const outgoing = new Map<number, Set<string>>();
          const unresolvedDeps: string[] = [];
          symbol.dependencies.forEach(dep => {
              if (dep.resolvedFileId !== undefined && dep.resolvedFileId !== symbol.fileId) {
                  if (!outgoing.has(dep.resolvedFileId)) outgoing.set(dep.resolvedFileId, new Set());
                  if (dep.resolvedSymbolId) {
                      const targetFile = allFiles.find(f => f.id === dep.resolvedFileId);
                      const targetSymbol = targetFile?.symbols.find(s => s.id === dep.resolvedSymbolId);
                      if (targetSymbol) {
                          const displayId = showSymbolIds ? formatSymbolIdDisplay(targetFile!, targetSymbol) : null;
                          let text = displayId ?? `(${targetFile!.id}.0)`;
                          if (dep.kind === 'goroutine') {
                              text += ` ${SCN_SYMBOLS.TAG_GOROUTINE}`;
                          }
                          outgoing.get(dep.resolvedFileId)!.add(text);
                      }
                  } else {
                      let text = `(${dep.resolvedFileId}.0)`;
                      if (dep.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                      outgoing.get(dep.resolvedFileId)!.add(text);
                  }
              } else if (dep.resolvedFileId === undefined) {
                  if (dep.kind === 'macro') {
                      unresolvedDeps.push(`${dep.targetName} ${SCN_SYMBOLS.TAG_MACRO}`);
                  }
              }
          });

          const outgoingParts: string[] = [];
          if (outgoing.size > 0) {
              const resolvedParts = Array.from(outgoing.entries())
                  .sort((a, b) => a[0] - b[0])
                  .map(([fileId, symbolIds]) => {
                      const items = Array.from(symbolIds).sort();
                      return items.length > 0 ? `${items.join(', ')}` : `(${fileId}.0)`;
                  });
              outgoingParts.push(...resolvedParts);
          }
          outgoingParts.push(...unresolvedDeps);

          if (showOutgoing && outgoingParts.length > 0) {
              result.push(`    ${SCN_SYMBOLS.OUTGOING_ARROW} ${outgoingParts.join(', ')}`);
          }
          
          if (!showIncoming) {
              return result;
          }

          const incoming = new Map<number, Set<string>>();
          allFiles.forEach(file => {
              file.symbols.forEach(s => {
                  s.dependencies.forEach(d => {
                      if (d.resolvedFileId === symbol.fileId && d.resolvedSymbolId === symbol.id && s !== symbol) {
                          if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                          // Suppress same-file incoming for properties
                          if (file.id === symbol.fileId && symbol.kind === 'property') return;
                          const disp = showSymbolIds ? (formatSymbolIdDisplay(file, s) ?? `(${file.id}.0)`) : `(${file.id}.0)`;
                          incoming.get(file.id)!.add(disp);
                      }
                  });
              });
              // Include file-level imports to this file as incoming for exported symbols
              // but only if there is no symbol-level incoming from that file already
              if (file.id !== symbol.fileId && symbol.isExported) {
                  file.fileRelationships?.forEach(rel => {
                      if (rel.resolvedFileId === symbol.fileId) {
                          const already = incoming.get(file.id);
                          if (!already || already.size === 0) {
                              if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                              incoming.get(file.id)!.add(`(${file.id}.0)`);
                          }
                      }
                  });
              }
          });

          if (incoming.size > 0) {
              const parts = Array.from(incoming.entries()).map(([_fileId, symbolIds]) => Array.from(symbolIds).join(', '));
              result.push(`    ${SCN_SYMBOLS.INCOMING_ARROW} ${parts.join(', ')}`);
          }

          return result;
      };

      >>>>>>> REPLACE

      <<<<<<< SEARCH

      const formatFile = (file: SourceFile, allFiles: SourceFile[], options:
      FormattingOptions): string => {
          if (file.parseError) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath} [error]`;
          if (!file.sourceCode.trim()) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath}`;

          const directives = [
              file.isGenerated && SCN_SYMBOLS.TAG_GENERATED.slice(1, -1),
              ...(file.languageDirectives || [])
          ].filter(Boolean);
          const directiveStr = directives.length > 0 ? ` [${directives.join(' ')}]` : '';
          const header = `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath}${directiveStr}`;

          const headerLines: string[] = [header];

          const { showOutgoing = true, showIncoming = true } = options;

          // File-level outgoing/incoming dependencies
          const outgoing: string[] = [];
          if (file.fileRelationships) {
              const outgoingFiles = new Set<number>();
              file.fileRelationships.forEach(rel => {
                  // Only show true file-level imports on the header
                  if ((rel.kind === 'import' || rel.kind === 'dynamic_import') && rel.resolvedFileId && rel.resolvedFileId !== file.id) {
                      let text = `(${rel.resolvedFileId}.0)`;
                      if (rel.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                      outgoingFiles.add(rel.resolvedFileId);
                      outgoing.push(text);
                  }
              });
              if (showOutgoing && outgoing.length > 0) {
                  headerLines.push(`  ${SCN_SYMBOLS.OUTGOING_ARROW} ${Array.from(new Set(outgoing)).sort().join(', ')}`);
              }
          }

          // Incoming: any other file that has a file-level relationship pointing here
          const incoming: string[] = [];
          if (showIncoming) {
              allFiles.forEach(other => {
                  if (other.id === file.id) return;
                  other.fileRelationships?.forEach(rel => {
                      if (rel.resolvedFileId === file.id) incoming.push(`(${other.id}.0)`);
                  });
              });
              if (incoming.length > 0) headerLines.push(`  ${SCN_SYMBOLS.INCOMING_ARROW} ${Array.from(new Set(incoming)).sort().join(', ')}`);
          }
          // If file has no exported symbols, only show symbols that are "entry points" for analysis,
          // which we define as having outgoing dependencies.
          const hasExports = file.symbols.some(s => s.isExported);
          let symbolsToPrint = hasExports
              ? file.symbols.slice()
              : file.symbols.filter(s => s.dependencies.length > 0);

          // Group properties/methods under their class/interface parent
          const childrenMap = buildChildrenMap(symbolsToPrint);
          const childIds = new Set<string>(Array.from(childrenMap.values()).flat().map(s => s.id));
          const topLevel = symbolsToPrint.filter(s => !childIds.has(s.id));

          const symbolLines: string[] = [];
          for (const sym of topLevel) {
              const lines = formatSymbol(sym, allFiles, options);
              symbolLines.push(...lines);
              if (childrenMap.has(sym.id)) {
                  const kids = childrenMap.get(sym.id)!;
                  for (const kid of kids) {
                      const kLines = formatSymbol(kid, allFiles, options).map(l => `  ${l}`);
                      symbolLines.push(...kLines);
                  }
              }
          }

          // If we hid symbols (or there were none to begin with for an entry file),
          // aggregate outgoing dependencies from all symbols onto the file header
          if (showOutgoing && symbolsToPrint.length === 0) {
              const aggOutgoing = new Map<number, Set<string>>();
              const unresolvedDeps: string[] = [];

              const processDep = (dep: import('./types').Relationship) => {
                  if (dep.resolvedFileId && dep.resolvedFileId !== file.id) {
                      if (!aggOutgoing.has(dep.resolvedFileId)) aggOutgoing.set(dep.resolvedFileId, new Set());
                      let text = `(${dep.resolvedFileId}.0)`; // Default to file-level
                      if (dep.resolvedSymbolId) {
                          const targetFile = allFiles.find(f => f.id === dep.resolvedFileId)!;
                          const targetSymbol = targetFile.symbols.find(ts => ts.id === dep.resolvedSymbolId);
                          if (targetSymbol) {
                              text = formatSymbolIdDisplay(targetFile, targetSymbol) ?? `(${dep.resolvedFileId}.0)`;
                          }
                      }
                      if (dep.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                      aggOutgoing.get(dep.resolvedFileId)!.add(text);
                  } else if (dep.resolvedFileId === undefined && dep.kind === 'macro') {
                      unresolvedDeps.push(`${dep.targetName} ${SCN_SYMBOLS.TAG_MACRO}`);
                  }
              };

              file.symbols.forEach(s => s.dependencies.forEach(processDep));
              file.fileRelationships?.forEach(processDep);

              const outgoingParts: string[] = [];
              if (aggOutgoing.size > 0) {
                  const resolvedParts = Array.from(aggOutgoing.entries())
                      .sort((a, b) => a[0] - b[0])
                      .flatMap(([, symbolIds]) => Array.from(symbolIds).sort());
                  outgoingParts.push(...resolvedParts);
              }
              outgoingParts.push(...unresolvedDeps);

              if (outgoingParts.length > 0) {
                  // Some fixtures expect separate -> lines per dependency.
                  // This preserves that behavior.
                  for (const part of outgoingParts) {
                      headerLines.push(`  ${SCN_SYMBOLS.OUTGOING_ARROW} ${part}`);
                  }
              }
          }
          return [...headerLines, ...symbolLines].join('\n');
      };

      =======

      const formatFile = (file: SourceFile, allFiles: SourceFile[], options:
      FormattingOptions): string => {
          if (file.parseError) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath} [error]`;
          if (!file.sourceCode.trim()) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath}`;

          const { 
              showOutgoing = true, 
              showIncoming = true,
              showTags = true,
          } = options;

          const directives = showTags ? [
              file.isGenerated && SCN_SYMBOLS.TAG_GENERATED.slice(1, -1),
              ...(file.languageDirectives || [])
          ].filter(Boolean) : [];
          const directiveStr = directives.length > 0 ? ` [${directives.join(' ')}]` : '';
          const header = `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath}${directiveStr}`;

          const headerLines: string[] = [header];

          // File-level outgoing/incoming dependencies
          const outgoing: string[] = [];
          if (file.fileRelationships) {
              const outgoingFiles = new Set<number>();
              file.fileRelationships.forEach(rel => {
                  // Only show true file-level imports on the header
                  if ((rel.kind === 'import' || rel.kind === 'dynamic_import') && rel.resolvedFileId && rel.resolvedFileId !== file.id) {
                      let text = `(${rel.resolvedFileId}.0)`;
                      if (rel.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                      outgoingFiles.add(rel.resolvedFileId);
                      outgoing.push(text);
                  }
              });
              if (showOutgoing && outgoing.length > 0) {
                  headerLines.push(`  ${SCN_SYMBOLS.OUTGOING_ARROW} ${Array.from(new Set(outgoing)).sort().join(', ')}`);
              }
          }

          // Incoming: any other file that has a file-level relationship pointing here
          const incoming: string[] = [];
          if (showIncoming) {
              allFiles.forEach(other => {
                  if (other.id === file.id) return;
                  other.fileRelationships?.forEach(rel => {
                      if (rel.resolvedFileId === file.id) incoming.push(`(${other.id}.0)`);
                  });
              });
              if (incoming.length > 0) headerLines.push(`  ${SCN_SYMBOLS.INCOMING_ARROW} ${Array.from(new Set(incoming)).sort().join(', ')}`);
          }
          // If file has no exported symbols, only show symbols that are "entry points" for analysis,
          // which we define as having outgoing dependencies.
          const hasExports = file.symbols.some(s => s.isExported);
          let symbolsToPrint = hasExports
              ? file.symbols.slice()
              : file.symbols.filter(s => s.dependencies.length > 0);

          // Group properties/methods under their class/interface parent
          const childrenMap = buildChildrenMap(symbolsToPrint);
          const childIds = new Set<string>(Array.from(childrenMap.values()).flat().map(s => s.id));
          const topLevel = symbolsToPrint.filter(s => !childIds.has(s.id));

          const symbolLines: string[] = [];
          for (const sym of topLevel) {
              const lines = formatSymbol(sym, allFiles, options);
              symbolLines.push(...lines);
              if (childrenMap.has(sym.id)) {
                  const kids = childrenMap.get(sym.id)!;
                  for (const kid of kids) {
                      const kLines = formatSymbol(kid, allFiles, options).map(l => `  ${l}`);
                      symbolLines.push(...kLines);
                  }
              }
          }

          // If we hid symbols (or there were none to begin with for an entry file),
          // aggregate outgoing dependencies from all symbols onto the file header
          if (showOutgoing && symbolLines.length === 0 && (file.symbols.length > 0 || (file.fileRelationships && file.fileRelationships.length > 0))) {
              const aggOutgoing = new Map<number, Set<string>>();
              const unresolvedDeps: string[] = [];

              const processDep = (dep: import('./types').Relationship) => {
                  if (dep.resolvedFileId && dep.resolvedFileId !== file.id) {
                      if (!aggOutgoing.has(dep.resolvedFileId)) aggOutgoing.set(dep.resolvedFileId, new Set());
                      let text = `(${dep.resolvedFileId}.0)`; // Default to file-level
                      if (dep.resolvedSymbolId) {
                          const targetFile = allFiles.find(f => f.id === dep.resolvedFileId)!;
                          const targetSymbol = targetFile.symbols.find(ts => ts.id === dep.resolvedSymbolId);
                          if (targetSymbol) {
                              text = options.showSymbolIds ? (formatSymbolIdDisplay(targetFile, targetSymbol) ?? `(${dep.resolvedFileId}.0)`) : `(${dep.resolvedFileId}.0)`;
                          }
                      }
                      if (dep.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                      aggOutgoing.get(dep.resolvedFileId)!.add(text);
                  } else if (dep.resolvedFileId === undefined && dep.kind === 'macro') {
                      unresolvedDeps.push(`${dep.targetName} ${SCN_SYMBOLS.TAG_MACRO}`);
                  }
              };

              file.symbols.forEach(s => s.dependencies.forEach(processDep));
              file.fileRelationships?.forEach(processDep);

              const outgoingParts: string[] = [];
              if (aggOutgoing.size > 0) {
                  const resolvedParts = Array.from(aggOutgoing.entries())
                      .sort((a, b) => a[0] - b[0])
                      .flatMap(([, symbolIds]) => Array.from(symbolIds).sort());
                  outgoingParts.push(...resolvedParts);
              }
              outgoingParts.push(...unresolvedDeps);

              if (outgoingParts.length > 0) {
                  // Some fixtures expect separate -> lines per dependency.
                  // This preserves that behavior.
                  for (const part of outgoingParts) {
                      headerLines.push(`  ${SCN_SYMBOLS.OUTGOING_ARROW} ${part}`);
                  }
              }
          }
          return [...headerLines, ...symbolLines].join('\n');
      };

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: |-
      <<<<<<< SEARCH
        const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
          showOutgoing: true,
          showIncoming: true,
        });
      =======
        const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
          showOutgoing: true,
          showIncoming: true,
          showIcons: true,
          showVisibility: true,
          showModifiers: true,
          showTags: true,
          showSymbolIds: true,
        });
      >>>>>>> REPLACE
      <<<<<<< SEARCH
                    <div className="flex items-center space-x-4 text-sm font-normal text-muted-foreground w-full justify-end">
                      <div className="flex items-center space-x-1.5">
                        <input
                          type="checkbox"
                          id="showOutgoing"
                          checked={formattingOptions.showOutgoing}
                          onChange={(e) => setFormattingOptions(prev => ({ ...prev, showOutgoing: e.target.checked }))}
                          className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                        />
                        <label htmlFor="showOutgoing" className="cursor-pointer select-none">Outgoing</label>
                      </div>
                      <div className="flex items-center space-x-1.5">
                        <input
                          type="checkbox"
                          id="showIncoming"
                          checked={formattingOptions.showIncoming}
                          onChange={(e) => setFormattingOptions(prev => ({ ...prev, showIncoming: e.target.checked }))}
                          className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                        />
                        <label htmlFor="showIncoming" className="cursor-pointer select-none">Incoming</label>
                      </div>
                      <span className="text-right tabular-nums w-24">{tokenCounts.output.toLocaleString()} tokens</span>
                    </div>
      =======
                    <div className="flex items-center flex-wrap gap-x-4 gap-y-1 text-sm font-normal text-muted-foreground w-full justify-end">
                      <div className="flex items-center space-x-1.5">
                        <input
                          type="checkbox"
                          id="showOutgoing"
                          checked={formattingOptions.showOutgoing}
                          onChange={(e) => setFormattingOptions(prev => ({ ...prev, showOutgoing: e.target.checked }))}
                          className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                        />
                        <label htmlFor="showOutgoing" className="cursor-pointer select-none">Outgoing</label>
                      </div>
                      <div className="flex items-center space-x-1.5">
                        <input
                          type="checkbox"
                          id="showIncoming"
                          checked={formattingOptions.showIncoming}
                          onChange={(e) => setFormattingOptions(prev => ({ ...prev, showIncoming: e.target.checked }))}
                          className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                        />
                        <label htmlFor="showIncoming" className="cursor-pointer select-none">Incoming</label>
                      </div>
                      <div className="flex items-center space-x-1.5">
                        <input
                          type="checkbox"
                          id="showIcons"
                          checked={formattingOptions.showIcons}
                          onChange={(e) => setFormattingOptions(prev => ({ ...prev, showIcons: e.target.checked }))}
                          className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                        />
                        <label htmlFor="showIcons" className="cursor-pointer select-none">Icons</label>
                      </div>
                      <div className="flex items-center space-x-1.5">
                        <input
                          type="checkbox"
                          id="showVisibility"
                          checked={formattingOptions.showVisibility}
                          onChange={(e) => setFormattingOptions(prev => ({ ...prev, showVisibility: e.target.checked }))}
                          className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                        />
                        <label htmlFor="showVisibility" className="cursor-pointer select-none">Visibility</label>
                      </div>
                      <div className="flex items-center space-x-1.5">
                        <input
                          type="checkbox"
                          id="showModifiers"
                          checked={formattingOptions.showModifiers}
                          onChange={(e) => setFormattingOptions(prev => ({ ...prev, showModifiers: e.target.checked }))}
                          className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                        />
                        <label htmlFor="showModifiers" className="cursor-pointer select-none">Modifiers</label>
                      </div>
                      <div className="flex items-center space-x-1.5">
                        <input
                          type="checkbox"
                          id="showTags"
                          checked={formattingOptions.showTags}
                          onChange={(e) => setFormattingOptions(prev => ({ ...prev, showTags: e.target.checked }))}
                          className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                        />
                        <label htmlFor="showTags" className="cursor-pointer select-none">Tags</label>
                      </div>
                      <div className="flex items-center space-x-1.5">
                        <input
                          type="checkbox"
                          id="showSymbolIds"
                          checked={formattingOptions.showSymbolIds}
                          onChange={(e) => setFormattingOptions(prev => ({ ...prev, showSymbolIds: e.target.checked }))}
                          className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                        />
                        <label htmlFor="showSymbolIds" className="cursor-pointer select-none">Symbol IDs</label>
                      </div>
                      <span className="text-right tabular-nums w-24 shrink-0">{tokenCounts.output.toLocaleString()} tokens</span>
                    </div>
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  src/types.ts: >-
    import type { Parser, Tree, Language } from 'web-tree-sitter';

    import type { PathResolver } from './utils/tsconfig';

    export type { PathResolver };


    export type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'silent';


    export type LogHandler = (level: Exclude<LogLevel, 'silent'>, ...args:
    any[]) => void;


    export interface TsConfig {
        compilerOptions?: {
            baseUrl?: string;
            paths?: Record<string, string[]>;
        };
    }


    export interface AnalyzeProjectOptions {
        files: InputFile[];
        tsconfig?: TsConfig;
        root?: string;
        onProgress?: (progress: { percentage: number; message: string }) => void;
        logLevel?: LogLevel;
    }


    /**
     * Options to control the SCN output format.
     */
    export interface FormattingOptions {
        showOutgoing?: boolean; // default true
        showIncoming?: boolean; // default true
    }


    /**
     * Represents a file to be processed.
     */
    export interface InputFile {
      path: string; // relative path from root
      content: string;
    }


    /**
     * Configuration for the SCN generation process.
     */
    export interface ScnTsConfig {
      files: InputFile[];
      tsconfig?: TsConfig;
      formattingOptions?: FormattingOptions;
      root?: string; // Optional: A virtual root path for resolution. Defaults to '/'.
      _test_id?: string; // Special property for test runner to identify fixtures
    }


    /**
     * Options for initializing the Tree-sitter parser.
     */
    export interface ParserInitOptions {
        wasmBaseUrl: string;
    }


    /**
     * Represents a supported programming language and its configuration.
     */
    export type SymbolKind =
      // TS/JS
      | 'class' | 'interface' | 'function' | 'method' | 'constructor'
      | 'variable' | 'property' | 'enum' | 'enum_member' | 'type_alias' | 'module'
      | 'decorator' | 'parameter' | 'type_parameter' | 'import_specifier' | 're_export'
      // React
      | 'react_component' | 'react_hook' | 'react_hoc' | 'jsx_attribute' | 'jsx_element' | 'styled_component'
      // CSS
      | 'css_class' | 'css_id' | 'css_tag' | 'css_at_rule' | 'css_property' | 'css_variable'
      // Generic / Meta
      | 'file' | 'reference' | 'comment' | 'error' | 'unresolved'
      // Other Languages
      | 'go_package' | 'go_struct' | 'go_goroutine' | 'rust_struct' | 'rust_trait' | 'rust_impl' | 'rust_macro'
      | 'java_package' | 'python_class'
      | 'unknown';

    export interface Position {
      line: number;
      column: number;
    }


    export interface Range {
      start: Position;
      end: Position;
    }


    export interface CodeSymbol {
      id: string;
      fileId: number;
      name: string;
      kind: SymbolKind;
      range: Range;
      // Modifiers and metadata
      isExported: boolean;
      isAbstract?: boolean;
      isStatic?: boolean;
      isReadonly?: boolean;
      isAsync?: boolean;
      isPure?: boolean; // for 'o'
      throws?: boolean; // for '!'
      labels?: string[]; // extra display labels like [symbol], [proxy]
      isGenerated?: boolean;
      languageDirectives?: string[]; // e.g. 'use server'
      superClass?: string;
      implementedInterfaces?: string[];
      scopeRange: Range; // The range of the entire scope (e.g., function body) for relationship association
      accessibility?: 'public' | 'private' | 'protected';
      // Type information and signatures
      signature?: string; // e.g., (a: #number, b: #number): #number
      typeAnnotation?: string; // e.g., #string for properties/variables
      typeAliasValue?: string; // e.g., #number|string for type aliases
      // Relationships
      dependencies: Relationship[];
    }


    export type RelationshipKind =
      | 'import'
      | 'dynamic_import'
      | 'reference'
      | 'tagged'
      | 'export'
      | 'call'
      | 'extends'
      | 'implements'
      | 'references'
      | 'aliased'
      | 'goroutine'
      | 'macro';

    export interface Relationship {
      targetName: string; // The raw name of the target (e.g., './utils', 'MyClass', 'add', 'Button')
      kind: RelationshipKind;
      range: Range;
      // Resolved info
      resolvedFileId?: number;
      resolvedSymbolId?: string;
    }


    export interface SourceFile {
      id: number;
      relativePath: string;
      absolutePath: string;
      language: LanguageConfig;
      sourceCode: string;
      ast?: Tree;
      symbols: CodeSymbol[];
      parseError: boolean;
      isGenerated?: boolean;
      languageDirectives?: string[];
      // File-level relationships (e.g., imports not tied to a specific symbol)
      fileRelationships?: Relationship[];
    }


    /**
     * Represents a supported programming language and its configuration.
     */
    export interface LanguageConfig {
        id: string;
        name: string;
        extensions: string[];
        wasmPath: string;
        parser?: Parser;
        loadedLanguage?: Language;
        queries?: Record<string, string>;
    }


    export interface AnalysisContext {
        sourceFiles: SourceFile[];
        pathResolver: PathResolver;
    }
  src/formatter.ts: >-
    import type { CodeSymbol, SourceFile, FormattingOptions } from './types';

    import { topologicalSort } from './utils/graph';

    import { ICONS, SCN_SYMBOLS } from './constants';


    // Compute display index per file based on eligible symbols (exclude
    properties and constructors)

    const isIdEligible = (symbol: CodeSymbol): boolean => {
        if (symbol.kind === 'property' || symbol.kind === 'constructor') return false;
        if (symbol.kind === 'variable') return symbol.isExported || symbol.name === 'module.exports' || symbol.name === 'default';
        if (symbol.kind === 'method') return !!symbol.isExported;
        return true;
    };


    const getDisplayIndex = (file: SourceFile, symbol: CodeSymbol): number |
    null => {
        const ordered = file.symbols
            .filter(isIdEligible)
            .sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);
        const index = ordered.findIndex(s => s === symbol);
        return index === -1 ? null : index + 1;
    };


    const formatSymbolIdDisplay = (file: SourceFile, symbol: CodeSymbol): string
    | null => {
        const idx = getDisplayIndex(file, symbol);
        if (idx == null) return null;
        return `(${file.id}.${idx})`;
    };


    const formatSymbol = (symbol: CodeSymbol, allFiles: SourceFile[], options:
    FormattingOptions): string[] => {
        let icon = ICONS[symbol.kind] || ICONS.default || '?';
        const prefix = symbol.isExported ? SCN_SYMBOLS.EXPORTED_PREFIX : SCN_SYMBOLS.PRIVATE_PREFIX;
        let name = symbol.name === '<anonymous>' ? '' : symbol.name;
        if (symbol.kind === 'variable' && name.trim() === 'default') name = '';
        
        // Handle styled components: ~div ComponentName, ~h1 ComponentName, etc.
        if (symbol.kind === 'styled_component' && (symbol as any)._styledTag) {
            const tagName = (symbol as any)._styledTag;
            icon = `~${tagName}`;
        }

        const mods: string[] = [];
        if (symbol.isAbstract) mods.push(SCN_SYMBOLS.TAG_ABSTRACT.slice(1, -1));
        if (symbol.isStatic) mods.push(SCN_SYMBOLS.TAG_STATIC.slice(1, -1));
        const modStr = mods.length > 0 ? ` [${mods.join(' ')}]` : '';

        const suffixParts: string[] = [];
        if (symbol.signature) name += symbol.name === '<anonymous>' ? symbol.signature : `${symbol.signature}`;
        if (symbol.typeAnnotation) name += `: ${symbol.typeAnnotation}`;
        if (symbol.typeAliasValue) name += ` ${symbol.typeAliasValue}`;
        // Merge async + throws into a single token
        const asyncToken = symbol.isAsync ? SCN_SYMBOLS.ASYNC : '';
        const throwsToken = symbol.throws ? SCN_SYMBOLS.THROWS : '';
        const asyncThrows = (asyncToken + throwsToken) || '';
        if (asyncThrows) suffixParts.push(asyncThrows);
        if (symbol.isPure) suffixParts.push(SCN_SYMBOLS.PURE);
        if (symbol.labels && symbol.labels.length > 0) suffixParts.push(...symbol.labels.map(l => `[${l}]`));
        const suffix = suffixParts.join(' ');

        // Build ID portion conditionally
        const file = allFiles.find(f => f.id === symbol.fileId)!;
        const idPart = formatSymbolIdDisplay(file, symbol);
        const idText = (symbol.kind === 'property' || symbol.kind === 'constructor') ? null : (idPart ?? null);
        const segments: string[] = [prefix, icon];
        if (idText) segments.push(idText);
        if (name) segments.push(name.trim());
        if (modStr) segments.push(modStr);
        if (suffix) segments.push(suffix);
        const line = `  ${segments.filter(Boolean).join(' ')}`;
        const result = [line];

        const { showOutgoing = true, showIncoming = true } = options;

        const outgoing = new Map<number, Set<string>>();
        const unresolvedDeps: string[] = [];
        symbol.dependencies.forEach(dep => {
            if (dep.resolvedFileId !== undefined && dep.resolvedFileId !== symbol.fileId) {
                if (!outgoing.has(dep.resolvedFileId)) outgoing.set(dep.resolvedFileId, new Set());
                if (dep.resolvedSymbolId) {
                    const targetFile = allFiles.find(f => f.id === dep.resolvedFileId);
                    const targetSymbol = targetFile?.symbols.find(s => s.id === dep.resolvedSymbolId);
                    if (targetSymbol) {
                        const displayId = formatSymbolIdDisplay(targetFile!, targetSymbol);
                        let text = displayId ?? `(${targetFile!.id}.0)`;
                        if (dep.kind === 'goroutine') {
                            text += ` ${SCN_SYMBOLS.TAG_GOROUTINE}`;
                        }
                        outgoing.get(dep.resolvedFileId)!.add(text);
                    }
                } else {
                    let text = `(${dep.resolvedFileId}.0)`;
                    if (dep.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                    outgoing.get(dep.resolvedFileId)!.add(text);
                }
            } else if (dep.resolvedFileId === undefined) {
                if (dep.kind === 'macro') {
                    unresolvedDeps.push(`${dep.targetName} ${SCN_SYMBOLS.TAG_MACRO}`);
                }
            }
        });

        const outgoingParts: string[] = [];
        if (outgoing.size > 0) {
            const resolvedParts = Array.from(outgoing.entries())
                .sort((a, b) => a[0] - b[0])
                .map(([fileId, symbolIds]) => {
                    const items = Array.from(symbolIds).sort();
                    return items.length > 0 ? `${items.join(', ')}` : `(${fileId}.0)`;
                });
            outgoingParts.push(...resolvedParts);
        }
        outgoingParts.push(...unresolvedDeps);

        if (showOutgoing && outgoingParts.length > 0) {
            result.push(`    ${SCN_SYMBOLS.OUTGOING_ARROW} ${outgoingParts.join(', ')}`);
        }
        
        if (!showIncoming) return result;

        const incoming = new Map<number, Set<string>>();
        allFiles.forEach(file => {
            file.symbols.forEach(s => {
                s.dependencies.forEach(d => {
                    if (d.resolvedFileId === symbol.fileId && d.resolvedSymbolId === symbol.id && s !== symbol) {
                        if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                        // Suppress same-file incoming for properties
                        if (file.id === symbol.fileId && symbol.kind === 'property') return;
                        const disp = formatSymbolIdDisplay(file, s) ?? `(${file.id}.0)`;
                        incoming.get(file.id)!.add(disp);
                    }
                });
            });
            // Include file-level imports to this file as incoming for exported symbols
            // but only if there is no symbol-level incoming from that file already
            if (file.id !== symbol.fileId && symbol.isExported) {
                file.fileRelationships?.forEach(rel => {
                    if (rel.resolvedFileId === symbol.fileId) {
                        const already = incoming.get(file.id);
                        if (!already || already.size === 0) {
                            if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                            incoming.get(file.id)!.add(`(${file.id}.0)`);
                        }
                    }
                });
            }
        });

        if (incoming.size > 0) {
            const parts = Array.from(incoming.entries()).map(([_fileId, symbolIds]) => Array.from(symbolIds).join(', '));
            result.push(`    ${SCN_SYMBOLS.INCOMING_ARROW} ${parts.join(', ')}`);
        }

        return result;
    };



    const isWithin = (inner: CodeSymbol, outer: CodeSymbol): boolean => {
        const a = inner.range;
        const b = outer.scopeRange;
        return (
            (a.start.line > b.start.line || (a.start.line === b.start.line && a.start.column >= b.start.column)) &&
            (a.end.line < b.end.line || (a.end.line === b.end.line && a.end.column <= b.end.column))
        );
    };


    const buildChildrenMap = (symbols: CodeSymbol[]): Map<string, CodeSymbol[]>
    => {
        const parents = symbols.filter(s => s.kind === 'class' || s.kind === 'interface' || s.kind === 'react_component');
        const map = new Map<string, CodeSymbol[]>();
        for (const parent of parents) map.set(parent.id, []);
        for (const sym of symbols) {
            if (sym.kind === 'class' || sym.kind === 'interface' || sym.kind === 'react_component') continue;
            const parent = parents
                .filter(p => isWithin(sym, p))
                .sort((a, b) => (a.scopeRange.end.line - a.scopeRange.start.line) - (b.scopeRange.end.line - b.scopeRange.start.line))[0];
            if (parent) {
                map.get(parent.id)!.push(sym);
            }
        }
        // Sort children by position
        for (const [, arr] of map.entries()) {
            arr.sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);
        }
        return map;
    };


    const formatFile = (file: SourceFile, allFiles: SourceFile[], options:
    FormattingOptions): string => {
        if (file.parseError) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath} [error]`;
        if (!file.sourceCode.trim()) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath}`;

        const directives = [
            file.isGenerated && SCN_SYMBOLS.TAG_GENERATED.slice(1, -1),
            ...(file.languageDirectives || [])
        ].filter(Boolean);
        const directiveStr = directives.length > 0 ? ` [${directives.join(' ')}]` : '';
        const header = `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath}${directiveStr}`;

        const headerLines: string[] = [header];

        const { showOutgoing = true, showIncoming = true } = options;

        // File-level outgoing/incoming dependencies
        const outgoing: string[] = [];
        if (file.fileRelationships) {
            const outgoingFiles = new Set<number>();
            file.fileRelationships.forEach(rel => {
                // Only show true file-level imports on the header
                if ((rel.kind === 'import' || rel.kind === 'dynamic_import') && rel.resolvedFileId && rel.resolvedFileId !== file.id) {
                    let text = `(${rel.resolvedFileId}.0)`;
                    if (rel.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                    outgoingFiles.add(rel.resolvedFileId);
                    outgoing.push(text);
                }
            });
            if (showOutgoing && outgoing.length > 0) {
                headerLines.push(`  ${SCN_SYMBOLS.OUTGOING_ARROW} ${Array.from(new Set(outgoing)).sort().join(', ')}`);
            }
        }

        // Incoming: any other file that has a file-level relationship pointing here
        const incoming: string[] = [];
        if (showIncoming) {
            allFiles.forEach(other => {
                if (other.id === file.id) return;
                other.fileRelationships?.forEach(rel => {
                    if (rel.resolvedFileId === file.id) incoming.push(`(${other.id}.0)`);
                });
            });
            if (incoming.length > 0) headerLines.push(`  ${SCN_SYMBOLS.INCOMING_ARROW} ${Array.from(new Set(incoming)).sort().join(', ')}`);
        }
        // If file has no exported symbols, only show symbols that are "entry points" for analysis,
        // which we define as having outgoing dependencies.
        const hasExports = file.symbols.some(s => s.isExported);
        let symbolsToPrint = hasExports
            ? file.symbols.slice()
            : file.symbols.filter(s => s.dependencies.length > 0);

        // Group properties/methods under their class/interface parent
        const childrenMap = buildChildrenMap(symbolsToPrint);
        const childIds = new Set<string>(Array.from(childrenMap.values()).flat().map(s => s.id));
        const topLevel = symbolsToPrint.filter(s => !childIds.has(s.id));

        const symbolLines: string[] = [];
        for (const sym of topLevel) {
            const lines = formatSymbol(sym, allFiles, options);
            symbolLines.push(...lines);
            if (childrenMap.has(sym.id)) {
                const kids = childrenMap.get(sym.id)!;
                for (const kid of kids) {
                    const kLines = formatSymbol(kid, allFiles, options).map(l => `  ${l}`);
                    symbolLines.push(...kLines);
                }
            }
        }

        // If we hid symbols (or there were none to begin with for an entry file),
        // aggregate outgoing dependencies from all symbols onto the file header
        if (showOutgoing && symbolsToPrint.length === 0) {
            const aggOutgoing = new Map<number, Set<string>>();
            const unresolvedDeps: string[] = [];

            const processDep = (dep: import('./types').Relationship) => {
                if (dep.resolvedFileId && dep.resolvedFileId !== file.id) {
                    if (!aggOutgoing.has(dep.resolvedFileId)) aggOutgoing.set(dep.resolvedFileId, new Set());
                    let text = `(${dep.resolvedFileId}.0)`; // Default to file-level
                    if (dep.resolvedSymbolId) {
                        const targetFile = allFiles.find(f => f.id === dep.resolvedFileId)!;
                        const targetSymbol = targetFile.symbols.find(ts => ts.id === dep.resolvedSymbolId);
                        if (targetSymbol) {
                            text = formatSymbolIdDisplay(targetFile, targetSymbol) ?? `(${dep.resolvedFileId}.0)`;
                        }
                    }
                    if (dep.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                    aggOutgoing.get(dep.resolvedFileId)!.add(text);
                } else if (dep.resolvedFileId === undefined && dep.kind === 'macro') {
                    unresolvedDeps.push(`${dep.targetName} ${SCN_SYMBOLS.TAG_MACRO}`);
                }
            };

            file.symbols.forEach(s => s.dependencies.forEach(processDep));
            file.fileRelationships?.forEach(processDep);

            const outgoingParts: string[] = [];
            if (aggOutgoing.size > 0) {
                const resolvedParts = Array.from(aggOutgoing.entries())
                    .sort((a, b) => a[0] - b[0])
                    .flatMap(([, symbolIds]) => Array.from(symbolIds).sort());
                outgoingParts.push(...resolvedParts);
            }
            outgoingParts.push(...unresolvedDeps);

            if (outgoingParts.length > 0) {
                // Some fixtures expect separate -> lines per dependency.
                // This preserves that behavior.
                for (const part of outgoingParts) {
                    headerLines.push(`  ${SCN_SYMBOLS.OUTGOING_ARROW} ${part}`);
                }
            }
        }
        return [...headerLines, ...symbolLines].join('\n');
    };


    export const formatScn = (analyzedFiles: SourceFile[], options:
    FormattingOptions = {}): string => {
        const sortedFiles = topologicalSort(analyzedFiles);
        return sortedFiles.map(file => formatFile(file, analyzedFiles, options)).join('\n\n');
    };
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback, useRef } from 'react';

    import { get_encoding, type Tiktoken } from 'tiktoken';

    import {
      initializeParser,
      logger,
      analyzeProject,
      generateScn,
    } from '../../../index';

    import type { FileContent, LogHandler, SourceFile, FormattingOptions } from
    '../../../index';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Card, CardContent, CardHeader, CardTitle } from
    './components/ui/card';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import { Play, Loader } from 'lucide-react';

    import type { LogEntry, ProgressData } from './types';


    function App() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
      const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
        showOutgoing: true,
        showIncoming: true,
      });
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [encoder, setEncoder] = useState<Tiktoken | null>(null);
      const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });

      useEffect(() => {
        const init = async () => {
          try {
            await initializeParser({ wasmBaseUrl: '/wasm/' });
            const enc = get_encoding("cl100k_base");
            setEncoder(enc);
            setIsInitialized(true);
            setLogs(prev => [...prev, { level: 'info', message: 'Parser and tokenizer initialized.', timestamp: Date.now() }]);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            setLogs(prev => [...prev, { level: 'error', message: `Failed to initialize: ${message}`, timestamp: Date.now() }]);
          }
        };
        init();
      }, []);

      useEffect(() => {
        if (!encoder) return;
        try {
          const inputTokens = encoder.encode(filesInput).length;
          const outputTokens = encoder.encode(scnOutput).length;
          setTokenCounts({ input: inputTokens, output: outputTokens });
        } catch (e) {
          console.error("Tokenization error:", e);
          setTokenCounts({ input: 0, output: 0 });
        }
      }, [filesInput, scnOutput, encoder]);

      useEffect(() => {
        if (analysisResult) {
          const scn = generateScn(analysisResult, formattingOptions);
          setScnOutput(scn);
        }
      }, [analysisResult, formattingOptions]);

      const handleAnalyze = useCallback(async () => {
        if (!isInitialized) {
          setLogs(prev => [...prev, { level: 'warn', message: 'Parser not ready.', timestamp: Date.now() }]);
          return;
        }

        setIsLoading(true);
        setLogs([]);
        setScnOutput('');
        setAnalysisResult(null);
        setProgress(null);

        const logHandler: LogHandler = (level, ...args) => {
          const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
          setLogs(prev => [...prev, { level, message, timestamp: Date.now() }]);
        };
        logger.setLogHandler(logHandler);
        logger.setLevel('debug');

        const onProgress = (progressData: ProgressData) => {
          setProgress(progressData);
          logger.info(`[${Math.round(progressData.percentage)}%] ${progressData.message}`);
        };

        try {
          let files: FileContent[] = [];
          try {
            files = JSON.parse(filesInput);
            if (!Array.isArray(files)) throw new Error("Input is not an array.");
          } catch (error) {
            throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
          }

          const rankedGraph = await analyzeProject({ files, onProgress, logLevel: 'debug' });
          setAnalysisResult(rankedGraph);
          logger.info('Analysis complete.');
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          logger.error('Analysis failed:', message);
        } finally {
          setIsLoading(false);
          setProgress(null);
          logger.setLogHandler(null);
        }
      }, [filesInput, isInitialized]);

      return (
        <div className="h-screen w-screen flex flex-col bg-background text-foreground">
          <header className="flex-shrink-0 flex items-center justify-between p-4 border-b">
            <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
            <Button onClick={handleAnalyze} disabled={isLoading || !isInitialized} className="w-32 justify-center">
              {isLoading ? (
                <>
                  <Loader className="mr-2 h-4 w-4 animate-spin" />
                  <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                </>
              ) : (
                <>
                  <Play className="mr-2 h-4 w-4" />
                  <span>Analyze</span>
                </>
              )}
            </Button>
          </header>

          <main className="flex-grow grid grid-cols-1 lg:grid-cols-2 gap-4 p-4 overflow-hidden">
            <Card className="flex flex-col overflow-hidden">
              <CardHeader>
                <CardTitle className="flex justify-between items-center">
                  <span>Input Files (JSON)</span>
                  <span className="text-sm font-normal text-muted-foreground">{tokenCounts.input.toLocaleString()} tokens</span>
                </CardTitle>
              </CardHeader>
              <CardContent className="flex-grow">
                <Textarea
                  value={filesInput}
                  onChange={(e) => setFilesInput(e.currentTarget.value)}
                  className="h-full w-full font-mono text-xs resize-none"
                  placeholder="Paste an array of FileContent objects here..."
                />
              </CardContent>
            </Card>

            <Card className="flex flex-col overflow-hidden">
              <CardHeader>
                <CardTitle className="flex justify-between items-center">
                  <span className="whitespace-nowrap">Output (SCN)</span>
                  <div className="flex items-center space-x-4 text-sm font-normal text-muted-foreground w-full justify-end">
                    <div className="flex items-center space-x-1.5">
                      <input
                        type="checkbox"
                        id="showOutgoing"
                        checked={formattingOptions.showOutgoing}
                        onChange={(e) => setFormattingOptions(prev => ({ ...prev, showOutgoing: e.target.checked }))}
                        className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                      />
                      <label htmlFor="showOutgoing" className="cursor-pointer select-none">Outgoing</label>
                    </div>
                    <div className="flex items-center space-x-1.5">
                      <input
                        type="checkbox"
                        id="showIncoming"
                        checked={formattingOptions.showIncoming}
                        onChange={(e) => setFormattingOptions(prev => ({ ...prev, showIncoming: e.target.checked }))}
                        className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
                      />
                      <label htmlFor="showIncoming" className="cursor-pointer select-none">Incoming</label>
                    </div>
                    <span className="text-right tabular-nums w-24">{tokenCounts.output.toLocaleString()} tokens</span>
                  </div>
                </CardTitle>
              </CardHeader>
              <CardContent className="flex-grow overflow-auto">
                <pre className="text-xs whitespace-pre-wrap font-mono h-full w-full">
                  <code className="h-full w-full">
                    {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
                  </code>
                </pre>
              </CardContent>
            </Card>
          </main>

          <footer className="flex-shrink-0 h-[200px] border-t">
            <LogViewer logs={logs} />
          </footer>
        </div>
      );
    }


    export default App;
approved: true
