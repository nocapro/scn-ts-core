uuid: d8910077-d4f1-469b-9807-6bb9fdd192f1
projectId: scn-ts-core
createdAt: '2025-08-12T04:34:47.515Z'
linesAdded: 2
linesRemoved: 2
gitCommitMsg: 'fix(types): use Node type alias for SyntaxNode'
promptSummary: >-
  Fix TypeScript errors indicating that 'SyntaxNode' is not an exported member
  of 'web-tree-sitter' by importing 'Node' and aliasing it as 'SyntaxNode'.
reasoning:
  - >-
    My apologies. It seems I misremembered the export name. The type for a node
    in the tree is `Node`, not `SyntaxNode`. The code uses `SyntaxNode` as a
    type alias for `Node`.
  - >-
    I'll correct the imports in both files to import `Node` and alias it as
    `SyntaxNode`.
  - 'First, I''ll fix `src/analyzer.ts`:'
  - 'Next, I''ll fix `src/utils/ast.ts`:'
  - >-
    These changes correctly import the `Node` type from `web-tree-sitter` and
    alias it to `SyntaxNode`, which should resolve the compilation errors.
operations:
  - type: write
    path: src/analyzer.ts
    content: |-
      <<<<<<< SEARCH
      import type { SyntaxNode, QueryCapture } from 'web-tree-sitter';
      =======
      import type { Node as SyntaxNode, QueryCapture } from 'web-tree-sitter';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/utils/ast.ts
    content: |-
      <<<<<<< SEARCH
      import type { SyntaxNode } from 'web-tree-sitter';
      =======
      import type { Node as SyntaxNode } from 'web-tree-sitter';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  src/analyzer.ts: >-
    import type { SourceFile, CodeSymbol, Relationship, SymbolKind,
    RelationshipKind, Range } from './types';

    import { getNodeRange, getNodeText, getIdentifier, findChildByFieldName }
    from './utils/ast';

    import type { SyntaxNode, QueryCapture } from 'web-tree-sitter';


    const getSymbolName = (node: SyntaxNode, sourceCode: string): string => {
        if (node.type === 'jsx_opening_element' || node.type === 'jsx_self_closing_element') {
            const nameNode = findChildByFieldName(node, 'name');
            return nameNode ? getNodeText(nameNode, sourceCode) : '<fragment>';
        }
        if (node.type === 'variable_declarator') {
            const valueNode = findChildByFieldName(node, 'value');
            if (valueNode?.type === 'arrow_function' || valueNode?.type.startsWith('class')) {
                return getIdentifier(node, sourceCode);
            }
        }
        return getIdentifier(node.parent || node, sourceCode);
    };


    const processCapture = (
        capture: QueryCapture,
        sourceFile: SourceFile,
        symbols: CodeSymbol[],
        relationships: Relationship[]
    ) => {
        const { node, name: captureName } = capture;
        const [cat, kind, role] = captureName.split('.');

        if (cat === 'symbol' && role === 'def') {
            const scopeNode = node.parent?.type.endsWith('_declaration') || node.parent?.type === 'method_definition'
                ? node.parent
                : node;
            const range = getNodeRange(node);
            const symbol: CodeSymbol = {
                id: `${range.start.line + 1}:${range.start.column}`,
                fileId: sourceFile.id,
                name: getSymbolName(node, sourceFile.sourceCode),
                kind: kind as SymbolKind,
                range: range,
                scopeRange: getNodeRange(scopeNode),
                isExported: scopeNode.parent?.type === 'export_statement' || scopeNode.text.startsWith('export '),
                dependencies: [],
            };
            symbols.push(symbol);
        } else if (cat === 'rel') {
            const rel: Relationship = {
                kind: kind as RelationshipKind,
                targetName: getNodeText(node, sourceFile.sourceCode).replace(/['"`]/g, ''),
                range: getNodeRange(node),
            };
            relationships.push(rel);
        } else if (cat === 'mod') {
            const parentSymbol = findParentSymbol(getNodeRange(node), symbols);
            if (parentSymbol) {
                if (kind === 'export') parentSymbol.isExported = true;
                if (kind === 'static') parentSymbol.isStatic = true;
                if (kind === 'abstract') parentSymbol.isAbstract = true;
                if (kind === 'readonly') parentSymbol.isReadonly = true;
                if (kind === 'async') parentSymbol.isAsync = true;
            }
        }
    };


    export const analyze = (sourceFile: SourceFile): SourceFile => {
        const { ast, language, sourceCode } = sourceFile;
        if (!ast || !language.parser || !language.loadedLanguage) return sourceFile;

        const directives = sourceCode.match(/^['"](use (?:server|client))['"];/gm);
        if(directives) {
            sourceFile.languageDirectives = directives.map(d => d.replace(/['";]/g, ''));
        }
        if (sourceCode.includes('AUTO-GENERATED') || sourceCode.includes('eslint-disable')) {
            sourceFile.isGenerated = true;
        }

        const mainQuery = language.queries?.main ?? '';
        if (!mainQuery) return sourceFile;

        const query = language.loadedLanguage.query(mainQuery);
        const captures = query.captures(ast.rootNode);

        const symbols: CodeSymbol[] = [];
        const relationships: Relationship[] = [];

        for (const capture of captures) {
            processCapture(capture, sourceFile, symbols, relationships);
        }
        
        for (const rel of relationships) {
            const parentSymbol = findParentSymbol(rel.range, symbols);
            if (parentSymbol) {
                parentSymbol.dependencies.push(rel);
            }
        }
        
        const addFunc = symbols.find(s => s.name === 'add');
        if (addFunc?.dependencies.length === 0) addFunc.isPure = true;

        sourceFile.symbols = symbols;
        return sourceFile;
    };


    const isRangeWithin = (inner: Range, outer: Range): boolean => {
        return (
            (inner.start.line > outer.start.line || (inner.start.line === outer.start.line && inner.start.column >= outer.start.column)) &&
            (inner.end.line < outer.end.line || (inner.end.line === outer.end.line && inner.end.column <= outer.end.column))
        );
    };


    const findParentSymbol = (range: Range, symbols: CodeSymbol[]): CodeSymbol |
    null => {
        return symbols
            .filter(s => isRangeWithin(range, s.scopeRange))
            .sort((a, b) => (a.scopeRange.end.line - a.scopeRange.start.line) - (b.scopeRange.end.line - b.scopeRange.start.line))
            [0] || null;
    };
  src/utils/ast.ts: >-
    import type { Range } from '../types';

    import type { SyntaxNode } from 'web-tree-sitter';


    export const getNodeText = (node: SyntaxNode, sourceCode: string): string =>
    {
        return sourceCode.substring(node.startIndex, node.endIndex);
    };


    export const getNodeRange = (node: SyntaxNode): Range => {
        return {
            start: { line: node.startPosition.row, column: node.startPosition.column },
            end: { line: node.endPosition.row, column: node.endPosition.column },
        };
    };


    export const findChild = (node: SyntaxNode, type: string | string[]):
    SyntaxNode | null => {
        const types = Array.isArray(type) ? type : [type];
        return node.children.find((c: SyntaxNode) => types.includes(c.type)) || null;
    }


    export const findChildByFieldName = (node: SyntaxNode, fieldName: string):
    SyntaxNode | null => {
        return node.childForFieldName(fieldName);
    };


    export const getIdentifier = (node: SyntaxNode, sourceCode: string,
    defaultName: string = '<anonymous>'): string => {
        const nameNode = findChildByFieldName(node, 'name') ?? findChild(node, ['identifier', 'property_identifier']);
        return nameNode ? getNodeText(nameNode, sourceCode) : defaultName;
    };
approved: true
