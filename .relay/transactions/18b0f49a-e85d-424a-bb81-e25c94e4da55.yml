uuid: 18b0f49a-e85d-424a-bb81-e25c94e4da55
projectId: scn-ts-core
createdAt: '2025-09-05T02:11:13.662Z'
linesAdded: 123
linesRemoved: 160
gitCommitMsg: 'refactor(web-demo): integrate comlink for robust worker communication'
promptSummary: >-
  User is still experiencing instability and suggests using a library for web
  worker management to avoid building communication from scratch.
reasoning:
  - >-
    you're absolutely right. my previous attempts to fix this by hand were just
    creating more problems. using a battle-tested library for worker
    communication is the correct engineering decision. it'll handle the tricky
    parts of messaging, state, and cancellation for us.
  - >-
    i'm going to refactor the demo to use `comlink`, a great little library from
    the Google Chrome team that makes web workers feel like simple async
    functions. this will stabilize the app, fix the race conditions, and give us
    a clean, robust way to cancel analysis.
  - first, let's add `comlink` to the project.
  - >-
    next, i'll bring back the `AbortSignal` to our core types and analysis
    function, as `comlink` can handle transferring it properly. this is a much
    better way to cancel work.
  - now, i'll rewrite the worker to expose a clean API using `comlink`.
  - >-
    finally, i'll update `App.tsx` to use the new `comlink`-powered worker. this
    drastically simplifies the state management, logging, and cancellation
    logic, making it robust.
  - this is a much more robust solution. thanks for pushing for a proper fix.
operations:
  - type: write
    path: packages/scn-ts-web-demo/package.json
    content: |-
      <<<<<<< SEARCH
          "class-variance-authority": "^0.7.0",
          "clsx": "^2.1.1",
          "lucide-react": "^0.379.0",
      =======
          "class-variance-authority": "^0.7.0",
          "comlink": "^4.4.1",
          "clsx": "^2.1.1",
          "lucide-react": "^0.379.0",
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/types.ts
    content: |-
      <<<<<<< SEARCH
      export interface AnalyzeProjectOptions {
          files: InputFile[];
          tsconfig?: TsConfig;
          root?: string;
          onProgress?: (progress: { percentage: number; message: string }) => void;
          logLevel?: LogLevel;
      }
      =======
      export interface AnalyzeProjectOptions {
          files: InputFile[];
          tsconfig?: TsConfig;
          root?: string;
          onProgress?: (progress: { percentage: number; message: string }) => void;
          logLevel?: LogLevel;
          signal?: AbortSignal;
      }
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/main.ts
    content: |-
      <<<<<<< SEARCH
      export const analyzeProject = async ({
          files,
          tsconfig,
          root = '/',
          onProgress,
          logLevel,
      }: AnalyzeProjectOptions): Promise<SourceFile[]> => {
          if (logLevel) {
              logger.setLevel(logLevel);
          }
          const pathResolver = getPathResolver(tsconfig);

          let fileIdCounter = 1;

          onProgress?.({ percentage: 0, message: 'Creating source files...' });

          // Step 1: Create SourceFile objects for all files
          const sourceFiles = files.map((file) => {
              const absolutePath = path.join(root, file.path);
              const sourceFile: SourceFile = {
                  id: fileIdCounter++,
                  relativePath: file.path,
                  absolutePath,
                  sourceCode: file.content,
                  language: getLanguageForFile(file.path)!,
                  symbols: [],
                  parseError: false,
              };
              return sourceFile;
          });

          onProgress?.({ percentage: 10, message: `Parsing ${sourceFiles.length} files...` });

          // Step 2: Parse all files
          const parsedFiles = sourceFiles.map((file, i) => {
              if (!file.language || !file.language.wasmPath || file.sourceCode.trim() === '') {
                  return file;
              }
              const tree = parse(file.sourceCode, file.language);
              if (!tree) {
                  file.parseError = true;
                  logger.warn(`Failed to parse ${file.relativePath}`);
              } else {
                  file.ast = tree;
              }
              const percentage = 10 + (40 * (i + 1) / sourceFiles.length);
              onProgress?.({ percentage, message: `Parsing ${file.relativePath}` });
              return file;
          });

          onProgress?.({ percentage: 50, message: 'Analyzing files...' });

          // Step 3: Analyze all parsed files
          const analyzedFiles = parsedFiles.map((file, i) => {
              if (file.ast) {
                  const analyzed = analyze(file);
                  const percentage = 50 + (40 * (i + 1) / sourceFiles.length);
                  onProgress?.({ percentage, message: `Analyzing ${file.relativePath}` });
                  return analyzed;
              }
              return file;
          });
          
          onProgress?.({ percentage: 90, message: 'Resolving dependency graph...' });

          // Step 4: Resolve the dependency graph across all files
          const resolvedGraph = resolveGraph(analyzedFiles, pathResolver, root);
          
          onProgress?.({ percentage: 100, message: 'Analysis complete.' });
          return resolvedGraph;
      };
      =======
      export const analyzeProject = async ({
          files,
          tsconfig,
          root = '/',
          onProgress,
          logLevel,
          signal,
      }: AnalyzeProjectOptions): Promise<SourceFile[]> => {
          if (logLevel) {
              logger.setLevel(logLevel);
          }
          const pathResolver = getPathResolver(tsconfig);

          const checkAborted = () => { if (signal?.aborted) throw new DOMException('Aborted', 'AbortError'); };
          let fileIdCounter = 1;

          onProgress?.({ percentage: 0, message: 'Creating source files...' });

          // Step 1: Create SourceFile objects for all files
          const sourceFiles = files.map((file) => {
              checkAborted();
              const absolutePath = path.join(root, file.path);
              const sourceFile: SourceFile = {
                  id: fileIdCounter++,
                  relativePath: file.path,
                  absolutePath,
                  sourceCode: file.content,
                  language: getLanguageForFile(file.path)!,
                  symbols: [],
                  parseError: false,
              };
              return sourceFile;
          });

          onProgress?.({ percentage: 10, message: `Parsing ${sourceFiles.length} files...` });

          // Step 2: Parse all files
          const parsedFiles = sourceFiles.map((file, i) => {
              checkAborted();
              if (!file.language || !file.language.wasmPath || file.sourceCode.trim() === '') {
                  return file;
              }
              const tree = parse(file.sourceCode, file.language);
              if (!tree) {
                  file.parseError = true;
                  logger.warn(`Failed to parse ${file.relativePath}`);
              } else {
                  file.ast = tree;
              }
              const percentage = 10 + (40 * (i + 1) / sourceFiles.length);
              onProgress?.({ percentage, message: `Parsing ${file.relativePath}` });
              return file;
          });

          onProgress?.({ percentage: 50, message: 'Analyzing files...' });

          // Step 3: Analyze all parsed files
          const analyzedFiles = parsedFiles.map((file, i) => {
              checkAborted();
              if (file.ast) {
                  const analyzed = analyze(file);
                  const percentage = 50 + (40 * (i + 1) / sourceFiles.length);
                  onProgress?.({ percentage, message: `Analyzing ${file.relativePath}` });
                  return analyzed;
              }
              return file;
          });
          
          onProgress?.({ percentage: 90, message: 'Resolving dependency graph...' });

          // Step 4: Resolve the dependency graph across all files
          checkAborted();
          const resolvedGraph = resolveGraph(analyzedFiles, pathResolver, root);
          
          onProgress?.({ percentage: 100, message: 'Analysis complete.' });
          return resolvedGraph;
      };
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: packages/scn-ts-web-demo/src/worker.ts
    content: |-
      <<<<<<< SEARCH
      import {
        initializeParser,
        analyzeProject,
        logger,
      } from '../../../index';
      import type {
        FileContent,
        LogHandler,
        LogLevel,
        SourceFile,
      } from '../../../index';
      import type { ProgressData } from './types';

      // Define message types for communication
      export type WorkerRequest = {
        type: 'analyze';
        payload: {
          filesInput: string;
          logLevel: LogLevel;
        };
      };

      export type WorkerResponse =
        | { type: 'log'; payload: { level: Exclude<LogLevel, 'silent'>; message: string; timestamp: number } }
        | { type: 'progress'; payload: ProgressData }
        | { type: 'result'; payload: { analysisResult: SourceFile[] } }
        | { type: 'error'; payload: { message: string } }
        | { type: 'init_success' }
        | { type: 'init_error'; payload: { message: string } };

      let isInitialized = false;

      // Initialize parser once when the worker starts
      async function initialize() {
        try {
          // The path is relative to the worker script's location
          await initializeParser({ wasmBaseUrl: '/wasm/' });
          isInitialized = true;
          self.postMessage({ type: 'init_success' } as WorkerResponse);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          self.postMessage({ type: 'init_error', payload: { message } } as WorkerResponse);
        }
      }

      initialize();

      self.onmessage = async (event: MessageEvent<WorkerRequest>) => {
        if (event.data.type !== 'analyze') return;
        if (!isInitialized) {
          self.postMessage({
            type: 'error',
            payload: { message: 'Worker not initialized yet.' },
          } as WorkerResponse);
          return;
        }

        const { filesInput, logLevel } = event.data.payload;

        const logHandler: LogHandler = (level, ...args) => {
          const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
          self.postMessage({ type: 'log', payload: { level, message, timestamp: Date.now() } } as WorkerResponse);
        };
        logger.setLogHandler(logHandler);
        logger.setLevel(logLevel);

        const onProgress = (progressData: ProgressData) => {
          self.postMessage({ type: 'progress', payload: progressData } as WorkerResponse);
        };

        try {
          let files: FileContent[] = [];
          try {
            files = JSON.parse(filesInput);
            if (!Array.isArray(files)) throw new Error("Input is not an array.");
          } catch (error) {
            throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
          }

          const analysisResult = await analyzeProject({
            files,
            onProgress,
            logLevel,
          });

          // Sanitize the result to make it structured-clonable for postMessage.
          // The `ast` and tree-sitter language/parser instances are not clonable.
          analysisResult.forEach(file => {
            delete file.ast;
            if (file.language) {
              delete file.language.parser;
              delete file.language.loadedLanguage;
            }
          });

          self.postMessage({ type: 'result', payload: { analysisResult } } as WorkerResponse);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          self.postMessage({ type: 'error', payload: { message } } as WorkerResponse);
        } finally {
          logger.setLogHandler(null);
        }
      };
      =======
      import * as Comlink from 'comlink';
      import { initializeParser, analyzeProject, logger } from '../../../index';
      import type { FileContent, LogLevel, SourceFile } from '../../../index';
      import type { LogEntry, ProgressData } from './types';

      // Define the API the worker will expose
      const workerApi = {
        isInitialized: false,

        async init() {
          if (this.isInitialized) return;
          await initializeParser({ wasmBaseUrl: '/wasm/' });
          this.isInitialized = true;
        },

        async analyze(
          { filesInput, logLevel }: { filesInput: string; logLevel: LogLevel },
          onProgress: (progress: ProgressData) => void,
          onLog: (log: LogEntry) => void,
          signal: AbortSignal
        ): Promise<SourceFile[]> {
          if (!this.isInitialized) {
            throw new Error('Worker not initialized.');
          }

          logger.setLogHandler((level, ...args) => {
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
            onLog({ level, message, timestamp: Date.now() });
          });
          logger.setLevel(logLevel);

          try {
            let files: FileContent[] = [];
            try {
              files = JSON.parse(filesInput);
              if (!Array.isArray(files)) throw new Error("Input is not an array.");
            } catch (error) {
              throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
            }

            const analysisResult = await analyzeProject({
              files,
              onProgress,
              logLevel,
              signal,
            });

            // Sanitize the result to make it structured-clonable.
            analysisResult.forEach(file => {
              delete file.ast;
              if (file.language) {
                delete file.language.parser;
                delete file.language.loadedLanguage;
              }
            });
            
            return analysisResult;
          } finally {
            logger.setLogHandler(null);
          }
        },
      };

      Comlink.expose(workerApi);

      export type WorkerApi = typeof workerApi;
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: >-
      <<<<<<< SEARCH

      import { useState, useEffect, useCallback, useRef } from 'react';

      import { get_encoding, type Tiktoken } from 'tiktoken';

      import { generateScn } from '../../../index';

      import type { SourceFile } from '../../../index';

      import { defaultFilesJSON } from './default-files';

      import { Button } from './components/ui/button';

      import { Textarea } from './components/ui/textarea';

      import LogViewer from './components/LogViewer';

      import OutputOptions from './components/OutputOptions';

      import { Play, Loader, Copy, Check, StopCircle } from 'lucide-react';

      import type { LogEntry, ProgressData, FormattingOptions } from './types';

      import type { WorkerRequest, WorkerResponse } from './worker';

      import { Accordion, AccordionContent, AccordionItem, AccordionTrigger }
      from './components/ui/accordion';


      function App() {
        const [isInitialized, setIsInitialized] = useState(false);
        const [isLoading, setIsLoading] = useState(false);
        const [filesInput, setFilesInput] = useState(defaultFilesJSON);
        const [scnOutput, setScnOutput] = useState('');
        const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
        const [isCopied, setIsCopied] = useState(false);
        const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
          showOutgoing: true,
          showIncoming: true,
          showIcons: true,
          showExportedIndicator: true,
          showPrivateIndicator: true,
          showModifiers: true,
          showTags: true,
          showSymbolIds: true,
          groupMembers: true,
          displayFilters: {},
          showFilePrefix: true,
          showFileIds: true,
        });
        const [progress, setProgress] = useState<ProgressData | null>(null);
        const [logs, setLogs] = useState<LogEntry[]>([]);
        const [encoder, setEncoder] = useState<Tiktoken | null>(null);
        const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });
        
        const workerRef = useRef<Worker | null>(null);
        const [workerKey, setWorkerKey] = useState(0);
        const logQueue = useRef<LogEntry[]>([]);

        useEffect(() => {
          // Initialize Tokenizer on main thread
          try {
            const enc = get_encoding("cl100k_base");
            setEncoder(enc);
          } catch (e) {
            console.error("Failed to initialize tokenizer:", e);
            setLogs(prev => [...prev, { level: 'error', message: 'Failed to initialize tokenizer.', timestamp: Date.now() }]);
          }

          // Initialize Web Worker
          workerRef.current = new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' });

          const flushLogQueue = () => {
            if (logQueue.current.length > 0) {
              setLogs(prev => [...prev, ...logQueue.current]);
              logQueue.current = [];
            }
          };

          const handleWorkerMessage = (event: MessageEvent<WorkerResponse>) => {
            const { type, payload } = event.data;
            switch(type) {
              case 'init_success':
                setIsInitialized(true);
                // Don't use log queue here, as it might not be flushed if no other logs arrive.
                setLogs(prev => [...prev, { level: 'info', message: 'Analysis worker ready.', timestamp: Date.now() }]);
                break;
              case 'init_error':
                setLogs(prev => [...prev, { level: 'error', message: `Worker failed to initialize: ${payload.message}`, timestamp: Date.now() }]);
                break;
              case 'log':
                logQueue.current.push(payload);
                // Batch log updates to avoid excessive re-renders
                setTimeout(flushLogQueue, 50);
                break;
              case 'progress':
                setProgress(payload);
                break;
              case 'result':
                setAnalysisResult(payload.analysisResult);
                setIsLoading(false);
                flushLogQueue(); // Flush any remaining logs
                break;
              case 'error':
                setLogs(prev => [...prev, { level: 'error', message: `Analysis error: ${payload.message}`, timestamp: Date.now() }]);
                setIsLoading(false);
                flushLogQueue(); // Flush any remaining logs
                break;
            }
          };

          workerRef.current.onmessage = handleWorkerMessage;

          return () => {
            workerRef.current?.terminate();
          };
        }, [workerKey]);

        useEffect(() => {
          if (!encoder) return;
          try {
            const inputTokens = encoder.encode(filesInput).length;
            const outputTokens = encoder.encode(scnOutput).length;
            setTokenCounts({ input: inputTokens, output: outputTokens });
          } catch (e) {
            console.error("Tokenization error:", e);
            setTokenCounts({ input: 0, output: 0 });
          }
        }, [filesInput, scnOutput, encoder]);

        useEffect(() => {
          if (analysisResult) {
            setScnOutput(generateScn(analysisResult, formattingOptions));
          }
        }, [analysisResult, formattingOptions]);

        const handleCopy = useCallback(() => {
          if (scnOutput) {
            navigator.clipboard.writeText(scnOutput).then(
              () => {
                setIsCopied(true);
                setTimeout(() => setIsCopied(false), 2000);
              }
            );
          }
        }, [scnOutput]);

        const handleStop = useCallback(() => {
          if (!isLoading) return;
          // This triggers the useEffect cleanup to terminate the old worker
          // and create a new one, ensuring a clean state.
          setWorkerKey(k => k + 1);
          setIsLoading(false);
          setProgress(null);
          setAnalysisResult(null);
          setScnOutput('');
          setLogs(prev => [...prev, { level: 'warn', message: 'Analysis canceled by user.', timestamp: Date.now() }]);
          logQueue.current = [];
        }, [isLoading]);

        const handleAnalyze = useCallback(() => {
          if (!isInitialized) {
            setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
            return;
          }

          if (isLoading) {
            // Effectively a "cancel and restart" if clicked while running
            handleStop();
          }

          setIsLoading(true);
          setScnOutput('');
          setAnalysisResult(null);
          setProgress(null);
          setLogs([]);
          logQueue.current = [];

          workerRef.current?.postMessage({
            type: 'analyze',
            payload: { filesInput, logLevel: 'debug' },
          } as WorkerRequest);
        }, [filesInput, isInitialized, isLoading, handleStop]);

        return (
          <div className="h-screen w-screen flex bg-background text-foreground">
            {/* Sidebar */}
            <aside className="w-[30rem] max-w-[40%] flex-shrink-0 flex flex-col border-r">
              <div className="flex-shrink-0 flex items-center justify-between p-4 border-b">
                <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
                <div className="flex items-center space-x-2">
                  {isLoading ? (
                    <>
                      <Button disabled className="w-32 justify-center">
                        <Loader className="mr-2 h-4 w-4 animate-spin" />
                        <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                      </Button>
                      <Button onClick={handleStop} variant="outline" size="icon" title="Stop analysis">
                        <StopCircle className="h-4 w-4" />
                      </Button>
                    </>
                  ) : (
                    <Button onClick={handleAnalyze} disabled={!isInitialized} className="w-32 justify-center">
                      <Play className="mr-2 h-4 w-4" />
                      <span>Analyze</span>
                    </Button>
                  )}
                </div>
              </div>

              <div className="flex-grow overflow-y-auto">
                <Accordion type="multiple" defaultValue={['input', 'options', 'logs']} className="w-full">
                  <AccordionItem value="input">
                    <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                      <div className="flex w-full justify-between items-center">
                        <span>Input Files (JSON)</span>
                        <span className="text-xs font-normal text-muted-foreground tabular-nums">
                          {tokenCounts.input.toLocaleString()} tokens
                        </span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent>
                      <div className="px-4 pb-4 h-96">
                        <Textarea
                          value={filesInput}
                          onChange={(e) => setFilesInput(e.currentTarget.value)}
                          className="h-full w-full font-mono text-xs resize-none"
                          placeholder="Paste an array of FileContent objects here..."
                        />
                      </div>
                    </AccordionContent>
                  </AccordionItem>

                  <AccordionItem value="options">
                    <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Formatting Options</AccordionTrigger>
                    <AccordionContent className="px-4">
                      <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} />
                    </AccordionContent>
                  </AccordionItem>

                  <AccordionItem value="logs" className="border-b-0">
                    <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Logs</AccordionTrigger>
                    <AccordionContent className="px-4">
                      <div className="h-96">
                        <LogViewer logs={logs} />
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                </Accordion>
              </div>
            </aside>

            {/* Main Content Area */}
            <main className="flex-grow flex flex-col overflow-hidden">
              <div className="flex justify-between items-center p-4 border-b flex-shrink-0">
                <h2 className="text-lg font-semibold leading-none tracking-tight">Output (SCN)</h2>
                <div className="flex items-center gap-4">
                  <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                  <Button variant="ghost" size="icon" onClick={handleCopy} disabled={!scnOutput} title="Copy to clipboard">
                    {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                  </Button>
                </div>
              </div>
              <div className="p-4 flex-grow overflow-auto font-mono text-xs">
                <pre className="whitespace-pre-wrap">
                  {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
                </pre>
              </div>
            </main>
          </div>
        );
      }


      export default App;

      =======

      import { useState, useEffect, useCallback, useRef } from 'react';

      import { get_encoding, type Tiktoken } from 'tiktoken';

      import * as Comlink from 'comlink';

      import type { Remote } from 'comlink';

      import { generateScn } from '../../../index';

      import type { SourceFile } from '../../../index';

      import { defaultFilesJSON } from './default-files';

      import { Button } from './components/ui/button';

      import { Textarea } from './components/ui/textarea';

      import LogViewer from './components/LogViewer';

      import OutputOptions from './components/OutputOptions';

      import { Play, Loader, Copy, Check, StopCircle } from 'lucide-react';

      import type { LogEntry, ProgressData, FormattingOptions } from './types';

      import type { WorkerApi } from './worker';

      import { Accordion, AccordionContent, AccordionItem, AccordionTrigger }
      from './components/ui/accordion';


      function App() {
        const [isInitialized, setIsInitialized] = useState(false);
        const [isLoading, setIsLoading] = useState(false);
        const [filesInput, setFilesInput] = useState(defaultFilesJSON);
        const [scnOutput, setScnOutput] = useState('');
        const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
        const [isCopied, setIsCopied] = useState(false);
        const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
          showOutgoing: true,
          showIncoming: true,
          showIcons: true,
          showExportedIndicator: true,
          showPrivateIndicator: true,
          showModifiers: true,
          showTags: true,
          showSymbolIds: true,
          groupMembers: true,
          displayFilters: {},
          showFilePrefix: true,
          showFileIds: true,
        });
        const [progress, setProgress] = useState<ProgressData | null>(null);
        const [logs, setLogs] = useState<LogEntry[]>([]);
        const [encoder, setEncoder] = useState<Tiktoken | null>(null);
        const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });
        
        const workerRef = useRef<Remote<WorkerApi> | null>(null);
        const abortControllerRef = useRef<AbortController | null>(null);

        useEffect(() => {
          // Initialize Tokenizer on main thread
          try {
            const enc = get_encoding("cl100k_base");
            setEncoder(enc);
          } catch (e) {
            console.error("Failed to initialize tokenizer:", e);
            setLogs(prev => [...prev, { level: 'error', message: 'Failed to initialize tokenizer.', timestamp: Date.now() }]);
          }

          // Comlink setup
          const worker = new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' });
          const wrappedWorker = Comlink.wrap<WorkerApi>(worker);
          workerRef.current = wrappedWorker;

          const initializeWorker = async () => {
            try {
              await wrappedWorker.init();
              setIsInitialized(true);
              setLogs(prev => [...prev, { level: 'info', message: 'Analysis worker ready.', timestamp: Date.now() }]);
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              setLogs(prev => [...prev, { level: 'error', message: `Worker failed to initialize: ${message}`, timestamp: Date.now() }]);
            }
          };

          initializeWorker();

          return () => {
            wrappedWorker[Comlink.releaseProxy]();
            worker.terminate();
          };
        }, []);

        useEffect(() => {
          if (!encoder) return;
          try {
            const inputTokens = encoder.encode(filesInput).length;
            const outputTokens = encoder.encode(scnOutput).length;
            setTokenCounts({ input: inputTokens, output: outputTokens });
          } catch (e) {
            console.error("Tokenization error:", e);
            setTokenCounts({ input: 0, output: 0 });
          }
        }, [filesInput, scnOutput, encoder]);

        useEffect(() => {
          if (analysisResult) {
            setScnOutput(generateScn(analysisResult, formattingOptions));
          }
        }, [analysisResult, formattingOptions]);

        const handleCopy = useCallback(() => {
          if (scnOutput) {
            navigator.clipboard.writeText(scnOutput).then(
              () => {
                setIsCopied(true);
                setTimeout(() => setIsCopied(false), 2000);
              }
            );
          }
        }, [scnOutput]);

        const handleStop = useCallback(() => {
          if (abortControllerRef.current) {
            abortControllerRef.current.abort();
            abortControllerRef.current = null;
            setIsLoading(false);
            setProgress(null);
            setLogs(prev => [...prev, { level: 'warn', message: 'Analysis canceled by user.', timestamp: Date.now() }]);
          }
        }, []);

        const handleAnalyze = useCallback(async () => {
          if (!isInitialized || !workerRef.current) {
            setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
            return;
          }
          
          if (isLoading) {
            return; // Prevent multiple concurrent analyses
          }
          
          setIsLoading(true);
          setScnOutput('');
          setAnalysisResult(null);
          setProgress(null);
          setLogs([]);

          abortControllerRef.current = new AbortController();
          const { signal } = abortControllerRef.current;

          const onLog = (log: LogEntry) => {
            setLogs(prev => [...prev, log]);
          };

          try {
            const result = await workerRef.current.analyze(
              { filesInput, logLevel: 'debug' },
              Comlink.proxy(setProgress),
              Comlink.proxy(onLog),
              signal,
            );
            setAnalysisResult(result);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            // Don't show error if it was a user cancellation
            if ((error as Error).name !== 'AbortError') {
              setLogs(prev => [...prev, { level: 'error', message: `Analysis error: ${message}`, timestamp: Date.now() }]);
            }
          } finally {
            setIsLoading(false);
            abortControllerRef.current = null;
          }
        }, [filesInput, isInitialized, isLoading]);

        return (
          <div className="h-screen w-screen flex bg-background text-foreground">
            {/* Sidebar */}
            <aside className="w-[30rem] max-w-[40%] flex-shrink-0 flex flex-col border-r">
              <div className="flex-shrink-0 flex items-center justify-between p-4 border-b">
                <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
                <div className="flex items-center space-x-2">
                  {isLoading ? (
                    <>
                      <Button disabled className="w-32 justify-center">
                        <Loader className="mr-2 h-4 w-4 animate-spin" />
                        <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                      </Button>
                      <Button onClick={handleStop} variant="outline" size="icon" title="Stop analysis">
                        <StopCircle className="h-4 w-4" />
                      </Button>
                    </>
                  ) : (
                    <Button onClick={handleAnalyze} disabled={!isInitialized} className="w-32 justify-center">
                      <Play className="mr-2 h-4 w-4" />
                      <span>Analyze</span>
                    </Button>
                  )}
                </div>
              </div>

              <div className="flex-grow overflow-y-auto">
                <Accordion type="multiple" defaultValue={['input', 'options', 'logs']} className="w-full">
                  <AccordionItem value="input">
                    <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                      <div className="flex w-full justify-between items-center">
                        <span>Input Files (JSON)</span>
                        <span className="text-xs font-normal text-muted-foreground tabular-nums">
                          {tokenCounts.input.toLocaleString()} tokens
                        </span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent>
                      <div className="px-4 pb-4 h-96">
                        <Textarea
                          value={filesInput}
                          onChange={(e) => setFilesInput(e.currentTarget.value)}
                          className="h-full w-full font-mono text-xs resize-none"
                          placeholder="Paste an array of FileContent objects here..."
                        />
                      </div>
                    </AccordionContent>
                  </AccordionItem>

                  <AccordionItem value="options">
                    <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Formatting Options</AccordionTrigger>
                    <AccordionContent className="px-4">
                      <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} />
                    </AccordionContent>
                  </AccordionItem>

                  <AccordionItem value="logs" className="border-b-0">
                    <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Logs</AccordionTrigger>
                    <AccordionContent className="px-4">
                      <div className="h-96">
                        <LogViewer logs={logs} />
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                </Accordion>
              </div>
            </aside>

            {/* Main Content Area */}
            <main className="flex-grow flex flex-col overflow-hidden">
              <div className="flex justify-between items-center p-4 border-b flex-shrink-0">
                <h2 className="text-lg font-semibold leading-none tracking-tight">Output (SCN)</h2>
                <div className="flex items-center gap-4">
                  <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                  <Button variant="ghost" size="icon" onClick={handleCopy} disabled={!scnOutput} title="Copy to clipboard">
                    {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                  </Button>
                </div>
              </div>
              <div className="p-4 flex-grow overflow-auto font-mono text-xs">
                <pre className="whitespace-pre-wrap">
                  {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
                </pre>
              </div>
            </main>
          </div>
        );
      }


      export default App;

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  packages/scn-ts-web-demo/package.json: |
    {
      "name": "scn-ts-web-demo",
      "private": true,
      "version": "0.1.0",
      "type": "module",
      "scripts": {
        "dev": "vite",
        "build": "tsc && vite build",
        "check": "tsc --noEmit",
        "preview": "vite preview",
        "prepare": "node scripts/prepare-wasm.cjs"
      },
      "dependencies": {
        "@radix-ui/react-accordion": "^1.1.2",
        "@radix-ui/react-slot": "^1.0.2",
        "class-variance-authority": "^0.7.0",
        "clsx": "^2.1.1",
        "lucide-react": "^0.379.0",
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "tailwind-merge": "^2.3.0",
        "tiktoken": "^1.0.14"
      },
      "devDependencies": {
        "@types/node": "^20.12.12",
        "@types/react": "^18.3.3",
        "@types/react-dom": "^18.3.0",
        "@vitejs/plugin-react": "^4.3.0",
        "autoprefixer": "^10.4.19",
        "eslint": "^8.57.0",
        "postcss": "^8.4.38",
        "tailwindcss": "^3.4.3",
        "typescript": "^5.4.5",
        "vite": "^5.2.12",
        "vite-plugin-top-level-await": "^1.4.1",
        "vite-plugin-wasm": "^3.3.0"
      }
    }
  src/types.ts: >-
    import type { Parser, Tree, Language } from 'web-tree-sitter';

    import type { PathResolver } from './utils/tsconfig';

    export type { PathResolver };


    export type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'silent';


    export type LogHandler = (level: Exclude<LogLevel, 'silent'>, ...args:
    any[]) => void;


    export interface TsConfig {
        compilerOptions?: {
            baseUrl?: string;
            paths?: Record<string, string[]>;
        };
    }


    export interface AnalyzeProjectOptions {
        files: InputFile[];
        tsconfig?: TsConfig;
        root?: string;
        onProgress?: (progress: { percentage: number; message: string }) => void;
        logLevel?: LogLevel;
    }


    /**
     * Options to control the SCN output format.
     */
    export interface FormattingOptions {
        showOutgoing?: boolean;
        showIncoming?: boolean;
        showIcons?: boolean;
        showExportedIndicator?: boolean; // + prefix
        showPrivateIndicator?: boolean; // - prefix
        showModifiers?: boolean; // ..., !, o
        showTags?: boolean;      // [generated], [styled], etc.
        showSymbolIds?: boolean; // (1.2) identifiers
        groupMembers?: boolean;  // group class/interface members under parent
        displayFilters?: Partial<Record<SymbolKind, boolean>>;
        showFilePrefix?: boolean; // ยง prefix, defaults to true
        showFileIds?: boolean;    // (1) file identifiers in headers and references, defaults to true
    }


    /**
     * Represents a file to be processed.
     */
    export interface InputFile {
      path: string; // relative path from root
      content: string;
    }


    /**
     * Configuration for the SCN generation process.
     */
    export interface ScnTsConfig {
      files: InputFile[];
      tsconfig?: TsConfig;
      formattingOptions?: FormattingOptions;
      root?: string; // Optional: A virtual root path for resolution. Defaults to '/'.
      _test_id?: string; // Special property for test runner to identify fixtures
    }


    /**
     * Options for initializing the Tree-sitter parser.
     */
    export interface ParserInitOptions {
        wasmBaseUrl: string;
    }


    /**
     * Represents a supported programming language and its configuration.
     */
    export type SymbolKind =
      // TS/JS
      | 'class' | 'interface' | 'function' | 'method' | 'constructor'
      | 'variable' | 'property' | 'enum' | 'enum_member' | 'type_alias' | 'module'
      | 'decorator' | 'parameter' | 'type_parameter' | 'import_specifier' | 're_export'
      // React
      | 'react_component' | 'react_hook' | 'react_hoc' | 'jsx_attribute' | 'jsx_element' | 'styled_component'
      // CSS
      | 'css_class' | 'css_id' | 'css_tag' | 'css_at_rule' | 'css_property' | 'css_variable'
      // Generic / Meta
      | 'file' | 'reference' | 'comment' | 'error' | 'unresolved'
      // Other Languages
      | 'go_package' | 'go_struct' | 'go_goroutine' | 'rust_struct' | 'rust_trait' | 'rust_impl' | 'rust_macro'
      | 'java_package' | 'python_class'
      | 'unknown';

    export interface Position {
      line: number;
      column: number;
    }


    export interface Range {
      start: Position;
      end: Position;
    }


    export interface CodeSymbol {
      id: string;
      fileId: number;
      name: string;
      kind: SymbolKind;
      range: Range;
      // Modifiers and metadata
      isExported: boolean;
      isAbstract?: boolean;
      isStatic?: boolean;
      isReadonly?: boolean;
      isAsync?: boolean;
      isPure?: boolean; // for 'o'
      throws?: boolean; // for '!'
      labels?: string[]; // extra display labels like [symbol], [proxy]
      isGenerated?: boolean;
      languageDirectives?: string[]; // e.g. 'use server'
      superClass?: string;
      implementedInterfaces?: string[];
      scopeRange: Range; // The range of the entire scope (e.g., function body) for relationship association
      accessibility?: 'public' | 'private' | 'protected';
      // Type information and signatures
      signature?: string; // e.g., (a: #number, b: #number): #number
      typeAnnotation?: string; // e.g., #string for properties/variables
      typeAliasValue?: string; // e.g., #number|string for type aliases
      // Relationships
      dependencies: Relationship[];
    }


    export type RelationshipKind =
      | 'import'
      | 'dynamic_import'
      | 'reference'
      | 'tagged'
      | 'export'
      | 'call'
      | 'extends'
      | 'implements'
      | 'references'
      | 'aliased'
      | 'goroutine'
      | 'macro';

    export interface Relationship {
      targetName: string; // The raw name of the target (e.g., './utils', 'MyClass', 'add', 'Button')
      kind: RelationshipKind;
      range: Range;
      // Resolved info
      resolvedFileId?: number;
      resolvedSymbolId?: string;
    }


    export interface SourceFile {
      id: number;
      relativePath: string;
      absolutePath: string;
      language: LanguageConfig;
      sourceCode: string;
      ast?: Tree;
      symbols: CodeSymbol[];
      parseError: boolean;
      isGenerated?: boolean;
      languageDirectives?: string[];
      // File-level relationships (e.g., imports not tied to a specific symbol)
      fileRelationships?: Relationship[];
    }


    /**
     * Represents a supported programming language and its configuration.
     */
    export interface LanguageConfig {
        id: string;
        name: string;
        extensions: string[];
        wasmPath: string;
        parser?: Parser;
        loadedLanguage?: Language;
        queries?: Record<string, string>;
    }


    export interface AnalysisContext {
        sourceFiles: SourceFile[];
        pathResolver: PathResolver;
    }
  src/main.ts: >-
    import { getLanguageForFile } from './languages';

    import { initializeParser as init, parse } from './parser';

    import type { ParserInitOptions, SourceFile, InputFile, ScnTsConfig,
    AnalyzeProjectOptions, FormattingOptions } from './types';

    import { analyze } from './analyzer';

    import { formatScn } from './formatter';

    import path from './utils/path';

    import { getPathResolver } from './utils/tsconfig';

    import { resolveGraph } from './graph-resolver';

    import { logger } from './logger';


    /**
     * Public API to initialize the parser. Must be called before any other APIs.
     */
    export const initializeParser = (options: ParserInitOptions): Promise<void>
    => init(options);


    // Types for web demo

    export type { ParserInitOptions, SourceFile, LogLevel, InputFile, TsConfig,
    ScnTsConfig, AnalyzeProjectOptions, LogHandler, FormattingOptions } from
    './types';

    export type FileContent = InputFile;


    // Exports for web demo

    export { logger };


    /**
     * Generate SCN from analyzed source files
     */
    export const generateScn = (analyzedFiles: SourceFile[], options?:
    FormattingOptions): string => {
        return formatScn(analyzedFiles, options);
    };


    /**
     * Legacy API: Generate SCN from config (for backward compatibility)
     */
    export const generateScnFromConfig = async (config: ScnTsConfig):
    Promise<string> => {
        const analyzedFiles = await analyzeProject({
            files: config.files,
            tsconfig: config.tsconfig,
            root: config.root,
        });
        return formatScn(analyzedFiles, config.formattingOptions);
    };


    /**
     * Parses and analyzes a project's files to build a dependency graph.
     */
    export const analyzeProject = async ({
        files,
        tsconfig,
        root = '/',
        onProgress,
        logLevel,
    }: AnalyzeProjectOptions): Promise<SourceFile[]> => {
        if (logLevel) {
            logger.setLevel(logLevel);
        }
        const pathResolver = getPathResolver(tsconfig);

        let fileIdCounter = 1;

        onProgress?.({ percentage: 0, message: 'Creating source files...' });

        // Step 1: Create SourceFile objects for all files
        const sourceFiles = files.map((file) => {
            const absolutePath = path.join(root, file.path);
            const sourceFile: SourceFile = {
                id: fileIdCounter++,
                relativePath: file.path,
                absolutePath,
                sourceCode: file.content,
                language: getLanguageForFile(file.path)!,
                symbols: [],
                parseError: false,
            };
            return sourceFile;
        });

        onProgress?.({ percentage: 10, message: `Parsing ${sourceFiles.length} files...` });

        // Step 2: Parse all files
        const parsedFiles = sourceFiles.map((file, i) => {
            if (!file.language || !file.language.wasmPath || file.sourceCode.trim() === '') {
                return file;
            }
            const tree = parse(file.sourceCode, file.language);
            if (!tree) {
                file.parseError = true;
                logger.warn(`Failed to parse ${file.relativePath}`);
            } else {
                file.ast = tree;
            }
            const percentage = 10 + (40 * (i + 1) / sourceFiles.length);
            onProgress?.({ percentage, message: `Parsing ${file.relativePath}` });
            return file;
        });

        onProgress?.({ percentage: 50, message: 'Analyzing files...' });

        // Step 3: Analyze all parsed files
        const analyzedFiles = parsedFiles.map((file, i) => {
            if (file.ast) {
                const analyzed = analyze(file);
                const percentage = 50 + (40 * (i + 1) / sourceFiles.length);
                onProgress?.({ percentage, message: `Analyzing ${file.relativePath}` });
                return analyzed;
            }
            return file;
        });
        
        onProgress?.({ percentage: 90, message: 'Resolving dependency graph...' });

        // Step 4: Resolve the dependency graph across all files
        const resolvedGraph = resolveGraph(analyzedFiles, pathResolver, root);
        
        onProgress?.({ percentage: 100, message: 'Analysis complete.' });
        return resolvedGraph;
    };
  packages/scn-ts-web-demo/src/worker.ts: |-
    import {
      initializeParser,
      analyzeProject,
      logger,
    } from '../../../index';
    import type {
      FileContent,
      LogHandler,
      LogLevel,
      SourceFile,
    } from '../../../index';
    import type { ProgressData } from './types';

    // Define message types for communication
    export type WorkerRequest = {
      type: 'analyze';
      payload: {
        filesInput: string;
        logLevel: LogLevel;
      };
    };

    export type WorkerResponse =
      | { type: 'log'; payload: { level: Exclude<LogLevel, 'silent'>; message: string; timestamp: number } }
      | { type: 'progress'; payload: ProgressData }
      | { type: 'result'; payload: { analysisResult: SourceFile[] } }
      | { type: 'error'; payload: { message: string } }
      | { type: 'init_success' }
      | { type: 'init_error'; payload: { message: string } };

    let isInitialized = false;

    // Initialize parser once when the worker starts
    async function initialize() {
      try {
        // The path is relative to the worker script's location
        await initializeParser({ wasmBaseUrl: '/wasm/' });
        isInitialized = true;
        self.postMessage({ type: 'init_success' } as WorkerResponse);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        self.postMessage({ type: 'init_error', payload: { message } } as WorkerResponse);
      }
    }

    initialize();

    self.onmessage = async (event: MessageEvent<WorkerRequest>) => {
      if (event.data.type !== 'analyze') return;
      if (!isInitialized) {
        self.postMessage({
          type: 'error',
          payload: { message: 'Worker not initialized yet.' },
        } as WorkerResponse);
        return;
      }

      const { filesInput, logLevel } = event.data.payload;

      const logHandler: LogHandler = (level, ...args) => {
        const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
        self.postMessage({ type: 'log', payload: { level, message, timestamp: Date.now() } } as WorkerResponse);
      };
      logger.setLogHandler(logHandler);
      logger.setLevel(logLevel);

      const onProgress = (progressData: ProgressData) => {
        self.postMessage({ type: 'progress', payload: progressData } as WorkerResponse);
      };

      try {
        let files: FileContent[] = [];
        try {
          files = JSON.parse(filesInput);
          if (!Array.isArray(files)) throw new Error("Input is not an array.");
        } catch (error) {
          throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
        }

        const analysisResult = await analyzeProject({
          files,
          onProgress,
          logLevel,
        });

        // Sanitize the result to make it structured-clonable for postMessage.
        // The `ast` and tree-sitter language/parser instances are not clonable.
        analysisResult.forEach(file => {
          delete file.ast;
          if (file.language) {
            delete file.language.parser;
            delete file.language.loadedLanguage;
          }
        });

        self.postMessage({ type: 'result', payload: { analysisResult } } as WorkerResponse);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        self.postMessage({ type: 'error', payload: { message } } as WorkerResponse);
      } finally {
        logger.setLogHandler(null);
      }
    };
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback, useRef } from 'react';

    import { get_encoding, type Tiktoken } from 'tiktoken';

    import { generateScn } from '../../../index';

    import type { SourceFile } from '../../../index';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import OutputOptions from './components/OutputOptions';

    import { Play, Loader, Copy, Check, StopCircle } from 'lucide-react';

    import type { LogEntry, ProgressData, FormattingOptions } from './types';

    import type { WorkerRequest, WorkerResponse } from './worker';

    import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from
    './components/ui/accordion';


    function App() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
      const [isCopied, setIsCopied] = useState(false);
      const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
        showOutgoing: true,
        showIncoming: true,
        showIcons: true,
        showExportedIndicator: true,
        showPrivateIndicator: true,
        showModifiers: true,
        showTags: true,
        showSymbolIds: true,
        groupMembers: true,
        displayFilters: {},
        showFilePrefix: true,
        showFileIds: true,
      });
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [encoder, setEncoder] = useState<Tiktoken | null>(null);
      const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });
      
      const workerRef = useRef<Worker | null>(null);
      const [workerKey, setWorkerKey] = useState(0);
      const logQueue = useRef<LogEntry[]>([]);

      useEffect(() => {
        // Initialize Tokenizer on main thread
        try {
          const enc = get_encoding("cl100k_base");
          setEncoder(enc);
        } catch (e) {
          console.error("Failed to initialize tokenizer:", e);
          setLogs(prev => [...prev, { level: 'error', message: 'Failed to initialize tokenizer.', timestamp: Date.now() }]);
        }

        // Initialize Web Worker
        workerRef.current = new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' });

        const flushLogQueue = () => {
          if (logQueue.current.length > 0) {
            setLogs(prev => [...prev, ...logQueue.current]);
            logQueue.current = [];
          }
        };

        const handleWorkerMessage = (event: MessageEvent<WorkerResponse>) => {
          const { type, payload } = event.data;
          switch(type) {
            case 'init_success':
              setIsInitialized(true);
              // Don't use log queue here, as it might not be flushed if no other logs arrive.
              setLogs(prev => [...prev, { level: 'info', message: 'Analysis worker ready.', timestamp: Date.now() }]);
              break;
            case 'init_error':
              setLogs(prev => [...prev, { level: 'error', message: `Worker failed to initialize: ${payload.message}`, timestamp: Date.now() }]);
              break;
            case 'log':
              logQueue.current.push(payload);
              // Batch log updates to avoid excessive re-renders
              setTimeout(flushLogQueue, 50);
              break;
            case 'progress':
              setProgress(payload);
              break;
            case 'result':
              setAnalysisResult(payload.analysisResult);
              setIsLoading(false);
              flushLogQueue(); // Flush any remaining logs
              break;
            case 'error':
              setLogs(prev => [...prev, { level: 'error', message: `Analysis error: ${payload.message}`, timestamp: Date.now() }]);
              setIsLoading(false);
              flushLogQueue(); // Flush any remaining logs
              break;
          }
        };

        workerRef.current.onmessage = handleWorkerMessage;

        return () => {
          workerRef.current?.terminate();
        };
      }, [workerKey]);

      useEffect(() => {
        if (!encoder) return;
        try {
          const inputTokens = encoder.encode(filesInput).length;
          const outputTokens = encoder.encode(scnOutput).length;
          setTokenCounts({ input: inputTokens, output: outputTokens });
        } catch (e) {
          console.error("Tokenization error:", e);
          setTokenCounts({ input: 0, output: 0 });
        }
      }, [filesInput, scnOutput, encoder]);

      useEffect(() => {
        if (analysisResult) {
          setScnOutput(generateScn(analysisResult, formattingOptions));
        }
      }, [analysisResult, formattingOptions]);

      const handleCopy = useCallback(() => {
        if (scnOutput) {
          navigator.clipboard.writeText(scnOutput).then(
            () => {
              setIsCopied(true);
              setTimeout(() => setIsCopied(false), 2000);
            }
          );
        }
      }, [scnOutput]);

      const handleStop = useCallback(() => {
        if (!isLoading) return;
        // This triggers the useEffect cleanup to terminate the old worker
        // and create a new one, ensuring a clean state.
        setWorkerKey(k => k + 1);
        setIsLoading(false);
        setProgress(null);
        setAnalysisResult(null);
        setScnOutput('');
        setLogs(prev => [...prev, { level: 'warn', message: 'Analysis canceled by user.', timestamp: Date.now() }]);
        logQueue.current = [];
      }, [isLoading]);

      const handleAnalyze = useCallback(() => {
        if (!isInitialized) {
          setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
          return;
        }

        if (isLoading) {
          // Effectively a "cancel and restart" if clicked while running
          handleStop();
        }

        setIsLoading(true);
        setScnOutput('');
        setAnalysisResult(null);
        setProgress(null);
        setLogs([]);
        logQueue.current = [];

        workerRef.current?.postMessage({
          type: 'analyze',
          payload: { filesInput, logLevel: 'debug' },
        } as WorkerRequest);
      }, [filesInput, isInitialized, isLoading, handleStop]);

      return (
        <div className="h-screen w-screen flex bg-background text-foreground">
          {/* Sidebar */}
          <aside className="w-[30rem] max-w-[40%] flex-shrink-0 flex flex-col border-r">
            <div className="flex-shrink-0 flex items-center justify-between p-4 border-b">
              <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
              <div className="flex items-center space-x-2">
                {isLoading ? (
                  <>
                    <Button disabled className="w-32 justify-center">
                      <Loader className="mr-2 h-4 w-4 animate-spin" />
                      <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                    </Button>
                    <Button onClick={handleStop} variant="outline" size="icon" title="Stop analysis">
                      <StopCircle className="h-4 w-4" />
                    </Button>
                  </>
                ) : (
                  <Button onClick={handleAnalyze} disabled={!isInitialized} className="w-32 justify-center">
                    <Play className="mr-2 h-4 w-4" />
                    <span>Analyze</span>
                  </Button>
                )}
              </div>
            </div>

            <div className="flex-grow overflow-y-auto">
              <Accordion type="multiple" defaultValue={['input', 'options', 'logs']} className="w-full">
                <AccordionItem value="input">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                    <div className="flex w-full justify-between items-center">
                      <span>Input Files (JSON)</span>
                      <span className="text-xs font-normal text-muted-foreground tabular-nums">
                        {tokenCounts.input.toLocaleString()} tokens
                      </span>
                    </div>
                  </AccordionTrigger>
                  <AccordionContent>
                    <div className="px-4 pb-4 h-96">
                      <Textarea
                        value={filesInput}
                        onChange={(e) => setFilesInput(e.currentTarget.value)}
                        className="h-full w-full font-mono text-xs resize-none"
                        placeholder="Paste an array of FileContent objects here..."
                      />
                    </div>
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="options">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Formatting Options</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="logs" className="border-b-0">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Logs</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <div className="h-96">
                      <LogViewer logs={logs} />
                    </div>
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </div>
          </aside>

          {/* Main Content Area */}
          <main className="flex-grow flex flex-col overflow-hidden">
            <div className="flex justify-between items-center p-4 border-b flex-shrink-0">
              <h2 className="text-lg font-semibold leading-none tracking-tight">Output (SCN)</h2>
              <div className="flex items-center gap-4">
                <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                <Button variant="ghost" size="icon" onClick={handleCopy} disabled={!scnOutput} title="Copy to clipboard">
                  {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                </Button>
              </div>
            </div>
            <div className="p-4 flex-grow overflow-auto font-mono text-xs">
              <pre className="whitespace-pre-wrap">
                {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
              </pre>
            </div>
          </main>
        </div>
      );
    }


    export default App;
approved: true
