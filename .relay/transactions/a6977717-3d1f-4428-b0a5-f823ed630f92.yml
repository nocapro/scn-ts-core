uuid: a6977717-3d1f-4428-b0a5-f823ed630f92
projectId: scn-ts-core
createdAt: '2025-09-05T01:07:26.947Z'
linesAdded: 38
linesRemoved: 35
gitCommitMsg: 'fix(web-demo): defer analysis to update UI loading state correctly'
promptSummary: Fix the analyze button state not updating during processing.
reasoning:
  - >-
    ok, got it. the UI update isn't happening because the analysis work is
    blocking the main thread. classic mistake. the fix is to schedule the heavy
    lifting on a new turn of the event loop with `setTimeout`, allowing react to
    render the loading state first.
  - i'll patch `App.tsx` to defer the analysis.
  - '---'
operations:
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: >-
      --- packages/scn-ts-web-demo/src/App.tsx

      +++ packages/scn-ts-web-demo/src/App.tsx

      @@ -95,62 +95,66 @@
           }
         }, []);
       
      -  const handleAnalyze = useCallback(async () => {

      +  const handleAnalyze = useCallback(() => {
           if (!isInitialized) {
             setLogs(prev => [...prev, { level: 'warn', message: 'Parser not ready.', timestamp: Date.now() }]);
             return;
           }
       
           setIsLoading(true);
      -    setLogs([]);
           setScnOutput('');
           setAnalysisResult(null);
           setProgress(null);
      +    setLogs([]);
       
      -    abortControllerRef.current = new AbortController();

      -    const signal = abortControllerRef.current.signal;

      +    // Defer the heavy work to allow UI to update to the loading state

      +    setTimeout(async () => {

      +      abortControllerRef.current = new AbortController();

      +      const signal = abortControllerRef.current.signal;
       
      -    const logHandler: LogHandler = (level, ...args) => {

      -      const message = args.map(arg => typeof arg === 'object' ?
      JSON.stringify(arg) : String(arg)).join(' ');

      -      setLogs(prev => [...prev, { level, message, timestamp: Date.now()
      }]);

      -    };

      -    logger.setLogHandler(logHandler);

      -    logger.setLevel('debug');

      +      const logHandler: LogHandler = (level, ...args) => {

      +        const message = args.map(arg => typeof arg === 'object' ?
      JSON.stringify(arg) : String(arg)).join(' ');

      +        setLogs(prev => [...prev, { level, message, timestamp: Date.now()
      }]);

      +      };

      +      logger.setLogHandler(logHandler);

      +      logger.setLevel('debug');
       
      -    const onProgress = (progressData: ProgressData) => {

      -      setProgress(progressData);

      -      logger.info(`[${Math.round(progressData.percentage)}%]
      ${progressData.message}`);

      -    };

      +      const onProgress = (progressData: ProgressData) => {

      +        setProgress(progressData);

      +        logger.info(`[${Math.round(progressData.percentage)}%]
      ${progressData.message}`);

      +      };
       
      -    try {

      -      let files: FileContent[] = [];
             try {
      -        files = JSON.parse(filesInput);

      -        if (!Array.isArray(files)) throw new Error("Input is not an
      array.");

      +        let files: FileContent[] = [];

      +        try {

      +          files = JSON.parse(filesInput);

      +          if (!Array.isArray(files)) throw new Error("Input is not an
      array.");

      +        } catch (error) {

      +          throw new Error(`Invalid JSON input: ${error instanceof Error ?
      error.message : String(error)}`);

      +        }

      +

      +        const rankedGraph = await analyzeProject({ files, onProgress,
      logLevel: 'debug', signal });

      +        setAnalysisResult(rankedGraph);
             } catch (error) {
      -        throw new Error(`Invalid JSON input: ${error instanceof Error ?
      error.message : String(error)}`);

      +        const message = error instanceof Error ? error.message :
      String(error);

      +        if ((error as Error).name === 'AbortError') {

      +          logger.warn('Analysis canceled by user.');

      +        } else {

      +          logger.error('Analysis failed:', message);

      +        }

      +      } finally {

      +        setIsLoading(false);

      +        abortControllerRef.current = null;

      +        setProgress(null);

      +        logger.setLogHandler(null);
             }
      -

      -      const rankedGraph = await analyzeProject({ files, onProgress,
      logLevel: 'debug', signal });

      -      setAnalysisResult(rankedGraph);

      -    } catch (error) {

      -      const message = error instanceof Error ? error.message :
      String(error);

      -      if ((error as Error).name === 'AbortError') {

      -        logger.warn('Analysis canceled by user.');

      -      } else {

      -        logger.error('Analysis failed:', message);

      -      }

      -    } finally {

      -      setIsLoading(false);

      -      abortControllerRef.current = null;

      -      setProgress(null);

      -      logger.setLogHandler(null);

      -    }

      +    }, 0);
         }, [filesInput, isInitialized]);
       
         return (
    patchStrategy: new-unified
snapshot:
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback, useRef } from 'react';

    import { get_encoding, type Tiktoken } from 'tiktoken';

    import {
      initializeParser,
      logger,
      analyzeProject,
      generateScn,
    } from '../../../index';

    import type { FileContent, LogHandler, SourceFile } from '../../../index';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import OutputOptions from './components/OutputOptions';

    import { Play, Loader, Copy, Check, StopCircle } from 'lucide-react';

    import type { LogEntry, ProgressData, FormattingOptions } from './types';

    import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from
    './components/ui/accordion';


    function App() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
      const [isCopied, setIsCopied] = useState(false);
      const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
        showOutgoing: true,
        showIncoming: true,
        showIcons: true,
        showExportedIndicator: true,
        showPrivateIndicator: true,
        showModifiers: true,
        showTags: true,
        showSymbolIds: true,
        groupMembers: true,
        displayFilters: {},
        showFilePrefix: true,
        showFileIds: true,
      });
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [encoder, setEncoder] = useState<Tiktoken | null>(null);
      const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });
      const initCalled = useRef(false);
      const abortControllerRef = useRef<AbortController | null>(null);

      useEffect(() => {
        if (initCalled.current) {
          return;
        }
        initCalled.current = true;

        const init = async () => {
          try {
            await initializeParser({ wasmBaseUrl: '/wasm/' });
            const enc = get_encoding("cl100k_base");
            setEncoder(enc);
            setIsInitialized(true);
            setLogs(prev => [...prev, { level: 'info', message: 'Parser and tokenizer initialized.', timestamp: Date.now() }]);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            setLogs(prev => [...prev, { level: 'error', message: `Failed to initialize: ${message}`, timestamp: Date.now() }]);
          }
        };
        init();
      }, []);

      useEffect(() => {
        if (!encoder) return;
        try {
          const inputTokens = encoder.encode(filesInput).length;
          const outputTokens = encoder.encode(scnOutput).length;
          setTokenCounts({ input: inputTokens, output: outputTokens });
        } catch (e) {
          console.error("Tokenization error:", e);
          setTokenCounts({ input: 0, output: 0 });
        }
      }, [filesInput, scnOutput, encoder]);

      useEffect(() => {
        if (analysisResult) {
          const scn = generateScn(analysisResult, formattingOptions);
          setScnOutput(scn);
        }
      }, [analysisResult, formattingOptions]);

      const handleCopy = useCallback(() => {
        if (scnOutput) {
          navigator.clipboard.writeText(scnOutput).then(
            () => {
              setIsCopied(true);
              setTimeout(() => setIsCopied(false), 2000);
            }
          );
        }
      }, [scnOutput]);

      const handleStop = useCallback(() => {
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
        }
      }, []);

      const handleAnalyze = useCallback(async () => {
        if (!isInitialized) {
          setLogs(prev => [...prev, { level: 'warn', message: 'Parser not ready.', timestamp: Date.now() }]);
          return;
        }

        setIsLoading(true);
        setLogs([]);
        setScnOutput('');
        setAnalysisResult(null);
        setProgress(null);

        abortControllerRef.current = new AbortController();
        const signal = abortControllerRef.current.signal;

        const logHandler: LogHandler = (level, ...args) => {
          const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
          setLogs(prev => [...prev, { level, message, timestamp: Date.now() }]);
        };
        logger.setLogHandler(logHandler);
        logger.setLevel('debug');

        const onProgress = (progressData: ProgressData) => {
          setProgress(progressData);
          logger.info(`[${Math.round(progressData.percentage)}%] ${progressData.message}`);
        };

        try {
          let files: FileContent[] = [];
          try {
            files = JSON.parse(filesInput);
            if (!Array.isArray(files)) throw new Error("Input is not an array.");
          } catch (error) {
            throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
          }

          const rankedGraph = await analyzeProject({ files, onProgress, logLevel: 'debug', signal });
          setAnalysisResult(rankedGraph);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          if ((error as Error).name === 'AbortError') {
            logger.warn('Analysis canceled by user.');
          } else {
            logger.error('Analysis failed:', message);
          }
        } finally {
          setIsLoading(false);
          abortControllerRef.current = null;
          setProgress(null);
          logger.setLogHandler(null);
        }
      }, [filesInput, isInitialized]);

      return (
        <div className="h-screen w-screen flex bg-background text-foreground">
          {/* Sidebar */}
          <aside className="w-[30rem] max-w-[40%] flex-shrink-0 flex flex-col border-r">
            <div className="flex-shrink-0 flex items-center justify-between p-4 border-b">
              <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
              <div className="flex items-center space-x-2">
                {isLoading ? (
                  <>
                    <Button disabled className="w-32 justify-center">
                      <Loader className="mr-2 h-4 w-4 animate-spin" />
                      <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                    </Button>
                    <Button onClick={handleStop} variant="outline" size="icon" title="Stop analysis">
                      <StopCircle className="h-4 w-4" />
                    </Button>
                  </>
                ) : (
                  <Button onClick={handleAnalyze} disabled={!isInitialized} className="w-32 justify-center">
                    <Play className="mr-2 h-4 w-4" />
                    <span>Analyze</span>
                  </Button>
                )}
              </div>
            </div>

            <div className="flex-grow overflow-y-auto">
              <Accordion type="multiple" defaultValue={['input', 'options', 'logs']} className="w-full">
                <AccordionItem value="input">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                    <div className="flex w-full justify-between items-center">
                      <span>Input Files (JSON)</span>
                      <span className="text-xs font-normal text-muted-foreground tabular-nums">
                        {tokenCounts.input.toLocaleString()} tokens
                      </span>
                    </div>
                  </AccordionTrigger>
                  <AccordionContent>
                    <div className="px-4 pb-4 h-96">
                      <Textarea
                        value={filesInput}
                        onChange={(e) => setFilesInput(e.currentTarget.value)}
                        className="h-full w-full font-mono text-xs resize-none"
                        placeholder="Paste an array of FileContent objects here..."
                      />
                    </div>
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="options">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Formatting Options</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="logs" className="border-b-0">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Logs</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <div className="h-96">
                      <LogViewer logs={logs} />
                    </div>
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </div>
          </aside>

          {/* Main Content Area */}
          <main className="flex-grow flex flex-col overflow-hidden">
            <div className="flex justify-between items-center p-4 border-b flex-shrink-0">
              <h2 className="text-lg font-semibold leading-none tracking-tight">Output (SCN)</h2>
              <div className="flex items-center gap-4">
                <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                <Button variant="ghost" size="icon" onClick={handleCopy} disabled={!scnOutput} title="Copy to clipboard">
                  {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                </Button>
              </div>
            </div>
            <div className="p-4 flex-grow overflow-auto font-mono text-xs">
              <pre className="whitespace-pre-wrap">
                {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
              </pre>
            </div>
          </main>
        </div>
      );
    }


    export default App;
approved: true
