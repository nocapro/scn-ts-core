uuid: 13a483de-7b00-410a-9d90-67c69994c637
projectId: scn-ts-core
createdAt: '2025-09-05T04:38:40.124Z'
linesAdded: 97
linesRemoved: 36
gitCommitMsg: >-
  refactor(web-demo): extract app state and analysis logic into stores and
  services
promptSummary: >-
  Refactor the web demo to extract state management to `.store.ts` files and
  business logic to `.service.ts` files for better separation of concerns.
reasoning:
  - >-
    Alright, let's refactor this codebase to get a better separation of
    concerns. The goal is to extract state management logic into "stores" and
    business/communication logic into "services", as you requested. The existing
    hooks are already well-named, so we'll focus on creating stores and services
    where it makes sense.
  - >-
    First, I'll extract the application state from `App.tsx` into a custom hook
    that will act as our "store". I'll put this in a new `stores` directory.
    It's a bit of a hybrid, a hook in a `.store.ts` file, but it gets the job
    done without adding new dependencies.
  - >-
    Now, let's update `App.tsx` to use our new `useAppStore` hook. This cleans
    up the component significantly.
  - >-
    Next, the `useAnalysis` hook is doing a lot of heavy lifting with the web
    worker. I'll extract the worker communication logic into a dedicated
    `AnalysisService` class. This aligns with your request to create service
    files.
  - >-
    Finally, I'll refactor the `useAnalysis.hook.ts` to use our new
    `AnalysisService`. The hook is now much simpler; its main job is to manage
    state and connect the service to the React component lifecycle.
operations:
  - type: write
    path: packages/scn-ts-web-demo/src/stores/app.store.ts
    content: |-
      import { useState } from 'react';
      import { defaultFilesJSON } from '../default-files';
      import type { FormattingOptions } from '../types';

      export function useAppStore() {
        const [filesInput, setFilesInput] = useState(defaultFilesJSON);
        const [scnOutput, setScnOutput] = useState('');
        const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
          showOutgoing: true,
          showIncoming: true,
          showIcons: true,
          showExportedIndicator: true,
          showPrivateIndicator: true,
          showModifiers: true,
          showTags: true,
          showSymbolIds: true,
          groupMembers: true,
          displayFilters: {},
          showFilePrefix: true,
          showFileIds: true,
        });

        return {
          filesInput,
          setFilesInput,
          scnOutput,
          setScnOutput,
          formattingOptions,
          setFormattingOptions,
        };
      }
    patchStrategy: replace
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: >-
      --- packages/scn-ts-web-demo/src/App.tsx

      +++ packages/scn-ts-web-demo/src/App.tsx

      @@ -1,13 +1,13 @@

      -import { useState, useEffect, useCallback } from 'react';

      +import { useEffect, useCallback } from 'react';
       import { generateScn } from 'scn-ts-core';
      -import { defaultFilesJSON } from './default-files';
       import { Button } from './components/ui/button';
       import { Textarea } from './components/ui/textarea';
       import LogViewer from './components/LogViewer';
       import OutputOptions from './components/OutputOptions';
       import { Legend } from './components/Legend';
       import { Play, Loader, Copy, Check, StopCircle } from 'lucide-react';
      -import type { FormattingOptions } from './types';
       import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from './components/ui/accordion';
       import { useAnalysis } from './hooks/useAnalysis.hook';
       import { useClipboard } from './hooks/useClipboard.hook';
       import { useResizableSidebar } from './hooks/useResizableSidebar.hook';
       import { useTokenCounter } from './hooks/useTokenCounter.hook';
      +import { useAppStore } from './stores/app.store';
       
       function App() {
      -  const [filesInput, setFilesInput] = useState(defaultFilesJSON);

      -  const [scnOutput, setScnOutput] = useState('');

      -  const [formattingOptions, setFormattingOptions] =
      useState<FormattingOptions>({

      -    showOutgoing: true,

      -    showIncoming: true,

      -    showIcons: true,

      -    showExportedIndicator: true,

      -    showPrivateIndicator: true,

      -    showModifiers: true,

      -    showTags: true,

      -    showSymbolIds: true,

      -    groupMembers: true,

      -    displayFilters: {},

      -    showFilePrefix: true,

      -    showFileIds: true,

      -  });

      +  const {

      +    filesInput,

      +    setFilesInput,

      +    scnOutput,

      +    setScnOutput,

      +    formattingOptions,

      +    setFormattingOptions,

      +  } = useAppStore();
       
         const {
           isInitialized,
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/services/analysis.service.ts
    content: |-
      import * as Comlink from 'comlink';
      import type { Remote } from 'comlink';
      import type { WorkerApi } from '../worker';
      import type { LogEntry, ProgressData } from '../types';
      import type { LogLevel, SourceFile } from 'scn-ts-core';

      export class AnalysisService {
        private worker: Worker;
        private workerApi: Remote<WorkerApi>;

        constructor() {
          this.worker = new Worker(new URL('../worker.ts', import.meta.url), { type: 'module' });
          this.workerApi = Comlink.wrap<WorkerApi>(this.worker);
        }

        async init(): Promise<void> {
          return this.workerApi.init();
        }

        async analyze(
          filesInput: string,
          logLevel: LogLevel,
          onProgress: (progress: ProgressData) => void,
          onLog: (log: LogEntry) => void
        ): Promise<{ result: SourceFile[], analysisTime: number }> {
          return this.workerApi.analyze(
            { filesInput, logLevel },
            Comlink.proxy(onProgress),
            Comlink.proxy(onLog)
          );
        }

        cancel(): Promise<void> {
          return this.workerApi.cancel();
        }

        cleanup(): void {
          this.workerApi[Comlink.releaseProxy]();
          this.worker.terminate();
        }
      }
    patchStrategy: replace
  - type: write
    path: packages/scn-ts-web-demo/src/hooks/useAnalysis.hook.ts
    content: |-
      import { useState, useEffect, useCallback, useRef } from 'react';
      import type { SourceFile } from 'scn-ts-core';
      import type { LogEntry, ProgressData } from '../types';
      import { AnalysisService } from '../services/analysis.service';

      export function useAnalysis() {
        const [isInitialized, setIsInitialized] = useState(false);
        const [isLoading, setIsLoading] = useState(false);
        const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
        const [progress, setProgress] = useState<ProgressData | null>(null);
        const [logs, setLogs] = useState<LogEntry[]>([]);
        const [analysisTime, setAnalysisTime] = useState<number | null>(null);
        const serviceRef = useRef<AnalysisService | null>(null);

        const onLog = useCallback((log: LogEntry) => {
          setLogs(prev => [...prev, log]);
        }, []);

        const onLogPartial = useCallback((log: Pick<LogEntry, 'level' | 'message'>) => {
          onLog({ ...log, timestamp: Date.now() });
        }, [onLog]);

        useEffect(() => {
          const service = new AnalysisService();
          serviceRef.current = service;

          const initializeWorker = async () => {
            try {
              await service.init();
              setIsInitialized(true);
              onLogPartial({ level: 'info', message: 'Analysis worker ready.' });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              onLogPartial({ level: 'error', message: `Worker failed to initialize: ${message}` });
            }
          };

          initializeWorker();

          return () => {
            service.cleanup();
            serviceRef.current = null;
          };
        }, [onLogPartial]);

        const resetAnalysisState = useCallback(() => {
          setAnalysisResult(null);
          setAnalysisTime(null);
          setProgress(null);
          setLogs([]);
        }, []);

        const handleAnalyze = useCallback(async (filesInput: string) => {
          if (!isInitialized || !serviceRef.current) {
            onLogPartial({ level: 'warn', message: 'Analysis worker not ready.' });
            return;
          }
          
          if (isLoading) {
            return; // Prevent multiple concurrent analyses
          }
          
          setIsLoading(true);
          resetAnalysisState();
          
          try {
            const { result, analysisTime } = await serviceRef.current.analyze(
              filesInput,
              'debug',
              setProgress,
              onLog
            );
            setAnalysisResult(result);
            setAnalysisTime(analysisTime);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            if ((error as Error).name === 'AbortError') {
              onLogPartial({ level: 'warn', message: 'Analysis canceled by user.' });
            } else {
              onLogPartial({ level: 'error', message: `Analysis error: ${message}` });
            }
          } finally {
            setIsLoading(false);
            setProgress(null);
          }
        }, [isInitialized, isLoading, resetAnalysisState, onLog, onLogPartial]);

        const handleStop = useCallback(() => {
          if (isLoading && serviceRef.current) {
            serviceRef.current.cancel();
          }
        }, [isLoading]);

        return {
          isInitialized,
          isLoading,
          analysisResult,
          progress,
          logs,
          analysisTime,
          handleAnalyze,
          handleStop,
          onLogPartial,
        };
      }
    patchStrategy: replace
snapshot:
  packages/scn-ts-web-demo/src/stores/app.store.ts: null
  packages/scn-ts-web-demo/src/services/analysis.service.ts: null
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback } from 'react';

    import { generateScn } from 'scn-ts-core';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import OutputOptions from './components/OutputOptions';

    import { Legend } from './components/Legend';

    import { Play, Loader, Copy, Check, StopCircle } from 'lucide-react';

    import type { FormattingOptions } from './types';

    import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from
    './components/ui/accordion';

    import { useAnalysis } from './hooks/useAnalysis.hook';

    import { useClipboard } from './hooks/useClipboard.hook';

    import { useResizableSidebar } from './hooks/useResizableSidebar.hook';

    import { useTokenCounter } from './hooks/useTokenCounter.hook';


    function App() {
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
        showOutgoing: true,
        showIncoming: true,
        showIcons: true,
        showExportedIndicator: true,
        showPrivateIndicator: true,
        showModifiers: true,
        showTags: true,
        showSymbolIds: true,
        groupMembers: true,
        displayFilters: {},
        showFilePrefix: true,
        showFileIds: true,
      });

      const {
        isInitialized,
        isLoading,
        analysisResult,
        progress,
        logs,
        analysisTime,
        handleAnalyze: performAnalysis,
        handleStop,
        onLogPartial,
      } = useAnalysis();

      const { sidebarWidth, handleMouseDown } = useResizableSidebar(480);
      const { isCopied, handleCopy: performCopy } = useClipboard();
      const tokenCounts = useTokenCounter(filesInput, scnOutput, onLogPartial);

      useEffect(() => {
        if (analysisResult) {
          setScnOutput(generateScn(analysisResult, formattingOptions));
        } else {
          setScnOutput('');
        }
      }, [analysisResult, formattingOptions]);

      const handleCopy = useCallback(() => {
        performCopy(scnOutput);
      }, [performCopy, scnOutput]);

      const handleAnalyze = useCallback(async () => {
        performAnalysis(filesInput);
      }, [performAnalysis, filesInput]);

      return (
        <div className="h-screen w-screen flex bg-background text-foreground overflow-hidden">
          {/* Sidebar */}
          <aside style={{ width: `${sidebarWidth}px` }} className="max-w-[80%] min-w-[320px] flex-shrink-0 flex flex-col border-r">
            <div className="flex-shrink-0 flex items-center justify-between p-4 border-b bg-background relative z-20">
              <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
              <div className="flex items-center space-x-2">
                {isLoading ? (
                  <>
                    <Button disabled className="w-32 justify-center">
                      <Loader className="mr-2 h-4 w-4 animate-spin" />
                      <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                    </Button>
                    <Button onClick={handleStop} variant="outline" size="icon" title="Stop analysis">
                      <StopCircle className="h-4 w-4" />
                    </Button>
                  </>
                ) : (
                  <Button onClick={handleAnalyze} disabled={!isInitialized} className="w-32 justify-center">
                    <Play className="mr-2 h-4 w-4" />
                    <span>Analyze</span>
                  </Button>
                )}
              </div>
            </div>

            <div className="flex-grow overflow-y-auto">
              <Accordion type="multiple" defaultValue={['input', 'options', 'logs']} className="w-full">
                <AccordionItem value="input">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                    <div className="flex w-full justify-between items-center">
                      <span>Input Files (JSON)</span>
                      <span className="text-xs font-normal text-muted-foreground tabular-nums">
                        {tokenCounts.input.toLocaleString()} tokens
                      </span>
                    </div>
                  </AccordionTrigger>
                  <AccordionContent>
                    <div className="px-4 pb-4 h-96">
                      <Textarea
                        value={filesInput}
                        onChange={(e) => setFilesInput(e.currentTarget.value)}
                        className="h-full w-full font-mono text-xs resize-none"
                        placeholder="Paste an array of FileContent objects here..."
                      />
                    </div>
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="options">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Formatting Options</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="logs">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Logs</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <LogViewer logs={logs} />
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </div>
          </aside>

          {/* Resizer */}
          <div
            role="separator"
            onMouseDown={handleMouseDown}
            className="w-1.5 flex-shrink-0 cursor-col-resize hover:bg-primary/20 transition-colors duration-200"
          />

          {/* Main Content Area */}
          <main className="flex-grow flex flex-col overflow-hidden relative">
            <div className="flex justify-between items-center p-4 border-b flex-shrink-0">
              <h2 className="text-lg font-semibold leading-none tracking-tight">Output (SCN)</h2>
              <div className="flex items-center gap-4">
                {analysisTime !== null && (
                  <span className="text-sm text-muted-foreground">
                    Analyzed in {(analysisTime / 1000).toFixed(2)}s
                  </span>
                )}
                <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                <Button variant="ghost" size="icon" onClick={handleCopy} disabled={!scnOutput} title="Copy to clipboard">
                  {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                </Button>
              </div>
            </div>
            <div className="p-4 flex-grow overflow-auto font-mono text-xs relative">
              <Legend />
              <pre className="whitespace-pre-wrap">
                {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
              </pre>
            </div>
          </main>
        </div>
      );
    }


    export default App;
  packages/scn-ts-web-demo/src/hooks/useAnalysis.hook.ts: |-
    import { useState, useEffect, useCallback, useRef } from 'react';
    import * as Comlink from 'comlink';
    import type { Remote } from 'comlink';
    import type { SourceFile } from 'scn-ts-core';
    import type { LogEntry, ProgressData } from '../types';
    import type { WorkerApi } from '../worker';

    export function useAnalysis() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [analysisTime, setAnalysisTime] = useState<number | null>(null);
      const workerRef = useRef<Remote<WorkerApi> | null>(null);

      const onLog = useCallback((log: LogEntry) => {
        setLogs(prev => [...prev, log]);
      }, []);

      const onLogPartial = useCallback((log: Pick<LogEntry, 'level' | 'message'>) => {
        onLog({ ...log, timestamp: Date.now() });
      }, [onLog]);

      useEffect(() => {
        const worker = new Worker(new URL('../worker.ts', import.meta.url), { type: 'module' });
        const wrappedWorker = Comlink.wrap<WorkerApi>(worker);
        workerRef.current = wrappedWorker;

        const initializeWorker = async () => {
          try {
            await wrappedWorker.init();
            setIsInitialized(true);
            onLogPartial({ level: 'info', message: 'Analysis worker ready.' });
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            onLogPartial({ level: 'error', message: `Worker failed to initialize: ${message}` });
          }
        };

        initializeWorker();

        return () => {
          wrappedWorker[Comlink.releaseProxy]();
          worker.terminate();
        };
      }, [onLogPartial]);

      const resetAnalysisState = useCallback(() => {
        setAnalysisResult(null);
        setAnalysisTime(null);
        setProgress(null);
        setLogs([]);
      }, []);

      const handleAnalyze = useCallback(async (filesInput: string) => {
        if (!isInitialized || !workerRef.current) {
          onLogPartial({ level: 'warn', message: 'Analysis worker not ready.' });
          return;
        }
        
        if (isLoading) {
          return; // Prevent multiple concurrent analyses
        }
        
        setIsLoading(true);
        resetAnalysisState();
        
        try {
          const { result, analysisTime } = await workerRef.current.analyze(
            { filesInput, logLevel: 'debug' },
            Comlink.proxy(setProgress),
            Comlink.proxy(onLog)
          );
          setAnalysisResult(result);
          setAnalysisTime(analysisTime);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          if ((error as Error).name === 'AbortError') {
            onLogPartial({ level: 'warn', message: 'Analysis canceled by user.' });
          } else {
            onLogPartial({ level: 'error', message: `Analysis error: ${message}` });
          }
        } finally {
          setIsLoading(false);
          setProgress(null);
        }
      }, [isInitialized, isLoading, resetAnalysisState, onLog, onLogPartial]);

      const handleStop = useCallback(() => {
        if (isLoading && workerRef.current) {
          workerRef.current.cancel();
        }
      }, [isLoading]);

      return {
        isInitialized,
        isLoading,
        analysisResult,
        progress,
        logs,
        analysisTime,
        handleAnalyze,
        handleStop,
        onLogPartial,
      };
    }
approved: true
