uuid: 4f4f5a9e-c852-4a0b-93f8-62d0ac79b8b2
projectId: scn-ts-core
createdAt: '2025-08-12T04:13:08.191Z'
linesAdded: 8
linesRemoved: 11
gitCommitMsg: 'fix(parser): make parser initialization thread-safe'
promptSummary: >-
  The user is encountering a Wasm LinkError and test timeouts when running `bun
  test`. This is likely due to a race condition in the `web-tree-sitter`
  initialization logic when tests run in parallel. I need to fix the
  initialization to be thread-safe.
reasoning:
  - >-
    Based on the error logs, it seems there's a race condition during the
    initialization of the `web-tree-sitter` parser, especially when tests are
    run in parallel by `bun test`. The `LinkError` for the Wasm module is a
    strong indicator that `Parser.init()` is being called multiple times
    concurrently, leading to a corrupted state.
  - >-
    To fix this, I will refactor the initialization logic in `src/parser.ts` to
    be race-condition-safe. Instead of the previous approach, I'll use a single
    promise (`initializePromise`) to ensure that the initialization function
    `doInitialize` is only ever executed once. Subsequent calls to
    `initializeParser` will receive the same promise, ensuring they all wait for
    the single initialization process to complete.
  - >-
    I will also modify the error handling within the language loading loop to
    re-throw errors. This will ensure that if a language parser fails to load,
    the corresponding test will fail explicitly instead of timing out or
    producing strange behavior.
  - 'Here is my plan:'
  - >-
    1.  Modify `src/parser.ts` to implement a thread-safe, one-time
    initialization pattern for the `web-tree-sitter` parser.
operations:
  - type: write
    path: src/parser.ts
    content: >-
      import type { ParserInitOptions, LanguageConfig } from './types';

      import Parser from 'web-tree-sitter';

      import path from 'node:path';

      import { languages } from './languages';


      let initializePromise: Promise<void> | null = null;

      let isInitialized = false;


      const doInitialize = async (options: ParserInitOptions): Promise<void> =>
      {
          await Parser.init({
              locateFile: (scriptName: string, _scriptDirectory: string) => {
                  return path.join(options.wasmBaseUrl, scriptName);
              }
          });

          const languageLoaders = languages
              .filter(lang => lang.wasmPath)
              .map(async (lang: LanguageConfig) => {
                  const wasmPath = path.join(options.wasmBaseUrl, lang.wasmPath);
                  try {
                      const loadedLang = await Parser.Language.load(wasmPath);
                      const parser = new Parser();
                      parser.setLanguage(loadedLang);
                      lang.parser = parser;
                  } catch (error) {
                      console.error(`Failed to load parser for ${lang.name} from ${wasmPath}`, error);
                      throw error;
                  }
              });
          
          await Promise.all(languageLoaders);
          isInitialized = true;
      };


      export const initializeParser = (options: ParserInitOptions):
      Promise<void> => {
          if (initializePromise) {
              return initializePromise;
          }
          initializePromise = doInitialize(options);
          return initializePromise;
      };


      export const parse = (sourceCode: string, lang: LanguageConfig):
      Parser.Tree | null => {
          if (!isInitialized || !lang.parser) {
              return null;
          }
          return lang.parser.parse(sourceCode);
      };
    patchStrategy: replace
snapshot:
  src/parser.ts: >-
    import type { ParserInitOptions, LanguageConfig } from './types';

    import Parser from 'web-tree-sitter';

    import path from 'node:path';

    import { languages } from './languages';


    let isInitialized = false;


    const createInitializer = (options: ParserInitOptions) => async ():
    Promise<void> => {
        if (isInitialized) {
            return;
        }
        
        await Parser.init({
            locateFile: (scriptName: string, _scriptDirectory: string) => {
                return path.join(options.wasmBaseUrl, scriptName);
            }
        });

        const languageLoaders = languages
            .filter(lang => lang.wasmPath)
            .map(async (lang: LanguageConfig) => {
                const wasmPath = path.join(options.wasmBaseUrl, lang.wasmPath);
                try {
                    const loadedLang = await Parser.Language.load(wasmPath);
                    const parser = new Parser();
                    parser.setLanguage(loadedLang);
                    lang.parser = parser;
                } catch (error) {
                    console.error(`Failed to load parser for ${lang.name} from ${wasmPath}`, error);
                }
            });
        
        await Promise.all(languageLoaders);
        isInitialized = true;
    };


    let initializeFn: (() => Promise<void>) | null = null;


    export const initializeParser = async (options: ParserInitOptions):
    Promise<void> => {
        if (!initializeFn) {
            initializeFn = createInitializer(options);
        }
        await initializeFn();
    };


    export const parse = (sourceCode: string, lang: LanguageConfig): Parser.Tree
    | null => {
        if (!isInitialized || !lang.parser) {
            return null;
        }
        return lang.parser.parse(sourceCode);
    };
approved: true
