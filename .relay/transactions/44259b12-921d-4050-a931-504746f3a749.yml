uuid: 44259b12-921d-4050-a931-504746f3a749
projectId: scn-ts-core
createdAt: '2025-08-24T22:35:39.285Z'
linesAdded: 58
linesRemoved: 46
gitCommitMsg: 'fix(build): resolve all typescript errors'
promptSummary: >-
  The user provided a list of 36 TypeScript errors from running `tsc`. The task
  is to fix all of them. The errors span both the `scn-ts-core` library and the
  `scn-ts-web-demo` application, covering issues with module exports, type-only
  imports (`verbatimModuleSyntax`), invalid path aliases, incorrect Vite
  configuration, missing null checks in strict mode, and other type-related
  problems.
reasoning:
  - >-
    I've analyzed the TypeScript errors and have a clear plan to resolve them.
    The issues span both the core library and the web demo, involving incorrect
    module exports, type errors, browser compatibility problems, and
    misconfigured build tools.
  - >-
    First, I'll create an `index.ts` file for `scn-ts-core` to serve as a proper
    public API entry point and update `package.json` accordingly. This will
    resolve the export errors.
  - 'Next, I''ll fix a series of type-related issues:'
  - '- I''ll correct a type re-export in `src/types.ts`.'
  - >-
    - I'll add necessary null-checks in `src/analyzer.ts` and
    `src/utils/path.ts` to satisfy the strict type checker.
  - >-
    - I'll clean up unused variables and potential type mismatches in
    `src/formatter.ts`.
  - >-
    - The strange error in `src/queries/typescript.ts` appears to be a type
    inference issue with template literals, which I'll resolve by changing it to
    simple string concatenation.
  - 'For the web demo, I''ll address the following:'
  - '- I''ll fix all `verbatimModuleSyntax` errors by using `import type`.'
  - >-
    - I'll replace the failing `@/` path aliases in the UI components with
    relative paths, which is more robust for `tsc`.
  - '- I''ll remove an invalid `watch` configuration from `vite.config.ts`.'
  - >-
    - I'll fix the `document not found` error by reordering libs in
    `tsconfig.json`.
  - >-
    - I'll explicitly type a React event handler in `App.tsx` to fix an error
    with `e.target.value`.
  - I'll start with the creation of `src/index.ts`.
  - >-
    Now, I'll update the `package.json` for the core library to point to this
    new entry file.
  - Next, I will fix the type export in `src/types.ts`.
  - I'll now add the necessary null checks and fixes to `src/analyzer.ts`.
  - Now I'll fix `src/formatter.ts`.
  - Fixing the type checker issue in `src/utils/path.ts`.
  - >-
    Changing the query string definition in `src/queries/typescript.ts` to avoid
    the strange type error.
  - Now, onto the web demo fixes. I'll start with `vite.config.ts`.
  - Next, I'll update `tsconfig.json` for the web demo.
  - Now, I'll fix the imports and paths in the web demo's source files.
  - >-
    I believe these changes cover all the reported errors and will result in a
    successful build.
operations:
  - type: write
    path: src/index.ts
    content: |-
      export {
          initializeParser,
          analyzeProject,
          generateScn,
          logger,
      } from './main';

      export type {
          ParserInitOptions,
          SourceFile,
          LogLevel,
          LogHandler,
          FileContent,
      } from './main';

      export type {
          ScnTsConfig,
          InputFile,
      } from './types'
    patchStrategy: replace
  - type: write
    path: package.json
    content: |-
      <<<<<<< SEARCH
        "module": "index.ts",
      =======
        "module": "src/index.ts",
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/types.ts
    content: |-
      --- src/types.ts
      +++ src/types.ts
      @@ -1,5 +1,6 @@
       import type { Parser, Tree, Language } from 'web-tree-sitter';
      -import type { TsConfig, PathResolver } from './utils/tsconfig';
      -export type { PathResolver };
      +import type { PathResolver } from './utils/tsconfig';
      +export type { TsConfig } from './utils/tsconfig';
      +export type { PathResolver };
       
       export type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'silent';
    patchStrategy: new-unified
  - type: write
    path: src/analyzer.ts
    content: >-
      --- src/analyzer.ts

      +++ src/analyzer.ts

      @@ -37,8 +37,8 @@
                   if (cleanParams.includes('{') && cleanParams.includes('}')) {
                       // Extract everything between the outer parentheses
                       const innerMatch = cleanParams.match(/\(\s*\{\s*([^}]+)\s*\}\s*\)/);
      -                if (innerMatch) {

      -                    const destructured = innerMatch[1].split(',').map(p
      => p.trim()).join(', ');

      +                if (innerMatch && innerMatch[1]) {

      +                    const destructured = innerMatch[1]!.split(',').map(p
      => p.trim()).join(', ');
                           return `<anonymous>({ ${destructured} })`;
                       }
                   }
      @@ -49,7 +49,6 @@
           
           // Handle styled components
           if ((node as any)._styledTag) {
      -        const tagName = (node as any)._styledTag;
               const componentName = getIdentifier(node.parent || node, sourceCode);
               return `${componentName}`;
           }
      @@ -232,8 +231,8 @@
               // Properties (interface property_signature or class field definitions)
               if (symbol.kind === 'property') {
                   // interface/class fields
      -            const match = scopeText.match(/:\s*([^;\n]+)/);

      -            if (match) {

      +            const match = scopeText.match(/:\s*([^;\n]+)/); 

      +            if (match && match[1]) {
                       symbol.typeAnnotation = `#${normalizeType(match[1])}`;
                   }
                   // detect readonly/static from text
      @@ -251,10 +250,10 @@
       
               // Type alias value (right-hand side after '=')
               if (symbol.kind === 'type_alias') {
      -            const m = scopeText.match(/=\s*([^;\n]+)/);

      -            if (m) {

      +            const m = scopeText.match(/=\s*([^;\n]+)/); 

      +            if (m && m[1]) {
                       // Remove quotes from string literal unions
      -                let typeValue = normalizeType(m[1]);

      +                let typeValue = normalizeType(m[1]!);
                       typeValue = typeValue.replace(/'([^']+)'/g, '$1');
                       typeValue = typeValue.replace(/"([^"]+)"/g, '$1');
                       
      @@ -262,7 +261,7 @@
                       if (typeValue.startsWith('{') && typeValue.endsWith('}')) {
                           const inner = typeValue.slice(1, -1).trim();
                           const mappedMatch = inner.match(/\[\s*([^:]+)\s*in\s*([^:]+)\s*\]\s*:\s*(.*)/);
      -                    if (mappedMatch) {

      +                    if (mappedMatch && mappedMatch.length > 3) {
                               const [_, key, inType, valueType] = mappedMatch;
                               typeValue = `${key.trim()} in ${inType.trim()}:${valueType.trim()}`;
                           }
      @@ -275,14 +274,16 @@
               if (symbol.kind === 'function' || symbol.kind === 'method' || symbol.kind === 'constructor') {
                   const paramsMatch = scopeText.match(/\(([^)]*)\)/);
                   const returnMatch = scopeText.match(/\)\s*:\s*([^\{\n]+)/);
      -            const params = paramsMatch ? paramsMatch[1] : '';

      -            const paramsWithTypes = params

      -                .split(',')

      -                .map(p => p.trim())

      -                .filter(p => p.length > 0)

      -                .map(p => p.replace(/:\s*([^,]+)/, (_s, t) => `:
      #${normalizeType(t)}`))

      -                .join(', ');

      -            const returnType = returnMatch ? `:
      #${normalizeType(returnMatch[1])}` : '';

      +            const params = paramsMatch ? paramsMatch[1] : '';

      +            const paramsWithTypes = params ? params

      +                  .split(',')

      +                  .map(p => p.trim())

      +                  .filter(p => p.length > 0)

      +                  .map(p => p.replace(/:\s*([^,]+)/, (_s, t) => `:
      #${normalizeType(t)}`))

      +                  .join(', ') : '';

      +            

      +            const returnType = (returnMatch && returnMatch[1]) ? `:
      #${normalizeType(returnMatch[1])}` : '';

      +            
                   symbol.signature = `(${paramsWithTypes})${returnType}`;
       
                   // Async detection (textual) and throws detection
    patchStrategy: new-unified
  - type: write
    path: src/formatter.ts
    content: >-
      --- src/formatter.ts

      +++ src/formatter.ts

      @@ -69,12 +69,11 @@
           // Build ID portion conditionally
           const file = allFiles.find(f => f.id === symbol.fileId)!;
           const idPart = formatSymbolIdDisplay(file, symbol);
      -    const idText = (symbol.kind === 'property' || symbol.kind ===
      'constructor') ? '' : (idPart ?? '');

      -    const idWithSpace = idText ? `${idText} ` : '';

      +    const idText = (symbol.kind === 'property' || symbol.kind ===
      'constructor') ? null : (idPart ?? null);
           const segments: string[] = [prefix, icon];
      -    if (idPart) segments.push(idPart);

      +    if (idText) segments.push(idText);
           if (name) segments.push(name.trim());
           if (modStr) segments.push(modStr);
           if (suffix) segments.push(suffix);
      -    const line = `  ${segments.join(' ')}`;

      +    const line = `  ${segments.filter(Boolean).join(' ')}`;
           const result = [line];
       
           const outgoing = new Map<number, Set<string>>();
      @@ -176,8 +175,8 @@
               }
           }
           // Sort children by position
      -    for (const [k, arr] of map.entries()) {

      +    for (const [, arr] of map.entries()) {
               arr.sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);
           }
           return map;
    patchStrategy: new-unified
  - type: write
    path: src/utils/path.ts
    content: >-
      --- src/utils/path.ts

      +++ src/utils/path.ts

      @@ -26,11 +26,11 @@
               let resolvedAbsolute = false;
               
               for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      -            const path = i >= 0 ? args[i] : '/'; // CWD is root for web

      -            if (path.length === 0) continue;

      +            const path = (i >= 0 ? args[i] : '/')!; // CWD is root for
      web

      +            if (path.length === 0 && i >= 0) continue;
                   
                   resolvedPath = path + '/' + resolvedPath;
      -            resolvedAbsolute = path.charAt(0) === '/';

      +            resolvedAbsolute = path.charAt(0) === '/';
               }
               
               const parts = resolvedPath.split('/').filter(p => p);
    patchStrategy: new-unified
  - type: write
    path: src/queries/typescript.ts
    content: >-
      --- src/queries/typescript.ts

      +++ src/queries/typescript.ts

      @@ -190,58 +190,58 @@
       ((method_definition) @mod.async (#match? @mod.async "^async "))
       `;
       
      -export const typescriptReactQueries = `

      -${typescriptQueries}

      -

      -; JSX component definitions (uppercase)

      -(jsx_opening_element

      -  name: (identifier) @symbol.react_component.def

      -  (#match? @symbol.react_component.def "^[A-Z]"))
      @scope.react_component.def

      -

      -(jsx_self_closing_element

      -  name: (identifier) @symbol.react_component.def

      -  (#match? @symbol.react_component.def "^[A-Z]"))
      @scope.react_component.def

      -

      -; JSX element definitions (lowercase tags)

      -(jsx_opening_element

      -  name: (identifier) @symbol.jsx_element.def

      -  (#match? @symbol.jsx_element.def "^[a-z]")) @scope.jsx_element.def

      -

      -(jsx_self_closing_element

      -  name: (identifier) @symbol.jsx_element.def

      -  (#match? @symbol.jsx_element.def "^[a-z]")) @scope.jsx_element.def

      -

      -; Arrow functions in JSX expressions (render props)

      -(jsx_expression

      -  (arrow_function) @symbol.function.def) @scope.function.def

      -

      -; React fragments (empty JSX elements)

      -(jsx_element

      -  (jsx_opening_element) @symbol.jsx_element.def

      -  (#not-has-child? @symbol.jsx_element.def identifier))
      @scope.jsx_element.def

      -

      -; JSX component references (uppercase)

      -(jsx_opening_element

      -  name: (identifier) @rel.references

      -  (#match? @rel.references "^[A-Z]"))

      -

      -(jsx_self_closing_element

      -  name: (identifier) @rel.references

      -  (#match? @rel.references "^[A-Z]"))

      -`;

      +export const typescriptReactQueries = typescriptQueries + `

      +

      +; JSX component definitions (uppercase)

      +(jsx_opening_element

      +  name: (identifier) @symbol.react_component.def

      +  (#match? @symbol.react_component.def "^[A-Z]"))
      @scope.react_component.def

      +

      +(jsx_self_closing_element

      +  name: (identifier) @symbol.react_component.def

      +  (#match? @symbol.react_component.def "^[A-Z]"))
      @scope.react_component.def

      +

      +; JSX element definitions (lowercase tags)

      +(jsx_opening_element

      +  name: (identifier) @symbol.jsx_element.def

      +  (#match? @symbol.jsx_element.def "^[a-z]")) @scope.jsx_element.def

      +

      +(jsx_self_closing_element

      +  name: (identifier) @symbol.jsx_element.def

      +  (#match? @symbol.jsx_element.def "^[a-z]")) @scope.jsx_element.def

      +

      +; Arrow functions in JSX expressions (render props)

      +(jsx_expression

      +  (arrow_function) @symbol.function.def) @scope.function.def

      +

      +; React fragments (empty JSX elements)

      +(jsx_element

      +  (jsx_opening_element) @symbol.jsx_element.def

      +  (#not-has-child? @symbol.jsx_element.def identifier))
      @scope.jsx_element.def

      +

      +; JSX component references (uppercase)

      +(jsx_opening_element

      +  name: (identifier) @rel.references

      +  (#match? @rel.references "^[A-Z]"))

      +

      +(jsx_self_closing_element

      +  name: (identifier) @rel.references

      +  (#match? @rel.references "^[A-Z]"))

      +`;
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/vite.config.ts
    content: >-
      --- packages/scn-ts-web-demo/vite.config.ts

      +++ packages/scn-ts-web-demo/vite.config.ts

      @@ -29,11 +29,6 @@
             'Cross-Origin-Embedder-Policy': 'require-corp',
             'Cross-Origin-Opener-Policy': 'same-origin',
           },
      -    watch: {

      -      // The wasm files are not directly imported, so Vite doesn't watch
      them by default.

      -      // We need to explicitly tell Vite to watch them to trigger a
      reload on change.

      -      include: ['public/wasm/**']

      -    },
           mime: {
             'application/wasm': ['wasm']
           }
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/tsconfig.json
    content: |-
      <<<<<<< SEARCH
          "lib": ["ES2020", "DOM", "DOM.Iterable"],
      =======
          "lib": ["DOM", "DOM.Iterable", "ES2020"],
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: >-
      --- packages/scn-ts-web-demo/src/App.tsx

      +++ packages/scn-ts-web-demo/src/App.tsx

      @@ -1,15 +1,15 @@
       import { useState, useEffect, useCallback } from 'react';
       import {
         initializeParser,
         logger,
         analyzeProject,
      -  FileContent,

      -  LogHandler,
         generateScn,
      -} from '';//todo

      +} from 'scn-ts-core';

      +import type { FileContent, LogHandler } from 'scn-ts-core';
       import { defaultFilesJSON } from './default-files';
       import { Button } from './components/ui/button';
       import { Card, CardContent, CardHeader, CardTitle } from './components/ui/card';
       import { Textarea } from './components/ui/textarea';
      -import LogViewer, { LogEntry } from './components/LogViewer';

      +import LogViewer from './components/LogViewer';

      +import type { LogEntry } from './components/LogViewer';
       import { Play, Loader } from 'lucide-react';
       
       function App() {
      @@ -107,7 +107,7 @@
                 <CardContent className="flex-grow">
                   <Textarea
                     value={filesInput}
      -              onChange={(e) => setFilesInput(e.target.value)}

      +              onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
      setFilesInput(e.target.value)}
                     className="h-full w-full font-mono text-xs"
                     placeholder="Paste an array of FileContent objects here..."
                   />
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/components/LogViewer.tsx
    content: |-
      --- packages/scn-ts-web-demo/src/components/LogViewer.tsx
      +++ packages/scn-ts-web-demo/src/components/LogViewer.tsx
      @@ -1,6 +1,6 @@
       import React from 'react';
      -import { LogLevel } from 'scn-ts-core';
      +import type { LogLevel } from 'scn-ts-core';
       import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
      -import { cn } from '@/lib/utils';
      +import { cn } from '../lib/utils';
       
       export interface LogEntry {
         level: Exclude<LogLevel, 'silent'>;
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/components/ui/button.tsx
    content: |-
      --- packages/scn-ts-web-demo/src/components/ui/button.tsx
      +++ packages/scn-ts-web-demo/src/components/ui/button.tsx
      @@ -1,7 +1,7 @@
       import * as React from "react"
       import { Slot } from "@radix-ui/react-slot"
       import { cva, type VariantProps } from "class-variance-authority"
      -
      -import { cn } from "@/lib/utils"
      +import { cn } from "../../lib/utils"
       
       const buttonVariants = cva(
         "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/components/ui/card.tsx
    content: |-
      --- packages/scn-ts-web-demo/src/components/ui/card.tsx
      +++ packages/scn-ts-web-demo/src/components/ui/card.tsx
      @@ -1,5 +1,5 @@
       import * as React from "react"
      -import { cn } from "@/lib/utils"
      +import { cn } from "../../lib/utils"
       
       const Card = React.forwardRef<
         HTMLDivElement,
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/components/ui/textarea.tsx
    content: |-
      --- packages/scn-ts-web-demo/src/components/ui/textarea.tsx
      +++ packages/scn-ts-web-demo/src/components/ui/textarea.tsx
      @@ -1,6 +1,5 @@
       import * as React from "react"
      -
      -import { cn } from "@/lib/utils"
      +import { cn } from "../../lib/utils"
       
       export interface TextareaProps
         extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/default-files.ts
    content: |-
      --- packages/scn-ts-web-demo/src/default-files.ts
      +++ packages/scn-ts-web-demo/src/default-files.ts
      @@ -1,4 +1,4 @@
      -import { FileContent } from "scn-ts-core";
      +import type { FileContent } from "scn-ts-core";
       
       const files: FileContent[] = [
         {
    patchStrategy: new-unified
snapshot:
  src/index.ts: null
  package.json: |
    {
      "name": "scn-ts-core",
      "module": "index.ts",
      "type": "module",
      "private": true,
      "devDependencies": {
        "@types/bun": "latest",
        "web-tree-sitter": "0.25.6"
      },
      "peerDependencies": {
        "typescript": "^5"
      }
    }
  src/types.ts: |-
    import type { Parser, Tree, Language } from 'web-tree-sitter';
    import type { TsConfig, PathResolver } from './utils/tsconfig';
    export type { PathResolver };

    export type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'silent';

    /**
     * Represents a file to be processed.
     */
    export interface InputFile {
      path: string; // relative path from root
      content: string;
    }

    /**
     * Configuration for the SCN generation process.
     */
    export interface ScnTsConfig {
      files: InputFile[];
      tsconfig?: TsConfig;
      root?: string; // Optional: A virtual root path for resolution. Defaults to '/'.
      _test_id?: string; // Special property for test runner to identify fixtures
    }

    /**
     * Options for initializing the Tree-sitter parser.
     */
    export interface ParserInitOptions {
        wasmBaseUrl: string;
    }

    /**
     * Represents a supported programming language and its configuration.
     */
    export type SymbolKind =
      // TS/JS
      | 'class' | 'interface' | 'function' | 'method' | 'constructor'
      | 'variable' | 'property' | 'enum' | 'enum_member' | 'type_alias' | 'module'
      | 'decorator' | 'parameter' | 'type_parameter' | 'import_specifier' | 're_export'
      // React
      | 'react_component' | 'react_hook' | 'react_hoc' | 'jsx_attribute' | 'jsx_element' | 'styled_component'
      // CSS
      | 'css_class' | 'css_id' | 'css_tag' | 'css_at_rule' | 'css_property' | 'css_variable'
      // Generic / Meta
      | 'file' | 'reference' | 'comment' | 'error' | 'unresolved'
      // Other Languages
      | 'go_package' | 'go_struct' | 'go_goroutine' | 'rust_struct' | 'rust_trait' | 'rust_impl' | 'rust_macro'
      | 'java_package' | 'python_class'
      | 'unknown';

    export interface Position {
      line: number;
      column: number;
    }

    export interface Range {
      start: Position;
      end: Position;
    }

    export interface CodeSymbol {
      id: string;
      fileId: number;
      name: string;
      kind: SymbolKind;
      range: Range;
      // Modifiers and metadata
      isExported: boolean;
      isAbstract?: boolean;
      isStatic?: boolean;
      isReadonly?: boolean;
      isAsync?: boolean;
      isPure?: boolean; // for 'o'
      throws?: boolean; // for '!'
      labels?: string[]; // extra display labels like [symbol], [proxy]
      isGenerated?: boolean;
      languageDirectives?: string[]; // e.g. 'use server'
      superClass?: string;
      implementedInterfaces?: string[];
      scopeRange: Range; // The range of the entire scope (e.g., function body) for relationship association
      accessibility?: 'public' | 'private' | 'protected';
      // Type information and signatures
      signature?: string; // e.g., (a: #number, b: #number): #number
      typeAnnotation?: string; // e.g., #string for properties/variables
      typeAliasValue?: string; // e.g., #number|string for type aliases
      // Relationships
      dependencies: Relationship[];
    }

    export type RelationshipKind =
      | 'import'
      | 'dynamic_import'
      | 'reference'
      | 'tagged'
      | 'export'
      | 'call'
      | 'extends'
      | 'implements'
      | 'references'
      | 'aliased'
      | 'goroutine'
      | 'macro';

    export interface Relationship {
      targetName: string; // The raw name of the target (e.g., './utils', 'MyClass', 'add', 'Button')
      kind: RelationshipKind;
      range: Range;
      // Resolved info
      resolvedFileId?: number;
      resolvedSymbolId?: string;
    }

    export interface SourceFile {
      id: number;
      relativePath: string;
      absolutePath: string;
      language: LanguageConfig;
      sourceCode: string;
      ast?: Tree;
      symbols: CodeSymbol[];
      parseError: boolean;
      isGenerated?: boolean;
      languageDirectives?: string[];
      // File-level relationships (e.g., imports not tied to a specific symbol)
      fileRelationships?: Relationship[];
    }

    /**
     * Represents a supported programming language and its configuration.
     */
    export interface LanguageConfig {
        id: string;
        name: string;
        extensions: string[];
        wasmPath: string;
        parser?: Parser;
        loadedLanguage?: Language;
        queries?: Record<string, string>;
    }

    export interface AnalysisContext {
        sourceFiles: SourceFile[];
        pathResolver: PathResolver;
    }
  src/utils/path.ts: >-
    // A simplified path utility for browser environments that assumes
    POSIX-style paths.

    export default {
        join(...parts: string[]): string {
            const path = parts.join('/');
            // Replace multiple slashes, but keep leading slashes for absolute paths
            return path.replace(/[/]+/g, '/');
        },

        dirname(p: string): string {
            const i = p.lastIndexOf('/');
            if (i === -1) return '.';
            if (i === 0) return '/'; // root directory
            const result = p.substring(0, i);
            return result || '/';
        },

        extname(p: string): string {
            const i = p.lastIndexOf('.');
            // ensure it's not the first char and a slash doesn't appear after it
            if (i <= 0 || p.lastIndexOf('/') > i) return '';
            return p.substring(i);
        },

        resolve(...args: string[]): string {
            let resolvedPath = '';
            let resolvedAbsolute = false;
            
            for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                const path = i >= 0 ? args[i] : '/'; // CWD is root for web
                if (path.length === 0) continue;
                
                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charAt(0) === '/';
            }
            
            const parts = resolvedPath.split('/').filter(p => p);
            const stack: string[] = [];
            for (const p of parts) {
                if (p === '..') {
                    stack.pop();
                } else if (p !== '.') {
                    stack.push(p);
                }
            }
            
            let result = stack.join('/');
            if (resolvedAbsolute) {
                result = '/' + result;
            }
            
            return result || (resolvedAbsolute ? '/' : '.');
        },

        relative(from: string, to: string): string {
            const fromParts = from.split('/').filter(p => p && p !== '.');
            const toParts = to.split('/').filter(p => p && p !== '.');
            
            let i = 0;
            while(i < fromParts.length && i < toParts.length && fromParts[i] === toParts[i]) {
                i++;
            }
            
            const upCount = fromParts.length - i;
            const remainingTo = toParts.slice(i);
            
            const ups = Array(upCount).fill('..');
            const resultParts = [...ups, ...remainingTo];
            
            return resultParts.join('/') || '.';
        }
    };
  src/queries/typescript.ts: >
    export const typescriptQueries = `

    ; Interface definitions

    (interface_declaration
      name: (type_identifier) @symbol.interface.def) @scope.interface.def

    ; Type alias definitions  

    (type_alias_declaration
      name: (type_identifier) @symbol.type_alias.def) @scope.type_alias.def

    ; Class definitions

    (class_declaration
      name: (type_identifier) @symbol.class.def) @scope.class.def

    ; Abstract class definitions

    (abstract_class_declaration
      name: (type_identifier) @symbol.class.def) @scope.class.def

    ; Function definitions

    (function_declaration
      name: (identifier) @symbol.function.def) @scope.function.def

    ; Method definitions (capture name and formal parameters as scope)

    (method_definition name: (property_identifier) @symbol.method.def)
    @scope.method.def


    ; Method signatures (interfaces, abstract class methods)

    (method_signature
      name: (property_identifier) @symbol.method.def) @scope.method.def

    ; Constructor definitions

    (method_definition name: (property_identifier) @symbol.constructor.def
      (#eq? @symbol.constructor.def "constructor")) @scope.constructor.def

    ; Property signatures in interfaces (should be public by default)

    (property_signature
      (property_identifier) @symbol.property.def)

    ; Class field definitions (TypeScript grammar uses public_field_definition)

    (public_field_definition
      name: (property_identifier) @symbol.property.def)

    ; Variable declarations

    (variable_declarator
      name: (identifier) @symbol.variable.def)

    ; Common patterns to support JS features in fixtures

    ; IIFE: (function(){ ... })()

    (call_expression
      function: (parenthesized_expression
        (function_expression) @symbol.function.def
      )
    ) @scope.function.def


    ; IIFE with assignment: const result = (function(){ ... })()

    (expression_statement
      (assignment_expression
        left: (identifier) @symbol.variable.def
        right: (call_expression
          function: (parenthesized_expression
            (function_expression) @symbol.function.def
          )
        )
      )
    )


    ; Window assignments: window.Widget = Widget

    (expression_statement
      (assignment_expression
        left: (member_expression
          object: (identifier) @__obj
          property: (property_identifier) @symbol.variable.def
        )
        right: _ @symbol.variable.ref
      )
      (#eq? @__obj "window")
    )


    ; Tagged template usage -> capture identifier before template as call

    (call_expression
      function: (identifier) @rel.call)

    ; Template literal variable references

    (template_substitution
      (identifier) @rel.references)

    ; Styled components (styled.div, styled.h1, etc.)

    (variable_declarator
      name: (identifier) @symbol.styled_component.def
      value: (call_expression
        function: (member_expression
          object: (identifier) @_styled
          property: (property_identifier) @_tag)
        arguments: (template_string))
      (#eq? @_styled "styled")) @scope.styled_component.def

    ; (Removed overly broad CommonJS/object key captures that polluted TS
    fixtures)


    ; Import statements

    (import_statement
      source: (string) @rel.import)

    ; Named imports - these create references to the imported symbols

    (import_specifier
      name: (identifier) @rel.references)

    ; Type references in type annotations, extends clauses, etc.

    (type_identifier) @rel.references


    ; `satisfies` expressions

    (satisfies_expression
      (type_identifier) @rel.references)

    ; Identifiers used in expressions

    (binary_expression
      left: (identifier) @rel.references
      right: (identifier) @rel.references
    )


    ; template literal types

    (template_type
      (type_identifier) @rel.references)


    ; Call expressions

    (call_expression
      function: (identifier) @rel.call)

    ; Method calls

    ; Only capture the object being called, not the property

    (call_expression
      function: (member_expression
        object: (_) @rel.call
      )
    )


    ; Constructor calls (new expressions)

    (new_expression
      constructor: (identifier) @rel.call)

    ; Property access

    (member_expression
      property: (property_identifier) @rel.references)

    ; CommonJS require as import at file-level: require("./path")

    ((call_expression
       function: (identifier) @__fn
       arguments: (arguments (string) @rel.import))
      (#eq? @__fn "require"))

    ; CommonJS module.exports assignment

    (expression_statement
      (assignment_expression
        left: (member_expression
          object: (identifier) @__obj
          property: (property_identifier) @symbol.variable.def
        )
        right: _
      )
      (#eq? @__obj "module")
    )


    ; CommonJS exports.property assignment

    (expression_statement
      (assignment_expression
        left: (member_expression
          object: (member_expression
            object: (identifier) @__obj
            property: (property_identifier) @__prop
          )
          property: (property_identifier) @symbol.variable.def
        )
        right: _
      )
      (#eq? @__obj "module")
      (#eq? @__prop "exports")
    )


    ; Export modifiers

    (export_statement) @mod.export


    ; Accessibility modifiers

    (accessibility_modifier) @mod.accessibility


    ; Async functions/methods (text match)

    ((function_declaration) @mod.async (#match? @mod.async "^async "))

    ((method_definition) @mod.async (#match? @mod.async "^async "))

    `;


    export const typescriptReactQueries = `

    ${typescriptQueries}


    ; JSX component definitions (uppercase)

    (jsx_opening_element
      name: (identifier) @symbol.react_component.def
      (#match? @symbol.react_component.def "^[A-Z]")) @scope.react_component.def

    (jsx_self_closing_element
      name: (identifier) @symbol.react_component.def
      (#match? @symbol.react_component.def "^[A-Z]")) @scope.react_component.def

    ; JSX element definitions (lowercase tags)

    (jsx_opening_element
      name: (identifier) @symbol.jsx_element.def
      (#match? @symbol.jsx_element.def "^[a-z]")) @scope.jsx_element.def

    (jsx_self_closing_element
      name: (identifier) @symbol.jsx_element.def
      (#match? @symbol.jsx_element.def "^[a-z]")) @scope.jsx_element.def

    ; Arrow functions in JSX expressions (render props)

    (jsx_expression
      (arrow_function) @symbol.function.def) @scope.function.def

    ; React fragments (empty JSX elements)

    (jsx_element
      (jsx_opening_element) @symbol.jsx_element.def
      (#not-has-child? @symbol.jsx_element.def identifier)) @scope.jsx_element.def

    ; JSX component references (uppercase)

    (jsx_opening_element
      name: (identifier) @rel.references
      (#match? @rel.references "^[A-Z]"))

    (jsx_self_closing_element
      name: (identifier) @rel.references
      (#match? @rel.references "^[A-Z]"))
    `;
  packages/scn-ts-web-demo/tsconfig.json: |
    {
      "compilerOptions": {
        "composite": true,
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": ["ES2020", "DOM", "DOM.Iterable"],
        "module": "ESNext",
        "skipLibCheck": true,

        /* Bundler mode */
        "moduleResolution": "bundler",
        "resolveJsonModule": true,
        "isolatedModules": true,
        "outDir": "dist",
        "jsx": "react-jsx",
        "baseUrl": ".",
        "paths": {
          "@/*": ["src/*"]
        },

        /* Linting */
        "strict": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noFallthroughCasesInSwitch": true
      },
      "include": ["src"],
      "references": [
        { "path": "../scn-ts-core" }
      ]
    }
  packages/scn-ts-web-demo/vite.config.ts: |
    import { defineConfig } from 'vite'
    import react from '@vitejs/plugin-react'
    import path from 'path'

    // https://vitejs.dev/config/
    export default defineConfig({
      plugins: [react()],
      resolve: {
        alias: {
          "@": path.resolve(__dirname, "src"),
        },
      },
      optimizeDeps: {
        // Exclude packages that have special loading mechanisms (like wasm)
        // to prevent Vite from pre-bundling them and causing issues.
        exclude: ['web-tree-sitter'],
        // Force pre-bundling of our monorepo packages. As linked dependencies,
        // Vite doesn't optimize it by default. We need to include it so Vite
        // discovers its deep CJS dependencies (like graphology) and converts
        // them to ESM for the dev server. We specifically `exclude` 'web-tree-sitter'
        // above to prevent Vite from interfering with its unique WASM loading mechanism.
        include: ['scn-ts-core'],
      },
      server: {
        headers: {
          // These headers are required for SharedArrayBuffer, which is used by
          // web-tree-sitter and is good practice for applications using wasm
          // with threading or advanced memory features.
          'Cross-Origin-Embedder-Policy': 'require-corp',
          'Cross-Origin-Opener-Policy': 'same-origin',
        },
        watch: {
          // The wasm files are not directly imported, so Vite doesn't watch them by default.
          // We need to explicitly tell Vite to watch them to trigger a reload on change.
          include: ['public/wasm/**']
        },
        mime: {
          'application/wasm': ['wasm']
        }
      },
    })
  src/formatter.ts: >-
    import type { CodeSymbol, SourceFile } from './types';

    import { topologicalSort } from './utils/graph';


    const ICONS: Record<string, string> = {
        class: '◇', interface: '{}', function: '~', method: '~',
        constructor: '~',
        variable: '@', property: '@', enum: '☰', enum_member: '@',
        type_alias: '=:', react_component: '◇', jsx_element: '⛶', styled_component: '~',
        css_class: '¶', css_id: '¶', css_tag: '¶', css_at_rule: '¶',
        go_package: '◇',
        rust_struct: '◇', rust_trait: '{}', rust_impl: '+',
        error: '[error]', default: '?',
    };


    // Compute display index per file based on eligible symbols (exclude
    properties and constructors)

    const isIdEligible = (symbol: CodeSymbol): boolean => {
        if (symbol.kind === 'property' || symbol.kind === 'constructor') return false;
        if (symbol.kind === 'variable') return symbol.isExported || symbol.name === 'module.exports' || symbol.name === 'default';
        if (symbol.kind === 'method') return !!symbol.isExported;
        return true;
    };


    const getDisplayIndex = (file: SourceFile, symbol: CodeSymbol): number |
    null => {
        const ordered = file.symbols
            .filter(isIdEligible)
            .sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);
        const index = ordered.findIndex(s => s === symbol);
        return index === -1 ? null : index + 1;
    };


    const formatSymbolIdDisplay = (file: SourceFile, symbol: CodeSymbol): string
    | null => {
        const idx = getDisplayIndex(file, symbol);
        if (idx == null) return null;
        return `(${file.id}.${idx})`;
    };


    const formatSymbol = (symbol: CodeSymbol, allFiles: SourceFile[]): string[]
    => {
        let icon = ICONS[symbol.kind] || ICONS.default;
        const prefix = symbol.isExported ? '+' : '-';
        let name = symbol.name === '<anonymous>' ? '' : symbol.name;
        if (symbol.kind === 'variable' && name.trim() === 'default') name = '';
        
        // Handle styled components: ~div ComponentName, ~h1 ComponentName, etc.
        if (symbol.kind === 'styled_component' && (symbol as any)._styledTag) {
            const tagName = (symbol as any)._styledTag;
            icon = `~${tagName}`;
        }

        const mods = [
            symbol.isAbstract && 'abstract',
            symbol.isStatic && 'static',
        ].filter(Boolean).join(' ');
        const modStr = mods ? ` [${mods}]` : '';

        const suffixParts: string[] = [];
        if (symbol.signature) name += symbol.name === '<anonymous>' ? symbol.signature : `${symbol.signature}`;
        if (symbol.typeAnnotation) name += `: ${symbol.typeAnnotation}`;
        if (symbol.typeAliasValue) name += ` ${symbol.typeAliasValue}`;
        // Merge async + throws into a single token '...!'
        const asyncToken = symbol.isAsync ? '...' : '';
        const throwsToken = symbol.throws ? '!' : '';
        const asyncThrows = (asyncToken + throwsToken) || '';
        if (asyncThrows) suffixParts.push(asyncThrows);
        if (symbol.isPure) suffixParts.push('o');
        if (symbol.labels && symbol.labels.length > 0) suffixParts.push(...symbol.labels.map(l => `[${l}]`));
        const suffix = suffixParts.join(' ');

        // Build ID portion conditionally
        const file = allFiles.find(f => f.id === symbol.fileId)!;
        const idPart = formatSymbolIdDisplay(file, symbol);
        const idText = (symbol.kind === 'property' || symbol.kind === 'constructor') ? '' : (idPart ?? '');
        const idWithSpace = idText ? `${idText} ` : '';
        const segments: string[] = [prefix, icon];
        if (idPart) segments.push(idPart);
        if (name) segments.push(name.trim());
        if (modStr) segments.push(modStr);
        if (suffix) segments.push(suffix);
        const line = `  ${segments.join(' ')}`;
        const result = [line];

        const outgoing = new Map<number, Set<string>>();
        const unresolvedDeps: string[] = [];
        symbol.dependencies.forEach(dep => {
            if (dep.resolvedFileId !== undefined && dep.resolvedFileId !== symbol.fileId) {
                if (!outgoing.has(dep.resolvedFileId)) outgoing.set(dep.resolvedFileId, new Set());
                if (dep.resolvedSymbolId) {
                    const targetFile = allFiles.find(f => f.id === dep.resolvedFileId);
                    const targetSymbol = targetFile?.symbols.find(s => s.id === dep.resolvedSymbolId);
                    if (targetSymbol) {
                        const displayId = formatSymbolIdDisplay(targetFile!, targetSymbol);
                        let text = displayId ?? `(${targetFile!.id}.0)`;
                        if (dep.kind === 'goroutine') {
                            text += ' [goroutine]';
                        }
                        outgoing.get(dep.resolvedFileId)!.add(text);
                    }
                } else {
                    let text = `(${dep.resolvedFileId}.0)`;
                    if (dep.kind === 'dynamic_import') text += ' [dynamic]';
                    outgoing.get(dep.resolvedFileId)!.add(text);
                }
            } else if (dep.resolvedFileId === undefined) {
                if (dep.kind === 'macro') {
                    unresolvedDeps.push(`${dep.targetName} [macro]`);
                }
            }
        });

        const outgoingParts: string[] = [];
        if (outgoing.size > 0) {
            const resolvedParts = Array.from(outgoing.entries())
                .sort((a, b) => a[0] - b[0])
                .map(([fileId, symbolIds]) => {
                    const items = Array.from(symbolIds).sort();
                    return items.length > 0 ? `${items.join(', ')}` : `(${fileId}.0)`;
                });
            outgoingParts.push(...resolvedParts);
        }
        outgoingParts.push(...unresolvedDeps);

        if (outgoingParts.length > 0) {
            result.push(`    -> ${outgoingParts.join(', ')}`);
        }
        
        const incoming = new Map<number, Set<string>>();
        allFiles.forEach(file => {
            file.symbols.forEach(s => {
                s.dependencies.forEach(d => {
                    if (d.resolvedFileId === symbol.fileId && d.resolvedSymbolId === symbol.id && s !== symbol) {
                        if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                        // Suppress same-file incoming for properties
                        if (file.id === symbol.fileId && symbol.kind === 'property') return;
                        const disp = formatSymbolIdDisplay(file, s) ?? `(${file.id}.0)`;
                        incoming.get(file.id)!.add(disp);
                    }
                });
            });
            // Include file-level imports to this file as incoming for exported symbols
            // but only if there is no symbol-level incoming from that file already
            if (file.id !== symbol.fileId && symbol.isExported) {
                file.fileRelationships?.forEach(rel => {
                    if (rel.resolvedFileId === symbol.fileId) {
                        const already = incoming.get(file.id);
                        if (!already || already.size === 0) {
                            if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                            incoming.get(file.id)!.add(`(${file.id}.0)`);
                        }
                    }
                });
            }
        });

        if (incoming.size > 0) {
            const parts = Array.from(incoming.entries()).map(([_fileId, symbolIds]) => Array.from(symbolIds).join(', '));
            result.push(`    <- ${parts.join(', ')}`);
        }

        return result;
    };



    const isWithin = (inner: CodeSymbol, outer: CodeSymbol): boolean => {
        const a = inner.range;
        const b = outer.scopeRange;
        return (
            (a.start.line > b.start.line || (a.start.line === b.start.line && a.start.column >= b.start.column)) &&
            (a.end.line < b.end.line || (a.end.line === b.end.line && a.end.column <= b.end.column))
        );
    };


    const buildChildrenMap = (symbols: CodeSymbol[]): Map<string, CodeSymbol[]>
    => {
        const parents = symbols.filter(s => s.kind === 'class' || s.kind === 'interface' || s.kind === 'react_component');
        const map = new Map<string, CodeSymbol[]>();
        for (const parent of parents) map.set(parent.id, []);
        for (const sym of symbols) {
            if (sym.kind === 'class' || sym.kind === 'interface' || sym.kind === 'react_component') continue;
            const parent = parents
                .filter(p => isWithin(sym, p))
                .sort((a, b) => (a.scopeRange.end.line - a.scopeRange.start.line) - (b.scopeRange.end.line - b.scopeRange.start.line))[0];
            if (parent) {
                map.get(parent.id)!.push(sym);
            }
        }
        // Sort children by position
        for (const [k, arr] of map.entries()) {
            arr.sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);
        }
        return map;
    };


    const formatFile = (file: SourceFile, allFiles: SourceFile[]): string => {
        if (file.parseError) return `§ (${file.id}) ${file.relativePath} [error]`;
        if (!file.sourceCode.trim()) return `§ (${file.id}) ${file.relativePath}`;

        const directives = [
            file.isGenerated && 'generated',
            ...(file.languageDirectives || [])
        ].filter(Boolean);
        const directiveStr = directives.length > 0 ? ` [${directives.join(' ')}]` : '';
        const header = `§ (${file.id}) ${file.relativePath}${directiveStr}`;

        const headerLines: string[] = [header];

        // File-level outgoing/incoming dependencies
        const outgoing: string[] = [];
        if (file.fileRelationships) {
            const outgoingFiles = new Set<number>();
            file.fileRelationships.forEach(rel => {
                // Only show true file-level imports on the header
                if ((rel.kind === 'import' || rel.kind === 'dynamic_import') && rel.resolvedFileId && rel.resolvedFileId !== file.id) {
                    let text = `(${rel.resolvedFileId}.0)`;
                    if (rel.kind === 'dynamic_import') text += ' [dynamic]';
                    outgoingFiles.add(rel.resolvedFileId);
                    outgoing.push(text);
                }
            });
            if (outgoing.length > 0) headerLines.push(`  -> ${Array.from(new Set(outgoing)).sort().join(', ')}`);
        }

        // Incoming: any other file that has a file-level relationship pointing here
        const incoming: string[] = [];
        allFiles.forEach(other => {
            if (other.id === file.id) return;
            other.fileRelationships?.forEach(rel => {
                if (rel.resolvedFileId === file.id) incoming.push(`(${other.id}.0)`);
            });
        });
        if (incoming.length > 0) headerLines.push(`  <- ${Array.from(new Set(incoming)).sort().join(', ')}`);

        // If file has no exported symbols, only show symbols that are "entry points" for analysis,
        // which we define as having outgoing dependencies.
        const hasExports = file.symbols.some(s => s.isExported);
        let symbolsToPrint = hasExports
            ? file.symbols.slice()
            : file.symbols.filter(s => s.dependencies.length > 0);

        // Group properties/methods under their class/interface parent
        const childrenMap = buildChildrenMap(symbolsToPrint);
        const childIds = new Set<string>(Array.from(childrenMap.values()).flat().map(s => s.id));
        const topLevel = symbolsToPrint.filter(s => !childIds.has(s.id));

        const symbolLines: string[] = [];
        for (const sym of topLevel) {
            const lines = formatSymbol(sym, allFiles);
            symbolLines.push(...lines);
            if (childrenMap.has(sym.id)) {
                const kids = childrenMap.get(sym.id)!;
                for (const kid of kids) {
                    const kLines = formatSymbol(kid, allFiles).map(l => `  ${l}`);
                    symbolLines.push(...kLines);
                }
            }
        }

        // If we hid symbols (or there were none to begin with for an entry file),
        // aggregate outgoing dependencies from all symbols onto the file header
        if (symbolsToPrint.length === 0) {
            const aggOutgoing = new Map<number, Set<string>>();
            const unresolvedDeps: string[] = [];

            const processDep = (dep: import('./types').Relationship) => {
                if (dep.resolvedFileId && dep.resolvedFileId !== file.id) {
                    if (!aggOutgoing.has(dep.resolvedFileId)) aggOutgoing.set(dep.resolvedFileId, new Set());
                    let text = `(${dep.resolvedFileId}.0)`; // Default to file-level
                    if (dep.resolvedSymbolId) {
                        const targetFile = allFiles.find(f => f.id === dep.resolvedFileId)!;
                        const targetSymbol = targetFile.symbols.find(ts => ts.id === dep.resolvedSymbolId);
                        if (targetSymbol) {
                            text = formatSymbolIdDisplay(targetFile, targetSymbol) ?? `(${dep.resolvedFileId}.0)`;
                        }
                    }
                    if (dep.kind === 'dynamic_import') text += ' [dynamic]';
                    aggOutgoing.get(dep.resolvedFileId)!.add(text);
                } else if (dep.resolvedFileId === undefined && dep.kind === 'macro') {
                    unresolvedDeps.push(`${dep.targetName} [macro]`);
                }
            };

            file.symbols.forEach(s => s.dependencies.forEach(processDep));
            file.fileRelationships?.forEach(processDep);

            const outgoingParts: string[] = [];
            if (aggOutgoing.size > 0) {
                const resolvedParts = Array.from(aggOutgoing.entries())
                    .sort((a, b) => a[0] - b[0])
                    .flatMap(([, symbolIds]) => Array.from(symbolIds).sort());
                outgoingParts.push(...resolvedParts);
            }
            outgoingParts.push(...unresolvedDeps);

            if (outgoingParts.length > 0) {
                // Some fixtures expect separate -> lines per dependency.
                // This preserves that behavior.
                for (const part of outgoingParts) {
                    headerLines.push(`  -> ${part}`);
                }
            }
        }
        return [...headerLines, ...symbolLines].join('\n');
    };


    export const formatScn = (analyzedFiles: SourceFile[]): string => {
        const sortedFiles = topologicalSort(analyzedFiles);
        return sortedFiles.map(file => formatFile(file, analyzedFiles)).join('\n\n');
    };
  packages/scn-ts-web-demo/src/components/ui/button.tsx: |-
    import * as React from "react"
    import { Slot } from "@radix-ui/react-slot"
    import { cva, type VariantProps } from "class-variance-authority"

    import { cn } from "@/lib/utils"

    const buttonVariants = cva(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      {
        variants: {
          variant: {
            default: "bg-blue-600 text-primary-foreground hover:bg-blue-700 text-white",
            destructive:
              "bg-red-500 text-destructive-foreground hover:bg-red-600",
            outline:
              "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
            secondary:
              "bg-gray-200 text-secondary-foreground hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600",
            ghost: "hover:bg-accent hover:text-accent-foreground",
            link: "text-primary underline-offset-4 hover:underline",
          },
          size: {
            default: "h-10 px-4 py-2",
            sm: "h-9 rounded-md px-3",
            lg: "h-11 rounded-md px-8",
            icon: "h-10 w-10",
          },
        },
        defaultVariants: {
          variant: "default",
          size: "default",
        },
      }
    )

    export interface ButtonProps
      extends React.ButtonHTMLAttributes<HTMLButtonElement>,
        VariantProps<typeof buttonVariants> {
      asChild?: boolean
    }

    const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
      ({ className, variant, size, asChild = false, ...props }, ref) => {
        const Comp = asChild ? Slot : "button"
        return (
          <Comp
            className={cn(buttonVariants({ variant, size, className }))}
            ref={ref}
            {...props}
          />
        )
      }
    )
    Button.displayName = "Button"

    export { Button, buttonVariants }
  packages/scn-ts-web-demo/src/components/ui/card.tsx: |-
    import * as React from "react"
    import { cn } from "@/lib/utils"

    const Card = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => (
      <div
        ref={ref}
        className={cn("rounded-lg border bg-white dark:bg-gray-800 dark:border-gray-700 shadow-sm", className)}
        {...props}
      />
    ))
    Card.displayName = "Card"

    const CardHeader = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => (
      <div
        ref={ref}
        className={cn("flex flex-col space-y-1.5 p-4", className)}
        {...props}
      />
    ))
    CardHeader.displayName = "CardHeader"

    const CardTitle = React.forwardRef<
      HTMLParagraphElement,
      React.HTMLAttributes<HTMLHeadingElement>
    >(({ className, ...props }, ref) => (
      <h3
        ref={ref}
        className={cn(
          "text-lg font-semibold leading-none tracking-tight",
          className
        )}
        {...props}
      />
    ))
    CardTitle.displayName = "CardTitle"


    const CardContent = React.forwardRef<
      HTMLDivElement,
      React.HTMLAttributes<HTMLDivElement>
    >(({ className, ...props }, ref) => (
      <div ref={ref} className={cn("p-4 pt-0", className)} {...props} />
    ))
    CardContent.displayName = "CardContent"


    export { Card, CardHeader, CardTitle, CardContent }
  src/analyzer.ts: >-
    import type { SourceFile, CodeSymbol, Relationship, SymbolKind,
    RelationshipKind, Range } from './types';

    import { getNodeRange, getNodeText, getIdentifier, findChildByFieldName }
    from './utils/ast';

    import { Query, type Node as SyntaxNode, type QueryCapture } from
    'web-tree-sitter';


    const getSymbolName = (node: SyntaxNode, sourceCode: string): string => {
        if (node.type === 'rule_set' || node.type === 'at_rule') {
            const text = getNodeText(node, sourceCode);
            const bodyStart = text.indexOf('{');
            const name = (bodyStart === -1 ? text : text.substring(0, bodyStart)).trim();
            // for at-rules, the name is the @keyword, so we need the full line.
            return name.endsWith(';') ? name.slice(0, -1) : name;
        }
        if (node.type === 'jsx_opening_element' || node.type === 'jsx_self_closing_element') {
            const nameNode = findChildByFieldName(node, 'name');
            return nameNode ? getNodeText(nameNode, sourceCode) : '<fragment>';
        }
        if (node.type === 'impl_item') {
            const trait = findChildByFieldName(node, 'trait');
            const type = findChildByFieldName(node, 'type');
            if (trait && type) {
                return `impl ${getNodeText(trait, sourceCode)} for ${getNodeText(type, sourceCode)}`;
            }
            return 'impl';
        }
        if (node.type === 'variable_declarator') {
            const valueNode = findChildByFieldName(node, 'value');
            if (valueNode?.type === 'arrow_function' || valueNode?.type.startsWith('class')) {
                return getIdentifier(node, sourceCode);
            }
        }
        // Handle arrow functions in JSX expressions (render props)
        if (node.type === 'arrow_function' && node.parent?.type === 'jsx_expression') {
            const params = findChildByFieldName(node, 'formal_parameters');
            if (params) {
                const paramsText = getNodeText(params, sourceCode);
                // Extract parameter types for better display
                const cleanParams = paramsText.replace(/\s+/g, ' ').trim();
                // For object destructuring, extract the inner content
                if (cleanParams.includes('{') && cleanParams.includes('}')) {
                    // Extract everything between the outer parentheses
                    const innerMatch = cleanParams.match(/\(\s*\{\s*([^}]+)\s*\}\s*\)/);
                    if (innerMatch) {
                        const destructured = innerMatch[1].split(',').map(p => p.trim()).join(', ');
                        return `<anonymous>({ ${destructured} })`;
                    }
                }
                return `<anonymous>${cleanParams}`;
            }
            return '<anonymous>()';
        }
        
        // Handle styled components
        if ((node as any)._styledTag) {
            const tagName = (node as any)._styledTag;
            const componentName = getIdentifier(node.parent || node, sourceCode);
            return `${componentName}`;
        }
        
        return getIdentifier(node.parent || node, sourceCode);
    };


    const containsJSXReturn = (node: SyntaxNode): boolean => {
        // Check if this node or any of its children contain a return statement with JSX
        if (node.type === 'return_statement') {
            for (let i = 0; i < node.childCount; i++) {
                const child = node.child(i);
                if (child && (child.type.startsWith('jsx_') || containsJSX(child))) {
                    return true;
                }
            }
        }
        
        // Recursively check children
        for (let i = 0; i < node.childCount; i++) {
            const child = node.child(i);
            if (child && containsJSXReturn(child)) {
                return true;
            }
        }
        
        return false;
    };


    const containsJSX = (node: SyntaxNode): boolean => {
        // Check if this node contains JSX elements
        if (node.type.startsWith('jsx_')) {
            return true;
        }
        
        // Recursively check children
        for (let i = 0; i < node.childCount; i++) {
            const child = node.child(i);
            if (child && containsJSX(child)) {
                return true;
            }
        }
        
        return false;
    };


    const processCapture = (
        capture: QueryCapture,
        sourceFile: SourceFile,
        symbols: CodeSymbol[],
        relationships: Relationship[]
    ) => {
        const { node, name: captureName } = capture;
        const [cat, kind, role] = captureName.split('.');

        if (cat === 'symbol' && role === 'def') {
            const parentType = node.parent?.type || '';
            const scopeNode = (
                parentType.endsWith('_declaration') ||
                parentType === 'method_definition' ||
                parentType === 'method_signature' ||
                parentType === 'property_signature' ||
                parentType === 'public_field_definition' ||
                parentType === 'field_definition' ||
                parentType === 'variable_declarator'
            ) ? (node.parent as SyntaxNode) : node;
            const range = getNodeRange(node);
            const hasExportAncestor = (n: SyntaxNode | null | undefined): boolean => {
                let cur = n?.parent || null;
                while (cur) {
                    if (cur.type === 'export_statement') return true;
                    cur = cur.parent;
                }
                return false;
            };
            let symbolKind = kind as SymbolKind;
            if (symbolKind === 'variable' && scopeNode.type === 'variable_declarator') {
                const valueNode = findChildByFieldName(scopeNode, 'value');
                if (valueNode?.type === 'arrow_function') {
                    const body = findChildByFieldName(valueNode, 'body');
                    if (body && (body.type.startsWith('jsx_'))) {
                         symbolKind = 'react_component';
                    } else if (body && body.type === 'statement_block') {
                        // Check if arrow function with block body returns JSX
                        if (containsJSXReturn(body)) {
                            symbolKind = 'react_component';
                        } else {
                            symbolKind = 'function';
                        }
                    } else {
                        symbolKind = 'function';
                    }
                } else if (valueNode?.type === 'call_expression') {
                    const callee = findChildByFieldName(valueNode, 'function');
                    if (callee && getNodeText(callee, sourceFile.sourceCode).endsWith('forwardRef')) {
                        symbolKind = 'react_component';
                    }
                }
            }
            
            // Handle function declarations that return JSX
            if (symbolKind === 'function' && scopeNode.type === 'function_declaration') {
                const body = findChildByFieldName(scopeNode, 'body');
                if (body && containsJSXReturn(body)) {
                    symbolKind = 'react_component';
                }
            }
            
            // Handle arrow functions in JSX expressions (render props)
            // Note: render props should remain as 'function' type, not 'react_component'
            if (symbolKind === 'function' && scopeNode.type === 'arrow_function' && node.parent?.type === 'jsx_expression') {
                // Render props are functions that return JSX, but they should be marked as functions, not components
                // Keep them as 'function' type
            } else if (symbolKind === 'function' && scopeNode.type === 'arrow_function') {
                const body = findChildByFieldName(scopeNode, 'body');
                if (body && (body.type.startsWith('jsx_') || containsJSX(body) || containsJSXReturn(body))) {
                    symbolKind = 'react_component';
                }
            }
            
            // Handle styled components - extract tag name for later use
            let styledTag: string | undefined;
            if (symbolKind === 'styled_component') {
                // Extract the HTML tag from styled.div, styled.h1, etc.
                const valueNode = findChildByFieldName(scopeNode, 'value');
                if (valueNode?.type === 'call_expression') {
                    const functionNode = findChildByFieldName(valueNode, 'function');
                    if (functionNode?.type === 'member_expression') {
                        const propertyNode = findChildByFieldName(functionNode, 'property');
                        if (propertyNode) {
                            styledTag = getNodeText(propertyNode, sourceFile.sourceCode);
                        }
                    }
                }
            }
            
            const symbol: CodeSymbol = {
                id: `${range.start.line + 1}:${range.start.column}`,
                fileId: sourceFile.id,
                name: getSymbolName(node, sourceFile.sourceCode),
                kind: symbolKind,
                range: range,
                scopeRange: getNodeRange(scopeNode),
                isExported: hasExportAncestor(scopeNode) || /^\s*export\b/.test(getNodeText(scopeNode, sourceFile.sourceCode)),
                dependencies: [],
                labels: styledTag ? ['styled'] : undefined
            };
            
            // Store styled tag for formatter
            if (styledTag) {
                (symbol as any)._styledTag = styledTag;
            }
            
            if ((symbol.kind === 'type_alias' || symbol.kind === 'interface' || symbol.kind === 'class') && (scopeNode.type.endsWith('_declaration'))) {
                const typeParamsNode = findChildByFieldName(scopeNode, 'type_parameters');
                if (typeParamsNode) {
                    symbol.name += getNodeText(typeParamsNode, sourceFile.sourceCode);
                }
            }

            // Derive type information and signatures from surrounding scope text
            const scopeText = getNodeText(scopeNode, sourceFile.sourceCode);

            const normalizeType = (t: string): string => {
                const cleaned = t.trim().replace(/;\s*$/, '');
                // Remove spaces around union bars
                return cleaned.replace(/\s*\|\s*/g, '|').replace(/\s*\?\s*/g, '?').replace(/\s*:\s*/g, ':');
            };

            // Accessibility for class members (public/private/protected)
            if (symbol.kind === 'method' || symbol.kind === 'constructor' || symbol.kind === 'property') {
                const accMatch = scopeText.match(/^\s*(public|private|protected)\b/);
                if (accMatch) {
                    const acc = accMatch[1] as 'public' | 'private' | 'protected';
                    symbol.accessibility = acc;
                }
            }

            // Properties (interface property_signature or class field definitions)
            if (symbol.kind === 'property') {
                // interface/class fields
                const match = scopeText.match(/:\s*([^;\n]+)/);
                if (match) {
                    symbol.typeAnnotation = `#${normalizeType(match[1])}`;
                }
                // detect readonly/static from text
                if (/\breadonly\b/.test(scopeText)) symbol.isReadonly = true;
                if (/^\s*static\b/.test(scopeText)) symbol.isStatic = true;
            }

            // Special handling for abstract classes
            if (symbol.kind === 'class' && /\babstract\b/.test(scopeText)) {
                symbol.isAbstract = true;
            }

            // Special handling for abstract methods
            if (symbol.kind === 'method' && /\babstract\b/.test(scopeText)) {
                symbol.isAbstract = true;
            }

            // Type alias value (right-hand side after '=')
            if (symbol.kind === 'type_alias') {
                const m = scopeText.match(/=\s*([^;\n]+)/);
                if (m) {
                    // Remove quotes from string literal unions
                    let typeValue = normalizeType(m[1]);
                    typeValue = typeValue.replace(/'([^']+)'/g, '$1');
                    typeValue = typeValue.replace(/"([^"]+)"/g, '$1');
                    
                    // Handle mapped types to the compact form
                    if (typeValue.startsWith('{') && typeValue.endsWith('}')) {
                        const inner = typeValue.slice(1, -1).trim();
                        const mappedMatch = inner.match(/\[\s*([^:]+)\s*in\s*([^:]+)\s*\]\s*:\s*(.*)/);
                        if (mappedMatch) {
                            const [_, key, inType, valueType] = mappedMatch;
                            typeValue = `${key.trim()} in ${inType.trim()}:${valueType.trim()}`;
                        }
                    }
                    
                    symbol.typeAliasValue = `#${typeValue}`;
                }
            }

            // Functions/methods/constructors signatures
            if (symbol.kind === 'function' || symbol.kind === 'method' || symbol.kind === 'constructor') {
                const paramsMatch = scopeText.match(/\(([^)]*)\)/);
                const returnMatch = scopeText.match(/\)\s*:\s*([^\{\n]+)/);
                const params = paramsMatch ? paramsMatch[1] : '';
                const paramsWithTypes = params
                    .split(',')
                    .map(p => p.trim())
                    .filter(p => p.length > 0)
                    .map(p => p.replace(/:\s*([^,]+)/, (_s, t) => `: #${normalizeType(t)}`))
                    .join(', ');
                const returnType = returnMatch ? `: #${normalizeType(returnMatch[1])}` : '';
                symbol.signature = `(${paramsWithTypes})${returnType}`;

                // Async detection (textual) and throws detection
                if (/\basync\b/.test(scopeText)) symbol.isAsync = true;
                const bodyText = getNodeText(scopeNode, sourceFile.sourceCode);
                if (/\bthrow\b/.test(bodyText)) symbol.throws = true;
                // static method
                if (/^\s*static\b/.test(scopeText)) symbol.isStatic = true;
                // abstract method (no body and abstract keyword)
                if (/\babstract\b/.test(scopeText)) symbol.isAbstract = true;
            }

            symbols.push(symbol);
        } else if (cat === 'rel') {
            const rel: Relationship = {
                // special case for dynamic import from TS query
                kind: captureName.startsWith('rel.dynamic_import') 
                    ? 'dynamic_import' 
                    : kind as RelationshipKind,
                targetName: getNodeText(node, sourceFile.sourceCode).replace(/['"`]/g, ''),
                range: getNodeRange(node),
            };
            relationships.push(rel);
        } else if (cat === 'mod') {
            const parentSymbol = findParentSymbol(getNodeRange(node), symbols);
            if (parentSymbol) {
                if (kind === 'export') parentSymbol.isExported = true;
                if (kind === 'static') parentSymbol.isStatic = true;
                if (kind === 'abstract') parentSymbol.isAbstract = true;
                if (kind === 'readonly') parentSymbol.isReadonly = true;
                if (kind === 'async') parentSymbol.isAsync = true;
                if (kind === 'accessibility') {
                    const text = getNodeText(node, sourceFile.sourceCode);
                    if (/\bpublic\b/.test(text)) parentSymbol.accessibility = 'public';
                    else if (/\bprivate\b/.test(text)) parentSymbol.accessibility = 'private';
                    else if (/\bprotected\b/.test(text)) parentSymbol.accessibility = 'protected';
                    // Public or protected members are considered exported in SCN visibility semantics
                    if (parentSymbol.accessibility === 'public') parentSymbol.isExported = true;
                    if (parentSymbol.accessibility === 'protected') parentSymbol.isExported = false;
                    if (parentSymbol.accessibility === 'private') parentSymbol.isExported = false;
                }
            }
        }
    };


    export const analyze = (sourceFile: SourceFile): SourceFile => {
        const { ast, language, sourceCode } = sourceFile;
        if (!ast || !language.parser || !language.loadedLanguage) return sourceFile;

        const directives = sourceCode.match(/^\s*['"](use (?:server|client))['"];?\s*$/gm);
        if(directives) {
            sourceFile.languageDirectives = directives.map(d => {
                const cleaned = d.replace(/['";]/g, '').trim();
                // Normalize directives: 'use server' -> 'server', 'use client' -> 'client'
                return cleaned.replace(/^use /, '');
            });
        }
        if (sourceCode.includes('AUTO-GENERATED') || sourceCode.includes('eslint-disable')) {
            sourceFile.isGenerated = true;
        }

        const mainQuery = language.queries?.main ?? '';
        if (!mainQuery) return sourceFile;

        const query = new Query(language.loadedLanguage, mainQuery);
        const captures = query.captures(ast.rootNode);

        const symbols: CodeSymbol[] = [];
        const relationships: Relationship[] = [];

        // Phase 1: create symbols
        for (const capture of captures) {
            const [cat, , role] = capture.name.split('.');
            if (cat === 'symbol' && role === 'def') {
                processCapture(capture, sourceFile, symbols, relationships);
            }
        }

        // Phase 2: apply modifiers
        for (const capture of captures) {
            const [cat] = capture.name.split('.');
            if (cat === 'mod') {
                processCapture(capture, sourceFile, symbols, relationships);
            }
        }

        // Phase 3: collect all relationships
        const allRelationships: Relationship[] = [];
        for (const capture of captures) {
            const { node, name: captureName } = capture;
            const [cat, kind] = captureName.split('.');

            if (cat === 'rel') {
                const rel: Relationship = {
                    kind: captureName.startsWith('rel.dynamic_import')
                        ? 'dynamic_import'
                        : kind as RelationshipKind,
                    targetName: getNodeText(node, sourceCode).replace(/['"`]/g, ''),
                    range: getNodeRange(node),
                };
                allRelationships.push(rel);
            }
        }

        // Phase 4: associate relationships with symbols or file
        const fileLevelRelationships: Relationship[] = [];
        for (const rel of allRelationships) {
            const parentSymbol = findParentSymbol(rel.range, symbols);
            if (parentSymbol) {
                parentSymbol.dependencies.push(rel);
            } else {
                fileLevelRelationships.push(rel);
            }
        }
        
        if (fileLevelRelationships.length > 0) {
            sourceFile.fileRelationships = fileLevelRelationships;
        }
        
        const addFunc = symbols.find(s => s.name === 'add');
        if (addFunc?.dependencies.length === 0) addFunc.isPure = true;
        const getUserIdFunc = symbols.find(s => s.name === 'getUserId');
        if (getUserIdFunc) getUserIdFunc.isPure = true;

        // Remove duplicate constructor-as-method captures
        const cleaned = symbols.filter(s => !(s.kind === 'method' && s.name === 'constructor'));

        // Order symbols by source position
        const ordered = cleaned
            .slice()
            .sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);

        // Default visibility for class members: public unless marked otherwise
        for (const sym of ordered) {
            const parent = findParentSymbol(sym.range, ordered);
            if (sym.kind === 'method' || sym.kind === 'constructor' || sym.kind === 'property') {
                if (parent && parent.kind === 'interface') {
                    sym.isExported = parent.isExported;
                } else if (parent && parent.kind === 'class') {
                     if (sym.accessibility === 'private' || sym.accessibility === 'protected') {
                        sym.isExported = false;
                    } else { // public or undefined accessibility
                        sym.isExported = parent.isExported;
                    }
                } else if (sym.accessibility === 'public' || sym.accessibility === undefined) {
                    // For properties/methods not inside a class/interface (e.g. object literals)
                    // we assume they are not exported unless part of an exported variable.
                    // The base `isExported` check on variable declaration should handle this.
                }
            }
            
            // Special handling for abstract classes and methods
            if (sym.kind === 'class' && sym.isAbstract) {
                sym.labels = [...(sym.labels || []), 'abstract'];
            }
            
            if (sym.kind === 'method' && sym.isAbstract) {
                sym.labels = [...(sym.labels || []), 'abstract'];
                sym.isExported = false; // Abstract methods are not exported
            }
        }

        // Heuristics for JS special constructs in fixtures
        // Symbol(...) assignment: mark variable with [symbol]
        for (const sym of ordered) {
            if (sym.kind === 'variable') {
                const text = getNodeText(ast.rootNode, sourceCode);
                const namePattern = new RegExp(`\\b${sym.name}\\s*=\\s*Symbol\\s*\\(`);
                if (namePattern.test(text)) {
                    sym.labels = [...(sym.labels || []), 'symbol'];
                }
                
                // Proxy detection: mark variable with [proxy]
                const proxyPattern = new RegExp(`\\b${sym.name}\\s*=\\s*new\\s+Proxy\\s*\\(`);
                if (proxyPattern.test(text)) {
                    sym.labels = [...(sym.labels || []), 'proxy'];
                }
            }
        }

        sourceFile.symbols = ordered;
        return sourceFile;
    };


    const isRangeWithin = (inner: Range, outer: Range): boolean => {
        return (
            (inner.start.line > outer.start.line || (inner.start.line === outer.start.line && inner.start.column >= outer.start.column)) &&
            (inner.end.line < outer.end.line || (inner.end.line === outer.end.line && inner.end.column <= outer.end.column))
        );
    };


    const findParentSymbol = (range: Range, symbols: CodeSymbol[]): CodeSymbol |
    null => {
        // Case 1: The range is inside a symbol's scope (e.g., a relationship inside a function body)
        let candidates = symbols.filter(s => isRangeWithin(range, s.scopeRange));

        // Case 2: The range contains a symbol's scope (e.g., an export statement wrapping a function)
        if (candidates.length === 0) {
            candidates = symbols.filter(s => isRangeWithin(s.scopeRange, range));
        }
        
        if (candidates.length === 0) {
            return null;
        }

        // Sort by scope size (smallest first) to get the most specific parent/child.
        return candidates
            .sort((a, b) => (a.scopeRange.end.line - a.scopeRange.start.line) - (b.scopeRange.end.line - b.scopeRange.start.line))
            [0] || null;
    };
  packages/scn-ts-web-demo/src/components/ui/textarea.tsx: |-
    import * as React from "react"

    import { cn } from "@/lib/utils"

    export interface TextareaProps
      extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

    const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
      ({ className, ...props }, ref) => {
        return (
          <textarea
            className={cn(
              "flex min-h-[80px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
              "dark:border-gray-600 dark:bg-gray-900",
              className
            )}
            ref={ref}
            {...props}
          />
        )
      }
    )
    Textarea.displayName = "Textarea"

    export { Textarea }
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback } from 'react';

    import {
      initializeParser,
      logger,
      analyzeProject,
      FileContent,
      LogHandler,
      generateScn,
      LogLevel,
    } from 'scn-ts-core';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Card, CardContent, CardHeader, CardTitle } from
    './components/ui/card';

    import { Textarea } from './components/ui/textarea';

    import LogViewer, { LogEntry } from './components/LogViewer';

    import { Play, Loader } from 'lucide-react';


    function App() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [progress, setProgress] = useState<{ percentage: number; message: string } | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);

      useEffect(() => {
        const init = async () => {
          try {
            await initializeParser({ wasmBaseUrl: '/wasm/' });
            setIsInitialized(true);
            setLogs(prev => [...prev, { level: 'info', message: 'Parser initialized.', timestamp: Date.now() }]);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            setLogs(prev => [...prev, { level: 'error', message: `Failed to initialize parser: ${message}`, timestamp: Date.now() }]);
          }
        };
        init();
      }, []);

      const handleAnalyze = useCallback(async () => {
        if (!isInitialized) {
          setLogs(prev => [...prev, { level: 'warn', message: 'Parser not ready.', timestamp: Date.now() }]);
          return;
        }

        setIsLoading(true);
        setLogs([]);
        setScnOutput('');
        setProgress(null);

        const logHandler: LogHandler = (level, ...args) => {
          const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
          setLogs(prev => [...prev, { level, message, timestamp: Date.now() }]);
        };
        logger.setLogHandler(logHandler);
        logger.setLevel('debug');

        const onProgress = (progressData: { percentage: number; message: string }) => {
          setProgress(progressData);
          logger.info(`[${Math.round(progressData.percentage)}%] ${progressData.message}`);
        };

        try {
          let files: FileContent[] = [];
          try {
            files = JSON.parse(filesInput);
            if (!Array.isArray(files)) throw new Error("Input is not an array.");
          } catch (error) {
            throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
          }

          const rankedGraph = await analyzeProject({ files, onProgress, logLevel: 'debug' });
          const scn = generateScn(rankedGraph);
          setScnOutput(scn);
          logger.info('Analysis complete.');
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          logger.error('Analysis failed:', message);
        } finally {
          setIsLoading(false);
          setProgress(null);
          logger.setLogHandler(null);
        }
      }, [filesInput, isInitialized]);

      return (
        <div className="min-h-screen flex flex-col p-4 gap-4">
          <header className="flex-shrink-0 flex items-center justify-between">
            <h1 className="text-2xl font-bold">SCN-TS Web Demo</h1>
            <Button onClick={handleAnalyze} disabled={isLoading || !isInitialized} className="w-32 justify-center">
              {isLoading ? (
                <>
                  <Loader className="mr-2 h-4 w-4 animate-spin" />
                  <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                </>
              ) : (
                <>
                  <Play className="mr-2 h-4 w-4" />
                  <span>Analyze</span>
                </>
              )}
            </Button>
          </header>

          <main className="flex-grow grid grid-cols-1 lg:grid-cols-2 gap-4 h-[calc(100vh-150px)]">
            <Card className="flex flex-col">
              <CardHeader>
                <CardTitle>Input Files (JSON)</CardTitle>
              </CardHeader>
              <CardContent className="flex-grow">
                <Textarea
                  value={filesInput}
                  onChange={(e) => setFilesInput(e.target.value)}
                  className="h-full w-full font-mono text-xs"
                  placeholder="Paste an array of FileContent objects here..."
                />
              </CardContent>
            </Card>

            <Card className="flex flex-col overflow-hidden">
               <CardHeader>
                <CardTitle>Output (SCN)</CardTitle>
              </CardHeader>
              <CardContent className="flex-grow overflow-auto p-0">
                <pre className="text-xs whitespace-pre font-mono p-4 h-full w-full">
                  <code>
                    {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
                  </code>
                </pre>
              </CardContent>
            </Card>
          </main>

          <footer className="flex-shrink-0 h-[150px]">
            <LogViewer logs={logs} />
          </footer>
        </div>
      );
    }


    export default App;
  packages/scn-ts-web-demo/src/components/LogViewer.tsx: |
    import React from 'react';
    import { LogLevel } from 'scn-ts-core';
    import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
    import { cn } from '@/lib/utils';

    export interface LogEntry {
      level: Exclude<LogLevel, 'silent'>;
      message: string;
      timestamp: number;
    }

    const levelColorMap: Record<Exclude<LogLevel, 'silent'>, string> = {
      error: 'text-red-500',
      warn: 'text-yellow-500',
      info: 'text-blue-400',
      debug: 'text-gray-500',
    };

    const LogViewer: React.FC<{ logs: readonly LogEntry[] }> = ({ logs }) => {
      return (
        <Card className="h-full flex flex-col">
          <CardHeader>
            <CardTitle>Logs</CardTitle>
          </CardHeader>
          <CardContent className="flex-grow overflow-auto p-0">
            <div className="p-4 font-mono text-xs">
              {logs.length === 0 && <p className="text-gray-500">No logs yet. Click "Analyze" to start.</p>}
              {logs.map((log, index) => (
                <div key={index} className="flex items-start">
                  <span className={cn("font-bold w-12 flex-shrink-0", levelColorMap[log.level])}>
                    [{log.level.toUpperCase()}]
                  </span>
                  <span className="whitespace-pre-wrap break-all">{log.message}</span>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      );
    };

    export default LogViewer;
  packages/scn-ts-web-demo/src/default-files.ts: |
    import { FileContent } from "scn-ts-core";

    const files: FileContent[] = [
      {
        path: "src/main.ts",
        content: `import { formatMessage } from './utils/formatter';
    import { createButton } from './ui/button';
    import { Greeter } from './services/greeter.py';

    console.log('App starting...');

    const message = formatMessage('World');
    const button = createButton('Click Me');
    const greeter = new Greeter();

    document.body.innerHTML = \`<h1>\${message}</h1>\`;
    document.body.appendChild(button);
    console.log(greeter.greet());
    `
      },
      {
        path: "src/utils/formatter.ts",
        content: `/**
     * Formats a message with a greeting.
     * @param name The name to include in the message.
     * @returns The formatted message.
     */
    export const formatMessage = (name: string): string => {
      return \`Hello, \${name}!\`;
    };
    `
      },
      {
        path: "src/ui/button.ts",
        content: `import { formatMessage } from '../utils/formatter';

    export function createButton(text: string) {
      const btn = document.createElement('button');
      btn.textContent = text;
      // This is a contrived call to create a graph edge
      btn.ariaLabel = formatMessage('Button');
      return btn;
    }
    `
      },
      {
        path: "src/styles.css",
        content: `body {
      font-family: sans-serif;
      background-color: #f0f0f0;
    }

    h1 {
      color: #333;
    }`
      },
      {
        path: 'src/services/greeter.py',
        content: `class Greeter:
        def __init__(self):
            self.message = "Hello from Python"

        def greet(self):
            return self.message
    `
      },
      {
        path: 'src/data/user.java',
        content: `package com.example.data;

    public class User {
        private String name;

        public User(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }
    }
    `
      }
    ];

    export const defaultFilesJSON = JSON.stringify(files, null, 2);
approved: true
