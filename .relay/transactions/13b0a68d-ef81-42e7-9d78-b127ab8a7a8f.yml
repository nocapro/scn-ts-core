uuid: 13b0a68d-ef81-42e7-9d78-b127ab8a7a8f
projectId: scn-ts-core
createdAt: '2025-09-04T17:38:12.396Z'
linesAdded: 14
linesRemoved: 4
gitCommitMsg: 'fix(web-demo): resolve typescript errors'
promptSummary: >-
  Fix several TypeScript errors in the scn-ts-web-demo package related to a
  missing type definition and an unused import.
reasoning:
  - >-
    ok, y combinator programmer netizens, let's squash these typescript bugs.
    most of them are downstream from a missing type definition. classic. let's
    get it.
  - >-
    First, I'll define the `FormattingOptions` type. It's used in a couple of
    places but isn't defined or exported from the core package. I'll add it to
    the web demo's local `types.ts` file. This is the root of the problem.
  - >-
    Next, in `App.tsx`, I'll fix the imports. I'll remove the unused `useRef`
    and then change the import for `FormattingOptions` to pull from our newly
    updated local `types.ts` instead of the non-existent export from the core
    package.
  - >-
    Finally, I'll update `OutputOptions.tsx` to import `FormattingOptions` from
    the correct local types file. This will resolve the rest of the TypeScript
    errors, as they all stemmed from `FormattingOptions` being an unresolved
    type.
  - There, all errors fixed. Ship it.
operations:
  - type: write
    path: packages/scn-ts-web-demo/src/types.ts
    content: |-
      --- packages/scn-ts-web-demo/src/types.ts
      +++ packages/scn-ts-web-demo/src/types.ts
      @@ -10,3 +10,13 @@
         percentage: number;
         message: string;
       }
      +
      +export interface FormattingOptions {
      +  showOutgoing?: boolean;
      +  showIncoming?: boolean;
      +  showIcons?: boolean;
      +  showVisibility?: boolean;
      +  showModifiers?: boolean;
      +  showTags?: boolean;
      +  showSymbolIds?: boolean;
      +}
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: >-
      --- packages/scn-ts-web-demo/src/App.tsx

      +++ packages/scn-ts-web-demo/src/App.tsx

      @@ -1,15 +1,15 @@

      -import { useState, useEffect, useCallback, useRef } from 'react';

      +import { useState, useEffect, useCallback } from 'react';
       import { get_encoding, type Tiktoken } from 'tiktoken';
       import {
         initializeParser,
         logger,
         analyzeProject,
         generateScn,
       } from '../../../index';
      -import type { FileContent, LogHandler, SourceFile, FormattingOptions }
      from '../../../index';

      +import type { FileContent, LogHandler, SourceFile } from
      '../../../index';
       import { defaultFilesJSON } from './default-files';
       import { Button } from './components/ui/button';
       import { Card, CardContent, CardHeader, CardTitle } from './components/ui/card';
       import { Textarea } from './components/ui/textarea';
       import LogViewer from './components/LogViewer';
       import OutputOptions from './components/OutputOptions';
       import { Play, Loader } from 'lucide-react';
      -import type { LogEntry, ProgressData } from './types';

      +import type { LogEntry, ProgressData, FormattingOptions } from './types';
       
       function App() {
         const [isInitialized, setIsInitialized] = useState(false);
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/components/OutputOptions.tsx
    content: |-
      --- packages/scn-ts-web-demo/src/components/OutputOptions.tsx
      +++ packages/scn-ts-web-demo/src/components/OutputOptions.tsx
      @@ -1,5 +1,5 @@
       import * as React from 'react';
      -import type { FormattingOptions } from '../../../index';
      +import type { FormattingOptions } from '../types';
       import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
       
       interface OutputOptionsProps {
    patchStrategy: new-unified
snapshot:
  packages/scn-ts-web-demo/src/types.ts: |-
    import type { LogLevel } from 'scn-ts-core';

    export interface LogEntry {
      level: Exclude<LogLevel, 'silent'>;
      message: string;
      timestamp: number;
    }

    export interface ProgressData {
      percentage: number;
      message: string;
    }
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback, useRef } from 'react';

    import { get_encoding, type Tiktoken } from 'tiktoken';

    import {
      initializeParser,
      logger,
      analyzeProject,
      generateScn,
    } from '../../../index';

    import type { FileContent, LogHandler, SourceFile, FormattingOptions } from
    '../../../index';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Card, CardContent, CardHeader, CardTitle } from
    './components/ui/card';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import OutputOptions from './components/OutputOptions';

    import { Play, Loader } from 'lucide-react';

    import type { LogEntry, ProgressData } from './types';


    function App() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
      const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
        showOutgoing: true,
        showIncoming: true,
        showIcons: true,
        showVisibility: true,
        showModifiers: true,
        showTags: true,
        showSymbolIds: true,
      });
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [encoder, setEncoder] = useState<Tiktoken | null>(null);
      const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });

      useEffect(() => {
        const init = async () => {
          try {
            await initializeParser({ wasmBaseUrl: '/wasm/' });
            const enc = get_encoding("cl100k_base");
            setEncoder(enc);
            setIsInitialized(true);
            setLogs(prev => [...prev, { level: 'info', message: 'Parser and tokenizer initialized.', timestamp: Date.now() }]);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            setLogs(prev => [...prev, { level: 'error', message: `Failed to initialize: ${message}`, timestamp: Date.now() }]);
          }
        };
        init();
      }, []);

      useEffect(() => {
        if (!encoder) return;
        try {
          const inputTokens = encoder.encode(filesInput).length;
          const outputTokens = encoder.encode(scnOutput).length;
          setTokenCounts({ input: inputTokens, output: outputTokens });
        } catch (e) {
          console.error("Tokenization error:", e);
          setTokenCounts({ input: 0, output: 0 });
        }
      }, [filesInput, scnOutput, encoder]);

      useEffect(() => {
        if (analysisResult) {
          const scn = generateScn(analysisResult, formattingOptions);
          setScnOutput(scn);
        }
      }, [analysisResult, formattingOptions]);

      const handleAnalyze = useCallback(async () => {
        if (!isInitialized) {
          setLogs(prev => [...prev, { level: 'warn', message: 'Parser not ready.', timestamp: Date.now() }]);
          return;
        }

        setIsLoading(true);
        setLogs([]);
        setScnOutput('');
        setAnalysisResult(null);
        setProgress(null);

        const logHandler: LogHandler = (level, ...args) => {
          const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
          setLogs(prev => [...prev, { level, message, timestamp: Date.now() }]);
        };
        logger.setLogHandler(logHandler);
        logger.setLevel('debug');

        const onProgress = (progressData: ProgressData) => {
          setProgress(progressData);
          logger.info(`[${Math.round(progressData.percentage)}%] ${progressData.message}`);
        };

        try {
          let files: FileContent[] = [];
          try {
            files = JSON.parse(filesInput);
            if (!Array.isArray(files)) throw new Error("Input is not an array.");
          } catch (error) {
            throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
          }

          const rankedGraph = await analyzeProject({ files, onProgress, logLevel: 'debug' });
          setAnalysisResult(rankedGraph);
          logger.info('Analysis complete.');
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          logger.error('Analysis failed:', message);
        } finally {
          setIsLoading(false);
          setProgress(null);
          logger.setLogHandler(null);
        }
      }, [filesInput, isInitialized]);

      return (
        <div className="h-screen w-screen flex flex-col bg-background text-foreground">
          <header className="flex-shrink-0 flex items-center justify-between p-4 border-b">
            <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
            <Button onClick={handleAnalyze} disabled={isLoading || !isInitialized} className="w-32 justify-center">
              {isLoading ? (
                <>
                  <Loader className="mr-2 h-4 w-4 animate-spin" />
                  <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                </>
              ) : (
                <>
                  <Play className="mr-2 h-4 w-4" />
                  <span>Analyze</span>
                </>
              )}
            </Button>
          </header>

          <main className="flex-grow flex flex-col gap-4 p-4 overflow-hidden">
            <div className="flex-grow grid grid-cols-1 lg:grid-cols-3 gap-4 overflow-hidden min-h-0">
              {/* Column 1: Input & Options */}
              <div className="lg:col-span-1 flex flex-col gap-4 overflow-hidden min-h-0">
                <Card className="flex flex-col overflow-hidden flex-grow">
                  <CardHeader>
                    <CardTitle className="flex justify-between items-center">
                      <span>Input Files (JSON)</span>
                      <span className="text-sm font-normal text-muted-foreground">{tokenCounts.input.toLocaleString()} tokens</span>
                    </CardTitle>
                  </CardHeader>
                  <CardContent className="flex-grow">
                    <Textarea
                      value={filesInput}
                      onChange={(e) => setFilesInput(e.currentTarget.value)}
                      className="h-full w-full font-mono text-xs resize-none"
                      placeholder="Paste an array of FileContent objects here..."
                    />
                  </CardContent>
                </Card>
                <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} />
              </div>

              {/* Column 2 & 3: Output */}
              <Card className="lg:col-span-2 flex flex-col overflow-hidden min-h-0">
                <CardHeader>
                  <div className="flex justify-between items-center">
                    <CardTitle>Output (SCN)</CardTitle>
                    <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                  </div>
                </CardHeader>
                <CardContent className="flex-grow overflow-auto">
                  <pre className="text-xs whitespace-pre-wrap font-mono h-full w-full">
                    <code className="h-full w-full">
                      {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
                    </code>
                  </pre>
                </CardContent>
              </Card>
            </div>
            <div className="flex-shrink-0 h-1/3 max-h-[25rem] border rounded-lg overflow-hidden">
              <LogViewer logs={logs} />
            </div>
          </main>
        </div>
      );
    }


    export default App;
  packages/scn-ts-web-demo/src/components/OutputOptions.tsx: >-
    import * as React from 'react';

    import type { FormattingOptions } from '../../../index';

    import { Card, CardContent, CardHeader, CardTitle } from './ui/card';


    interface OutputOptionsProps {
      options: FormattingOptions;
      setOptions: React.Dispatch<React.SetStateAction<FormattingOptions>>;
    }


    const OptionCheckbox: React.FC<{
      id: keyof FormattingOptions;
      label: string;
      checked: boolean;
      onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    }> = ({ id, label, checked, onChange }) => (
      <div className="flex items-center space-x-1.5">
        <input
          type="checkbox"
          id={id}
          checked={checked}
          onChange={onChange}
          className="h-4 w-4 rounded border-muted-foreground/50 bg-transparent text-primary focus:ring-primary"
        />
        <label htmlFor={id} className="cursor-pointer select-none text-sm text-muted-foreground">
          {label}
        </label>
      </div>
    );


    const OutputOptions: React.FC<OutputOptionsProps> = ({ options, setOptions
    }) => {
      const handleChange = (option: keyof FormattingOptions) => (e: React.ChangeEvent<HTMLInputElement>) => {
        setOptions(prev => ({ ...prev, [option]: e.target.checked }));
      };

      return (
        <Card>
          <CardHeader className="py-3">
            <CardTitle className="text-base">Formatting Options</CardTitle>
          </CardHeader>
          <CardContent className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-2 xl:grid-cols-3 gap-4 pt-0 pb-4">
            <OptionCheckbox
              id="showOutgoing"
              label="Outgoing"
              checked={options.showOutgoing ?? true}
              onChange={handleChange('showOutgoing')}
            />
            <OptionCheckbox
              id="showIncoming"
              label="Incoming"
              checked={options.showIncoming ?? true}
              onChange={handleChange('showIncoming')}
            />
            <OptionCheckbox
              id="showIcons"
              label="Icons"
              checked={options.showIcons ?? true}
              onChange={handleChange('showIcons')}
            />
            <OptionCheckbox
              id="showVisibility"
              label="Visibility"
              checked={options.showVisibility ?? true}
              onChange={handleChange('showVisibility')}
            />
            <OptionCheckbox
              id="showModifiers"
              label="Modifiers"
              checked={options.showModifiers ?? true}
              onChange={handleChange('showModifiers')}
            />
            <OptionCheckbox
              id="showTags"
              label="Tags"
              checked={options.showTags ?? true}
              onChange={handleChange('showTags')}
            />
            <OptionCheckbox
              id="showSymbolIds"
              label="Symbol IDs"
              checked={options.showSymbolIds ?? true}
              onChange={handleChange('showSymbolIds')}
            />
          </CardContent>
        </Card>
      );
    };


    export default OutputOptions;
approved: true
