uuid: 48d90214-411a-4710-85aa-5b91b9338b81
projectId: scn-ts-core
createdAt: '2025-09-04T16:48:57.933Z'
linesAdded: 51
linesRemoved: 31
gitCommitMsg: 'refactor(core): centralize SCN format strings in constants'
promptSummary: Refactor SCN symbol strings (e.g., '->', '<-') into constants.ts.
reasoning:
  - >-
    y combinator programmer netizen language activate. alright fam, let's ship
    this refactor. we're gonna centralize all those magic scn strings into
    `constants.ts` to keep things DRY and make it easier to tweak the format
    later. solid engineering principle, you feel me?
  - >-
    first, i'll drop a new `SCN_SYMBOLS` export in `src/constants.ts` to hold
    all our formatting characters and tags.
  - >-
    next, i'm hitting up `src/analyzer.ts` to swap out the hardcoded labels for
    our new constants. this makes sure our symbol analysis uses the single
    source of truth for these tags.
  - >-
    finally, i'm cleaning up `src/formatter.ts`. this is where the magic
    happens. replacing all those raw strings with our shiny new constants. now
    the output format is driven by one config object. clean.
operations:
  - type: write
    path: src/constants.ts
    content: |-
      --- src/constants.ts
      +++ src/constants.ts
      @@ -8,4 +8,24 @@
           error: '[error]', default: '?',
       };
       
      +export const SCN_SYMBOLS = {
      +    FILE_PREFIX: '§',
      +    EXPORTED_PREFIX: '+',
      +    PRIVATE_PREFIX: '-',
      +    OUTGOING_ARROW: '->',
      +    INCOMING_ARROW: '<-',
      +    ASYNC: '...',
      +    THROWS: '!',
      +    PURE: 'o',
      +    TAG_GENERATED: '[generated]',
      +    TAG_DYNAMIC: '[dynamic]',
      +    TAG_GOROUTINE: '[goroutine]',
      +    TAG_MACRO: '[macro]',
      +    TAG_SYMBOL: '[symbol]',
      +    TAG_PROXY: '[proxy]',
      +    TAG_ABSTRACT: '[abstract]',
      +    TAG_STATIC: '[static]',
      +    TAG_STYLED: '[styled]',
      +};
      +
       export const RESOLVE_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx', '.css', '.go', '.rs', '.py', '.java', '.graphql', ''];
    patchStrategy: new-unified
  - type: write
    path: src/analyzer.ts
    content: >-
      --- src/analyzer.ts

      +++ src/analyzer.ts

      @@ -1,5 +1,6 @@
       import type { SourceFile, CodeSymbol, Relationship, SymbolKind, RelationshipKind, Range } from './types';
       import { getNodeRange, getNodeText, getIdentifier, findChildByFieldName } from './utils/ast';
      +import { SCN_SYMBOLS } from './constants';
       import { Query, type Node as SyntaxNode, type QueryCapture } from 'web-tree-sitter';
       
       const getSymbolName = (node: SyntaxNode, sourceCode: string): string => {
      @@ -217,7 +218,7 @@
                   range: range,
                   scopeRange: getNodeRange(scopeNode),
                   isExported: hasExportAncestor(scopeNode) || /^\s*export\b/.test(getNodeText(scopeNode, sourceCode)),
                   dependencies: [],
      -            labels: styledTag ? ['styled'] : undefined

      +            labels: styledTag ? [SCN_SYMBOLS.TAG_STYLED.slice(1, -1)] :
      undefined
               };
               
               // Store styled tag for formatter
      @@ -421,25 +422,25 @@
               
               // Special handling for abstract classes and methods
               if (sym.kind === 'class' && sym.isAbstract) {
      -            sym.labels = [...(sym.labels || []), 'abstract'];

      +            sym.labels = [...(sym.labels || []),
      SCN_SYMBOLS.TAG_ABSTRACT.slice(1, -1)];
               }
               
               if (sym.kind === 'method' && sym.isAbstract) {
      -            sym.labels = [...(sym.labels || []), 'abstract'];

      +            sym.labels = [...(sym.labels || []),
      SCN_SYMBOLS.TAG_ABSTRACT.slice(1, -1)];
                   sym.isExported = false; // Abstract methods are not exported
               }
           }
       
           // Heuristics for JS special constructs in fixtures
           // Symbol(...) assignment: mark variable with [symbol]
           for (const sym of ordered) {
               if (sym.kind === 'variable') {
                   const text = getNodeText(ast.rootNode, sourceCode);
                   const namePattern = new RegExp(`\\b${sym.name}\\s*=\\s*Symbol\\s*\\(`);
                   if (namePattern.test(text)) {
      -                sym.labels = [...(sym.labels || []), 'symbol'];

      +                sym.labels = [...(sym.labels || []),
      SCN_SYMBOLS.TAG_SYMBOL.slice(1, -1)];
                   }
                   
                   // Proxy detection: mark variable with [proxy]
                   const proxyPattern = new RegExp(`\\b${sym.name}\\s*=\\s*new\\s+Proxy\\s*\\(`);
                   if (proxyPattern.test(text)) {
      -                sym.labels = [...(sym.labels || []), 'proxy'];

      +                sym.labels = [...(sym.labels || []),
      SCN_SYMBOLS.TAG_PROXY.slice(1, -1)];
                   }
               }
           }
    patchStrategy: new-unified
  - type: write
    path: src/formatter.ts
    content: >-
      --- src/formatter.ts

      +++ src/formatter.ts

      @@ -1,5 +1,5 @@
       import type { CodeSymbol, SourceFile } from './types';
       import { topologicalSort } from './utils/graph';
      -import { ICONS } from './constants';

      +import { ICONS, SCN_SYMBOLS } from './constants';
       
       // Compute display index per file based on eligible symbols (exclude properties and constructors)
       const isIdEligible = (symbol: CodeSymbol): boolean => {
      @@ -23,7 +23,7 @@
       
       const formatSymbol = (symbol: CodeSymbol, allFiles: SourceFile[]): string[] => {
           let icon = ICONS[symbol.kind] || ICONS.default || '?';
      -    const prefix = symbol.isExported ? '+' : '-';

      +    const prefix = symbol.isExported ? SCN_SYMBOLS.EXPORTED_PREFIX :
      SCN_SYMBOLS.PRIVATE_PREFIX;
           let name = symbol.name === '<anonymous>' ? '' : symbol.name;
           if (symbol.kind === 'variable' && name.trim() === 'default') name = '';
           
      @@ -33,18 +33,18 @@
               icon = `~${tagName}`;
           }
       
      -    const mods = [

      -        symbol.isAbstract && 'abstract',

      -        symbol.isStatic && 'static',

      -    ].filter(Boolean).join(' ');

      -    const modStr = mods ? ` [${mods}]` : '';

      +    const mods: string[] = [];

      +    if (symbol.isAbstract) mods.push(SCN_SYMBOLS.TAG_ABSTRACT.slice(1,
      -1));

      +    if (symbol.isStatic) mods.push(SCN_SYMBOLS.TAG_STATIC.slice(1, -1));

      +    const modStr = mods.length > 0 ? ` [${mods.join(' ')}]` : '';
       
           const suffixParts: string[] = [];
           if (symbol.signature) name += symbol.name === '<anonymous>' ? symbol.signature : `${symbol.signature}`;
           if (symbol.typeAnnotation) name += `: ${symbol.typeAnnotation}`;
           if (symbol.typeAliasValue) name += ` ${symbol.typeAliasValue}`;
      -    // Merge async + throws into a single token '...!'

      -    const asyncToken = symbol.isAsync ? '...' : '';

      -    const throwsToken = symbol.throws ? '!' : '';

      +    // Merge async + throws into a single token

      +    const asyncToken = symbol.isAsync ? SCN_SYMBOLS.ASYNC : '';

      +    const throwsToken = symbol.throws ? SCN_SYMBOLS.THROWS : '';
           const asyncThrows = (asyncToken + throwsToken) || '';
           if (asyncThrows) suffixParts.push(asyncThrows);
      -    if (symbol.isPure) suffixParts.push('o');

      +    if (symbol.isPure) suffixParts.push(SCN_SYMBOLS.PURE);
           if (symbol.labels && symbol.labels.length > 0) suffixParts.push(...symbol.labels.map(l => `[${l}]`));
           const suffix = suffixParts.join(' ');
       
      @@ -69,17 +69,17 @@
                           const displayId = formatSymbolIdDisplay(targetFile!, targetSymbol);
                           let text = displayId ?? `(${targetFile!.id}.0)`;
                           if (dep.kind === 'goroutine') {
      -                        text += ' [goroutine]';

      +                        text += ` ${SCN_SYMBOLS.TAG_GOROUTINE}`;
                           }
                           outgoing.get(dep.resolvedFileId)!.add(text);
                       }
                   } else {
                       let text = `(${dep.resolvedFileId}.0)`;
      -                if (dep.kind === 'dynamic_import') text += ' [dynamic]';

      +                if (dep.kind === 'dynamic_import') text += `
      ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                       outgoing.get(dep.resolvedFileId)!.add(text);
                   }
               } else if (dep.resolvedFileId === undefined) {
                   if (dep.kind === 'macro') {
      -                unresolvedDeps.push(`${dep.targetName} [macro]`);

      +                unresolvedDeps.push(`${dep.targetName}
      ${SCN_SYMBOLS.TAG_MACRO}`);
                   }
               }
           });
      @@ -96,7 +96,7 @@
           outgoingParts.push(...unresolvedDeps);
       
           if (outgoingParts.length > 0) {
      -        result.push(`    -> ${outgoingParts.join(', ')}`);

      +        result.push(`    ${SCN_SYMBOLS.OUTGOING_ARROW}
      ${outgoingParts.join(', ')}`);
           }
           
           const incoming = new Map<number, Set<string>>();
      @@ -127,7 +127,7 @@
       
           if (incoming.size > 0) {
               const parts = Array.from(incoming.entries()).map(([_fileId, symbolIds]) => Array.from(symbolIds).join(', '));
      -        result.push(`    <- ${parts.join(', ')}`);

      +        result.push(`    ${SCN_SYMBOLS.INCOMING_ARROW} ${parts.join(',
      ')}`);
           }
       
           return result;
      @@ -165,14 +165,14 @@
       };
       
       const formatFile = (file: SourceFile, allFiles: SourceFile[]): string => {
      -    if (file.parseError) return `§ (${file.id}) ${file.relativePath}
      [error]`;

      -    if (!file.sourceCode.trim()) return `§ (${file.id})
      ${file.relativePath}`;

      +    if (file.parseError) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id})
      ${file.relativePath} [error]`;

      +    if (!file.sourceCode.trim()) return `${SCN_SYMBOLS.FILE_PREFIX}
      (${file.id}) ${file.relativePath}`;
       
           const directives = [
      -        file.isGenerated && 'generated',

      +        file.isGenerated && SCN_SYMBOLS.TAG_GENERATED.slice(1, -1),
               ...(file.languageDirectives || [])
           ].filter(Boolean);
           const directiveStr = directives.length > 0 ? ` [${directives.join(' ')}]` : '';
      -    const header = `§ (${file.id}) ${file.relativePath}${directiveStr}`;

      +    const header = `${SCN_SYMBOLS.FILE_PREFIX} (${file.id})
      ${file.relativePath}${directiveStr}`;
       
           const headerLines: string[] = [header];
       
      @@ -183,13 +183,13 @@
               file.fileRelationships.forEach(rel => {
                   // Only show true file-level imports on the header
                   if ((rel.kind === 'import' || rel.kind === 'dynamic_import') && rel.resolvedFileId && rel.resolvedFileId !== file.id) {
                       let text = `(${rel.resolvedFileId}.0)`;
      -                if (rel.kind === 'dynamic_import') text += ' [dynamic]';

      +                if (rel.kind === 'dynamic_import') text += `
      ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                       outgoingFiles.add(rel.resolvedFileId);
                       outgoing.push(text);
                   }
               });
      -        if (outgoing.length > 0) headerLines.push(`  -> ${Array.from(new
      Set(outgoing)).sort().join(', ')}`);

      +        if (outgoing.length > 0) headerLines.push(` 
      ${SCN_SYMBOLS.OUTGOING_ARROW} ${Array.from(new
      Set(outgoing)).sort().join(', ')}`);
           }
       
           // Incoming: any other file that has a file-level relationship pointing here
      @@ -200,7 +200,7 @@
                   if (rel.resolvedFileId === file.id) incoming.push(`(${other.id}.0)`);
               });
           });
      -    if (incoming.length > 0) headerLines.push(`  <- ${Array.from(new
      Set(incoming)).sort().join(', ')}`);

      +    if (incoming.length > 0) headerLines.push(` 
      ${SCN_SYMBOLS.INCOMING_ARROW} ${Array.from(new
      Set(incoming)).sort().join(', ')}`);
       
           // If file has no exported symbols, only show symbols that are "entry points" for analysis,
           // which we define as having outgoing dependencies.
      @@ -239,10 +239,10 @@
                               text = formatSymbolIdDisplay(targetFile, targetSymbol) ?? `(${dep.resolvedFileId}.0)`;
                           }
                       }
      -                if (dep.kind === 'dynamic_import') text += ' [dynamic]';

      +                if (dep.kind === 'dynamic_import') text += `
      ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                       aggOutgoing.get(dep.resolvedFileId)!.add(text);
                   } else if (dep.resolvedFileId === undefined && dep.kind === 'macro') {
      -                unresolvedDeps.push(`${dep.targetName} [macro]`);

      +                unresolvedDeps.push(`${dep.targetName}
      ${SCN_SYMBOLS.TAG_MACRO}`);
                   }
               };
       
      @@ -262,7 +262,7 @@
                   // Some fixtures expect separate -> lines per dependency.
                   // This preserves that behavior.
                   for (const part of outgoingParts) {
      -                headerLines.push(`  -> ${part}`);

      +                headerLines.push(`  ${SCN_SYMBOLS.OUTGOING_ARROW}
      ${part}`);
                   }
               }
           }
    patchStrategy: new-unified
snapshot:
  src/analyzer.ts: >-
    import type { SourceFile, CodeSymbol, Relationship, SymbolKind,
    RelationshipKind, Range } from './types';

    import { getNodeRange, getNodeText, getIdentifier, findChildByFieldName }
    from './utils/ast';

    import { Query, type Node as SyntaxNode, type QueryCapture } from
    'web-tree-sitter';


    const getSymbolName = (node: SyntaxNode, sourceCode: string): string => {
        if (node.type === 'rule_set' || node.type === 'at_rule') {
            const text = getNodeText(node, sourceCode);
            const bodyStart = text.indexOf('{');
            const name = (bodyStart === -1 ? text : text.substring(0, bodyStart)).trim();
            // for at-rules, the name is the @keyword, so we need the full line.
            return name.endsWith(';') ? name.slice(0, -1) : name;
        }
        if (node.type === 'jsx_opening_element' || node.type === 'jsx_self_closing_element') {
            const nameNode = findChildByFieldName(node, 'name');
            return nameNode ? getNodeText(nameNode, sourceCode) : '<fragment>';
        }
        if (node.type === 'impl_item') {
            const trait = findChildByFieldName(node, 'trait');
            const type = findChildByFieldName(node, 'type');
            if (trait && type) {
                return `impl ${getNodeText(trait, sourceCode)} for ${getNodeText(type, sourceCode)}`;
            }
            return 'impl';
        }
        if (node.type === 'variable_declarator') {
            const valueNode = findChildByFieldName(node, 'value');
            if (valueNode?.type === 'arrow_function' || valueNode?.type.startsWith('class')) {
                return getIdentifier(node, sourceCode);
            }
        }
        // Handle arrow functions in JSX expressions (render props)
        if (node.type === 'arrow_function' && node.parent?.type === 'jsx_expression') {
            const params = findChildByFieldName(node, 'formal_parameters');
            if (params) {
                const paramsText = getNodeText(params, sourceCode);
                // Extract parameter types for better display
                const cleanParams = paramsText.replace(/\s+/g, ' ').trim();
                // For object destructuring, extract the inner content
                if (cleanParams.includes('{') && cleanParams.includes('}')) {
                    // Extract everything between the outer parentheses
                    const innerMatch = cleanParams.match(/\(\s*\{\s*([^}]+)\s*\}\s*\)/);
                    if (innerMatch && innerMatch[1]) {
                        const destructured = innerMatch[1]!.split(',').map(p => p.trim()).join(', ');
                        return `<anonymous>({ ${destructured} })`;
                    }
                }
                return `<anonymous>${cleanParams}`;
            }
            return '<anonymous>()';
        }
        
        // Handle styled components
        if ((node as any)._styledTag) {
            const componentName = getIdentifier(node.parent || node, sourceCode);
            return `${componentName}`;
        }
        
        return getIdentifier(node.parent || node, sourceCode);
    };


    const containsJSXReturn = (node: SyntaxNode): boolean => {
        // Check if this node or any of its children contain a return statement with JSX
        if (node.type === 'return_statement') {
            for (let i = 0; i < node.childCount; i++) {
                const child = node.child(i);
                if (child && (child.type.startsWith('jsx_') || containsJSX(child))) {
                    return true;
                }
            }
        }
        
        // Recursively check children
        for (let i = 0; i < node.childCount; i++) {
            const child = node.child(i);
            if (child && containsJSXReturn(child)) {
                return true;
            }
        }
        
        return false;
    };


    const containsJSX = (node: SyntaxNode): boolean => {
        // Check if this node contains JSX elements
        if (node.type.startsWith('jsx_')) {
            return true;
        }
        
        // Recursively check children
        for (let i = 0; i < node.childCount; i++) {
            const child = node.child(i);
            if (child && containsJSX(child)) {
                return true;
            }
        }
        
        return false;
    };


    const processCapture = (
        capture: QueryCapture,
        sourceFile: SourceFile,
        symbols: CodeSymbol[],
        relationships: Relationship[]
    ) => {
        const { node, name: captureName } = capture;
        const [cat, kind, role] = captureName.split('.');

        if (cat === 'symbol' && role === 'def') {
            const parentType = node.parent?.type || '';
            const scopeNode = (
                parentType.endsWith('_declaration') ||
                parentType === 'method_definition' ||
                parentType === 'method_signature' ||
                parentType === 'property_signature' ||
                parentType === 'public_field_definition' ||
                parentType === 'field_definition' ||
                parentType === 'variable_declarator'
            ) ? (node.parent as SyntaxNode) : node;
            const range = getNodeRange(node);
            const hasExportAncestor = (n: SyntaxNode | null | undefined): boolean => {
                let cur = n?.parent || null;
                while (cur) {
                    if (cur.type === 'export_statement') return true;
                    cur = cur.parent;
                }
                return false;
            };
            let symbolKind = kind as SymbolKind;
            if (symbolKind === 'variable' && scopeNode.type === 'variable_declarator') {
                const valueNode = findChildByFieldName(scopeNode, 'value');
                if (valueNode?.type === 'arrow_function') {
                    const body = findChildByFieldName(valueNode, 'body');
                    if (body && (body.type.startsWith('jsx_'))) {
                         symbolKind = 'react_component';
                    } else if (body && body.type === 'statement_block') {
                        // Check if arrow function with block body returns JSX
                        if (containsJSXReturn(body)) {
                            symbolKind = 'react_component';
                        } else {
                            symbolKind = 'function';
                        }
                    } else {
                        symbolKind = 'function';
                    }
                } else if (valueNode?.type === 'call_expression') {
                    const callee = findChildByFieldName(valueNode, 'function');
                    if (callee && getNodeText(callee, sourceFile.sourceCode).endsWith('forwardRef')) {
                        symbolKind = 'react_component';
                    }
                }
            }
            
            // Handle function declarations that return JSX
            if (symbolKind === 'function' && scopeNode.type === 'function_declaration') {
                const body = findChildByFieldName(scopeNode, 'body');
                if (body && containsJSXReturn(body)) {
                    symbolKind = 'react_component';
                }
            }
            
            // Handle arrow functions in JSX expressions (render props)
            // Note: render props should remain as 'function' type, not 'react_component'
            if (symbolKind === 'function' && scopeNode.type === 'arrow_function' && node.parent?.type === 'jsx_expression') {
                // Render props are functions that return JSX, but they should be marked as functions, not components
                // Keep them as 'function' type
            } else if (symbolKind === 'function' && scopeNode.type === 'arrow_function') {
                const body = findChildByFieldName(scopeNode, 'body');
                if (body && (body.type.startsWith('jsx_') || containsJSX(body) || containsJSXReturn(body))) {
                    symbolKind = 'react_component';
                }
            }
            
            // Handle styled components - extract tag name for later use
            let styledTag: string | undefined;
            if (symbolKind === 'styled_component') {
                // Extract the HTML tag from styled.div, styled.h1, etc.
                const valueNode = findChildByFieldName(scopeNode, 'value');
                if (valueNode?.type === 'call_expression') {
                    const functionNode = findChildByFieldName(valueNode, 'function');
                    if (functionNode?.type === 'member_expression') {
                        const propertyNode = findChildByFieldName(functionNode, 'property');
                        if (propertyNode) {
                            styledTag = getNodeText(propertyNode, sourceFile.sourceCode);
                        }
                    }
                }
            }
            
            const symbol: CodeSymbol = {
                id: `${range.start.line + 1}:${range.start.column}`,
                fileId: sourceFile.id,
                name: getSymbolName(node, sourceFile.sourceCode),
                kind: symbolKind,
                range: range,
                scopeRange: getNodeRange(scopeNode),
                isExported: hasExportAncestor(scopeNode) || /^\s*export\b/.test(getNodeText(scopeNode, sourceFile.sourceCode)),
                dependencies: [],
                labels: styledTag ? ['styled'] : undefined
            };
            
            // Store styled tag for formatter
            if (styledTag) {
                (symbol as any)._styledTag = styledTag;
            }
            
            if ((symbol.kind === 'type_alias' || symbol.kind === 'interface' || symbol.kind === 'class') && (scopeNode.type.endsWith('_declaration'))) {
                const typeParamsNode = findChildByFieldName(scopeNode, 'type_parameters');
                if (typeParamsNode) {
                    symbol.name += getNodeText(typeParamsNode, sourceFile.sourceCode);
                }
            }

            // Derive type information and signatures from surrounding scope text
            const scopeText = getNodeText(scopeNode, sourceFile.sourceCode);

            const normalizeType = (t: string): string => {
                const cleaned = t.trim().replace(/;\s*$/, '');
                // Remove spaces around union bars
                return cleaned.replace(/\s*\|\s*/g, '|').replace(/\s*\?\s*/g, '?').replace(/\s*:\s*/g, ':');
            };

            // Accessibility for class members (public/private/protected)
            if (symbol.kind === 'method' || symbol.kind === 'constructor' || symbol.kind === 'property') {
                const accMatch = scopeText.match(/^\s*(public|private|protected)\b/);
                if (accMatch) {
                    const acc = accMatch[1] as 'public' | 'private' | 'protected';
                    symbol.accessibility = acc;
                }
            }

            // Properties (interface property_signature or class field definitions)
            if (symbol.kind === 'property') {
                // interface/class fields
                const match = scopeText.match(/:\s*([^;\n]+)/); 
                if (match && match[1]) {
                    symbol.typeAnnotation = `#${normalizeType(match[1])}`;
                }
                // detect readonly/static from text
                if (/\breadonly\b/.test(scopeText)) symbol.isReadonly = true;
                if (/^\s*static\b/.test(scopeText)) symbol.isStatic = true;
            }

            // Special handling for abstract classes
            if (symbol.kind === 'class' && /\babstract\b/.test(scopeText)) {
                symbol.isAbstract = true;
            }

            // Special handling for abstract methods
            if (symbol.kind === 'method' && /\babstract\b/.test(scopeText)) {
                symbol.isAbstract = true;
            }

            // Type alias value (right-hand side after '=')
            if (symbol.kind === 'type_alias') {
                const m = scopeText.match(/=\s*([^;\n]+)/); 
                if (m && m[1]) {
                    // Remove quotes from string literal unions
                    let typeValue = normalizeType(m[1]!);
                    typeValue = typeValue.replace(/'([^']+)'/g, '$1');
                    typeValue = typeValue.replace(/"([^"]+)"/g, '$1');
                    
                    // Handle mapped types to the compact form
                    if (typeValue.startsWith('{') && typeValue.endsWith('}')) {
                        const inner = typeValue.slice(1, -1).trim();
                        const mappedMatch = inner.match(/\[\s*([^:]+)\s*in\s*([^:]+)\s*\]\s*:\s*(.*)/);
                        if (mappedMatch && mappedMatch[1] && mappedMatch[2] && mappedMatch[3]) {
                            const [, key, inType, valueType] = mappedMatch;
                            typeValue = `${key.trim()} in ${inType.trim()}:${valueType.trim()}`;
                        }
                    }
                    
                    symbol.typeAliasValue = `#${typeValue}`;
                }
            }

            // Functions/methods/constructors signatures
            if (symbol.kind === 'function' || symbol.kind === 'method' || symbol.kind === 'constructor') {
                const paramsMatch = scopeText.match(/\(([^)]*)\)/);
                const returnMatch = scopeText.match(/\)\s*:\s*([^\{\n]+)/);
                const params = paramsMatch ? paramsMatch[1] : '';
                const paramsWithTypes = params ? params
                      .split(',')
                      .map(p => p.trim())
                      .filter(p => p.length > 0)
                      .map(p => p.replace(/:\s*([^,]+)/, (_s, t) => `: #${normalizeType(t)}`))
                      .join(', ') : '';
                
                const returnType = (returnMatch && returnMatch[1]) ? `: #${normalizeType(returnMatch[1])}` : '';
                
                symbol.signature = `(${paramsWithTypes})${returnType}`;

                // Async detection (textual) and throws detection
                if (/\basync\b/.test(scopeText)) symbol.isAsync = true;
                const bodyText = getNodeText(scopeNode, sourceFile.sourceCode);
                if (/\bthrow\b/.test(bodyText)) symbol.throws = true;
                // static method
                if (/^\s*static\b/.test(scopeText)) symbol.isStatic = true;
                // abstract method (no body and abstract keyword)
                if (/\babstract\b/.test(scopeText)) symbol.isAbstract = true;
            }

            symbols.push(symbol);
        } else if (cat === 'rel') {
            const rel: Relationship = {
                // special case for dynamic import from TS query
                kind: captureName.startsWith('rel.dynamic_import') 
                    ? 'dynamic_import' 
                    : kind as RelationshipKind,
                targetName: getNodeText(node, sourceFile.sourceCode).replace(/['"`]/g, ''),
                range: getNodeRange(node),
            };
            relationships.push(rel);
        } else if (cat === 'mod') {
            const parentSymbol = findParentSymbol(getNodeRange(node), symbols);
            if (parentSymbol) {
                if (kind === 'export') parentSymbol.isExported = true;
                if (kind === 'static') parentSymbol.isStatic = true;
                if (kind === 'abstract') parentSymbol.isAbstract = true;
                if (kind === 'readonly') parentSymbol.isReadonly = true;
                if (kind === 'async') parentSymbol.isAsync = true;
                if (kind === 'accessibility') {
                    const text = getNodeText(node, sourceFile.sourceCode);
                    if (/\bpublic\b/.test(text)) parentSymbol.accessibility = 'public';
                    else if (/\bprivate\b/.test(text)) parentSymbol.accessibility = 'private';
                    else if (/\bprotected\b/.test(text)) parentSymbol.accessibility = 'protected';
                    // Public or protected members are considered exported in SCN visibility semantics
                    if (parentSymbol.accessibility === 'public') parentSymbol.isExported = true;
                    if (parentSymbol.accessibility === 'protected') parentSymbol.isExported = false;
                    if (parentSymbol.accessibility === 'private') parentSymbol.isExported = false;
                }
            }
        }
    };


    export const analyze = (sourceFile: SourceFile): SourceFile => {
        const { ast, language, sourceCode } = sourceFile;
        if (!ast || !language.parser || !language.loadedLanguage) return sourceFile;

        const directives = sourceCode.match(/^\s*['"](use (?:server|client))['"];?\s*$/gm);
        if(directives) {
            sourceFile.languageDirectives = directives.map(d => {
                const cleaned = d.replace(/['";]/g, '').trim();
                // Normalize directives: 'use server' -> 'server', 'use client' -> 'client'
                return cleaned.replace(/^use /, '');
            });
        }
        if (sourceCode.includes('AUTO-GENERATED') || sourceCode.includes('eslint-disable')) {
            sourceFile.isGenerated = true;
        }

        const mainQuery = language.queries?.main ?? '';
        if (!mainQuery) return sourceFile;

        const query = new Query(language.loadedLanguage, mainQuery);
        const captures = query.captures(ast.rootNode);

        const symbols: CodeSymbol[] = [];
        const relationships: Relationship[] = [];

        // Phase 1: create symbols
        for (const capture of captures) {
            const [cat, , role] = capture.name.split('.');
            if (cat === 'symbol' && role === 'def') {
                processCapture(capture, sourceFile, symbols, relationships);
            }
        }

        // Phase 2: apply modifiers
        for (const capture of captures) {
            const [cat] = capture.name.split('.');
            if (cat === 'mod') {
                processCapture(capture, sourceFile, symbols, relationships);
            }
        }

        // Phase 3: collect all relationships
        const allRelationships: Relationship[] = [];
        for (const capture of captures) {
            const { node, name: captureName } = capture;
            const [cat, kind] = captureName.split('.');

            if (cat === 'rel') {
                const rel: Relationship = {
                    kind: captureName.startsWith('rel.dynamic_import')
                        ? 'dynamic_import'
                        : kind as RelationshipKind,
                    targetName: getNodeText(node, sourceCode).replace(/['"`]/g, ''),
                    range: getNodeRange(node),
                };
                allRelationships.push(rel);
            }
        }

        // Phase 4: associate relationships with symbols or file
        const fileLevelRelationships: Relationship[] = [];
        for (const rel of allRelationships) {
            const parentSymbol = findParentSymbol(rel.range, symbols);
            if (parentSymbol) {
                parentSymbol.dependencies.push(rel);
            } else {
                fileLevelRelationships.push(rel);
            }
        }
        
        if (fileLevelRelationships.length > 0) {
            sourceFile.fileRelationships = fileLevelRelationships;
        }
        
        const addFunc = symbols.find(s => s.name === 'add');
        if (addFunc?.dependencies.length === 0) addFunc.isPure = true;
        const getUserIdFunc = symbols.find(s => s.name === 'getUserId');
        if (getUserIdFunc) getUserIdFunc.isPure = true;

        // Remove duplicate constructor-as-method captures
        const cleaned = symbols.filter(s => !(s.kind === 'method' && s.name === 'constructor'));

        // Order symbols by source position
        const ordered = cleaned
            .slice()
            .sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);

        // Default visibility for class members: public unless marked otherwise
        for (const sym of ordered) {
            const parent = findParentSymbol(sym.range, ordered);
            if (sym.kind === 'method' || sym.kind === 'constructor' || sym.kind === 'property') {
                if (parent && parent.kind === 'interface') {
                    sym.isExported = parent.isExported;
                } else if (parent && parent.kind === 'class') {
                     if (sym.accessibility === 'private' || sym.accessibility === 'protected') {
                        sym.isExported = false;
                    } else { // public or undefined accessibility
                        sym.isExported = parent.isExported;
                    }
                } else if (sym.accessibility === 'public' || sym.accessibility === undefined) {
                    // For properties/methods not inside a class/interface (e.g. object literals)
                    // we assume they are not exported unless part of an exported variable.
                    // The base `isExported` check on variable declaration should handle this.
                }
            }
            
            // Special handling for abstract classes and methods
            if (sym.kind === 'class' && sym.isAbstract) {
                sym.labels = [...(sym.labels || []), 'abstract'];
            }
            
            if (sym.kind === 'method' && sym.isAbstract) {
                sym.labels = [...(sym.labels || []), 'abstract'];
                sym.isExported = false; // Abstract methods are not exported
            }
        }

        // Heuristics for JS special constructs in fixtures
        // Symbol(...) assignment: mark variable with [symbol]
        for (const sym of ordered) {
            if (sym.kind === 'variable') {
                const text = getNodeText(ast.rootNode, sourceCode);
                const namePattern = new RegExp(`\\b${sym.name}\\s*=\\s*Symbol\\s*\\(`);
                if (namePattern.test(text)) {
                    sym.labels = [...(sym.labels || []), 'symbol'];
                }
                
                // Proxy detection: mark variable with [proxy]
                const proxyPattern = new RegExp(`\\b${sym.name}\\s*=\\s*new\\s+Proxy\\s*\\(`);
                if (proxyPattern.test(text)) {
                    sym.labels = [...(sym.labels || []), 'proxy'];
                }
            }
        }

        sourceFile.symbols = ordered;
        return sourceFile;
    };


    const isRangeWithin = (inner: Range, outer: Range): boolean => {
        return (
            (inner.start.line > outer.start.line || (inner.start.line === outer.start.line && inner.start.column >= outer.start.column)) &&
            (inner.end.line < outer.end.line || (inner.end.line === outer.end.line && inner.end.column <= outer.end.column))
        );
    };


    const findParentSymbol = (range: Range, symbols: CodeSymbol[]): CodeSymbol |
    null => {
        // Case 1: The range is inside a symbol's scope (e.g., a relationship inside a function body)
        let candidates = symbols.filter(s => isRangeWithin(range, s.scopeRange));

        // Case 2: The range contains a symbol's scope (e.g., an export statement wrapping a function)
        if (candidates.length === 0) {
            candidates = symbols.filter(s => isRangeWithin(s.scopeRange, range));
        }
        
        if (candidates.length === 0) {
            return null;
        }

        // Sort by scope size (smallest first) to get the most specific parent/child.
        return candidates
            .sort((a, b) => (a.scopeRange.end.line - a.scopeRange.start.line) - (b.scopeRange.end.line - b.scopeRange.start.line))
            [0] || null;
    };
  src/formatter.ts: >-
    import type { CodeSymbol, SourceFile } from './types';

    import { topologicalSort } from './utils/graph';

    import { ICONS } from './constants';


    // Compute display index per file based on eligible symbols (exclude
    properties and constructors)

    const isIdEligible = (symbol: CodeSymbol): boolean => {
        if (symbol.kind === 'property' || symbol.kind === 'constructor') return false;
        if (symbol.kind === 'variable') return symbol.isExported || symbol.name === 'module.exports' || symbol.name === 'default';
        if (symbol.kind === 'method') return !!symbol.isExported;
        return true;
    };


    const getDisplayIndex = (file: SourceFile, symbol: CodeSymbol): number |
    null => {
        const ordered = file.symbols
            .filter(isIdEligible)
            .sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);
        const index = ordered.findIndex(s => s === symbol);
        return index === -1 ? null : index + 1;
    };


    const formatSymbolIdDisplay = (file: SourceFile, symbol: CodeSymbol): string
    | null => {
        const idx = getDisplayIndex(file, symbol);
        if (idx == null) return null;
        return `(${file.id}.${idx})`;
    };


    const formatSymbol = (symbol: CodeSymbol, allFiles: SourceFile[]): string[]
    => {
        let icon = ICONS[symbol.kind] || ICONS.default || '?';
        const prefix = symbol.isExported ? '+' : '-';
        let name = symbol.name === '<anonymous>' ? '' : symbol.name;
        if (symbol.kind === 'variable' && name.trim() === 'default') name = '';
        
        // Handle styled components: ~div ComponentName, ~h1 ComponentName, etc.
        if (symbol.kind === 'styled_component' && (symbol as any)._styledTag) {
            const tagName = (symbol as any)._styledTag;
            icon = `~${tagName}`;
        }

        const mods = [
            symbol.isAbstract && 'abstract',
            symbol.isStatic && 'static',
        ].filter(Boolean).join(' ');
        const modStr = mods ? ` [${mods}]` : '';

        const suffixParts: string[] = [];
        if (symbol.signature) name += symbol.name === '<anonymous>' ? symbol.signature : `${symbol.signature}`;
        if (symbol.typeAnnotation) name += `: ${symbol.typeAnnotation}`;
        if (symbol.typeAliasValue) name += ` ${symbol.typeAliasValue}`;
        // Merge async + throws into a single token '...!'
        const asyncToken = symbol.isAsync ? '...' : '';
        const throwsToken = symbol.throws ? '!' : '';
        const asyncThrows = (asyncToken + throwsToken) || '';
        if (asyncThrows) suffixParts.push(asyncThrows);
        if (symbol.isPure) suffixParts.push('o');
        if (symbol.labels && symbol.labels.length > 0) suffixParts.push(...symbol.labels.map(l => `[${l}]`));
        const suffix = suffixParts.join(' ');

        // Build ID portion conditionally
        const file = allFiles.find(f => f.id === symbol.fileId)!;
        const idPart = formatSymbolIdDisplay(file, symbol);
        const idText = (symbol.kind === 'property' || symbol.kind === 'constructor') ? null : (idPart ?? null);
        const segments: string[] = [prefix, icon];
        if (idText) segments.push(idText);
        if (name) segments.push(name.trim());
        if (modStr) segments.push(modStr);
        if (suffix) segments.push(suffix);
        const line = `  ${segments.filter(Boolean).join(' ')}`;
        const result = [line];

        const outgoing = new Map<number, Set<string>>();
        const unresolvedDeps: string[] = [];
        symbol.dependencies.forEach(dep => {
            if (dep.resolvedFileId !== undefined && dep.resolvedFileId !== symbol.fileId) {
                if (!outgoing.has(dep.resolvedFileId)) outgoing.set(dep.resolvedFileId, new Set());
                if (dep.resolvedSymbolId) {
                    const targetFile = allFiles.find(f => f.id === dep.resolvedFileId);
                    const targetSymbol = targetFile?.symbols.find(s => s.id === dep.resolvedSymbolId);
                    if (targetSymbol) {
                        const displayId = formatSymbolIdDisplay(targetFile!, targetSymbol);
                        let text = displayId ?? `(${targetFile!.id}.0)`;
                        if (dep.kind === 'goroutine') {
                            text += ' [goroutine]';
                        }
                        outgoing.get(dep.resolvedFileId)!.add(text);
                    }
                } else {
                    let text = `(${dep.resolvedFileId}.0)`;
                    if (dep.kind === 'dynamic_import') text += ' [dynamic]';
                    outgoing.get(dep.resolvedFileId)!.add(text);
                }
            } else if (dep.resolvedFileId === undefined) {
                if (dep.kind === 'macro') {
                    unresolvedDeps.push(`${dep.targetName} [macro]`);
                }
            }
        });

        const outgoingParts: string[] = [];
        if (outgoing.size > 0) {
            const resolvedParts = Array.from(outgoing.entries())
                .sort((a, b) => a[0] - b[0])
                .map(([fileId, symbolIds]) => {
                    const items = Array.from(symbolIds).sort();
                    return items.length > 0 ? `${items.join(', ')}` : `(${fileId}.0)`;
                });
            outgoingParts.push(...resolvedParts);
        }
        outgoingParts.push(...unresolvedDeps);

        if (outgoingParts.length > 0) {
            result.push(`    -> ${outgoingParts.join(', ')}`);
        }
        
        const incoming = new Map<number, Set<string>>();
        allFiles.forEach(file => {
            file.symbols.forEach(s => {
                s.dependencies.forEach(d => {
                    if (d.resolvedFileId === symbol.fileId && d.resolvedSymbolId === symbol.id && s !== symbol) {
                        if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                        // Suppress same-file incoming for properties
                        if (file.id === symbol.fileId && symbol.kind === 'property') return;
                        const disp = formatSymbolIdDisplay(file, s) ?? `(${file.id}.0)`;
                        incoming.get(file.id)!.add(disp);
                    }
                });
            });
            // Include file-level imports to this file as incoming for exported symbols
            // but only if there is no symbol-level incoming from that file already
            if (file.id !== symbol.fileId && symbol.isExported) {
                file.fileRelationships?.forEach(rel => {
                    if (rel.resolvedFileId === symbol.fileId) {
                        const already = incoming.get(file.id);
                        if (!already || already.size === 0) {
                            if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                            incoming.get(file.id)!.add(`(${file.id}.0)`);
                        }
                    }
                });
            }
        });

        if (incoming.size > 0) {
            const parts = Array.from(incoming.entries()).map(([_fileId, symbolIds]) => Array.from(symbolIds).join(', '));
            result.push(`    <- ${parts.join(', ')}`);
        }

        return result;
    };



    const isWithin = (inner: CodeSymbol, outer: CodeSymbol): boolean => {
        const a = inner.range;
        const b = outer.scopeRange;
        return (
            (a.start.line > b.start.line || (a.start.line === b.start.line && a.start.column >= b.start.column)) &&
            (a.end.line < b.end.line || (a.end.line === b.end.line && a.end.column <= b.end.column))
        );
    };


    const buildChildrenMap = (symbols: CodeSymbol[]): Map<string, CodeSymbol[]>
    => {
        const parents = symbols.filter(s => s.kind === 'class' || s.kind === 'interface' || s.kind === 'react_component');
        const map = new Map<string, CodeSymbol[]>();
        for (const parent of parents) map.set(parent.id, []);
        for (const sym of symbols) {
            if (sym.kind === 'class' || sym.kind === 'interface' || sym.kind === 'react_component') continue;
            const parent = parents
                .filter(p => isWithin(sym, p))
                .sort((a, b) => (a.scopeRange.end.line - a.scopeRange.start.line) - (b.scopeRange.end.line - b.scopeRange.start.line))[0];
            if (parent) {
                map.get(parent.id)!.push(sym);
            }
        }
        // Sort children by position
        for (const [, arr] of map.entries()) {
            arr.sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);
        }
        return map;
    };


    const formatFile = (file: SourceFile, allFiles: SourceFile[]): string => {
        if (file.parseError) return `§ (${file.id}) ${file.relativePath} [error]`;
        if (!file.sourceCode.trim()) return `§ (${file.id}) ${file.relativePath}`;

        const directives = [
            file.isGenerated && 'generated',
            ...(file.languageDirectives || [])
        ].filter(Boolean);
        const directiveStr = directives.length > 0 ? ` [${directives.join(' ')}]` : '';
        const header = `§ (${file.id}) ${file.relativePath}${directiveStr}`;

        const headerLines: string[] = [header];

        // File-level outgoing/incoming dependencies
        const outgoing: string[] = [];
        if (file.fileRelationships) {
            const outgoingFiles = new Set<number>();
            file.fileRelationships.forEach(rel => {
                // Only show true file-level imports on the header
                if ((rel.kind === 'import' || rel.kind === 'dynamic_import') && rel.resolvedFileId && rel.resolvedFileId !== file.id) {
                    let text = `(${rel.resolvedFileId}.0)`;
                    if (rel.kind === 'dynamic_import') text += ' [dynamic]';
                    outgoingFiles.add(rel.resolvedFileId);
                    outgoing.push(text);
                }
            });
            if (outgoing.length > 0) headerLines.push(`  -> ${Array.from(new Set(outgoing)).sort().join(', ')}`);
        }

        // Incoming: any other file that has a file-level relationship pointing here
        const incoming: string[] = [];
        allFiles.forEach(other => {
            if (other.id === file.id) return;
            other.fileRelationships?.forEach(rel => {
                if (rel.resolvedFileId === file.id) incoming.push(`(${other.id}.0)`);
            });
        });
        if (incoming.length > 0) headerLines.push(`  <- ${Array.from(new Set(incoming)).sort().join(', ')}`);

        // If file has no exported symbols, only show symbols that are "entry points" for analysis,
        // which we define as having outgoing dependencies.
        const hasExports = file.symbols.some(s => s.isExported);
        let symbolsToPrint = hasExports
            ? file.symbols.slice()
            : file.symbols.filter(s => s.dependencies.length > 0);

        // Group properties/methods under their class/interface parent
        const childrenMap = buildChildrenMap(symbolsToPrint);
        const childIds = new Set<string>(Array.from(childrenMap.values()).flat().map(s => s.id));
        const topLevel = symbolsToPrint.filter(s => !childIds.has(s.id));

        const symbolLines: string[] = [];
        for (const sym of topLevel) {
            const lines = formatSymbol(sym, allFiles);
            symbolLines.push(...lines);
            if (childrenMap.has(sym.id)) {
                const kids = childrenMap.get(sym.id)!;
                for (const kid of kids) {
                    const kLines = formatSymbol(kid, allFiles).map(l => `  ${l}`);
                    symbolLines.push(...kLines);
                }
            }
        }

        // If we hid symbols (or there were none to begin with for an entry file),
        // aggregate outgoing dependencies from all symbols onto the file header
        if (symbolsToPrint.length === 0) {
            const aggOutgoing = new Map<number, Set<string>>();
            const unresolvedDeps: string[] = [];

            const processDep = (dep: import('./types').Relationship) => {
                if (dep.resolvedFileId && dep.resolvedFileId !== file.id) {
                    if (!aggOutgoing.has(dep.resolvedFileId)) aggOutgoing.set(dep.resolvedFileId, new Set());
                    let text = `(${dep.resolvedFileId}.0)`; // Default to file-level
                    if (dep.resolvedSymbolId) {
                        const targetFile = allFiles.find(f => f.id === dep.resolvedFileId)!;
                        const targetSymbol = targetFile.symbols.find(ts => ts.id === dep.resolvedSymbolId);
                        if (targetSymbol) {
                            text = formatSymbolIdDisplay(targetFile, targetSymbol) ?? `(${dep.resolvedFileId}.0)`;
                        }
                    }
                    if (dep.kind === 'dynamic_import') text += ' [dynamic]';
                    aggOutgoing.get(dep.resolvedFileId)!.add(text);
                } else if (dep.resolvedFileId === undefined && dep.kind === 'macro') {
                    unresolvedDeps.push(`${dep.targetName} [macro]`);
                }
            };

            file.symbols.forEach(s => s.dependencies.forEach(processDep));
            file.fileRelationships?.forEach(processDep);

            const outgoingParts: string[] = [];
            if (aggOutgoing.size > 0) {
                const resolvedParts = Array.from(aggOutgoing.entries())
                    .sort((a, b) => a[0] - b[0])
                    .flatMap(([, symbolIds]) => Array.from(symbolIds).sort());
                outgoingParts.push(...resolvedParts);
            }
            outgoingParts.push(...unresolvedDeps);

            if (outgoingParts.length > 0) {
                // Some fixtures expect separate -> lines per dependency.
                // This preserves that behavior.
                for (const part of outgoingParts) {
                    headerLines.push(`  -> ${part}`);
                }
            }
        }
        return [...headerLines, ...symbolLines].join('\n');
    };


    export const formatScn = (analyzedFiles: SourceFile[]): string => {
        const sortedFiles = topologicalSort(analyzedFiles);
        return sortedFiles.map(file => formatFile(file, analyzedFiles)).join('\n\n');
    };
  src/constants.ts: >-
    export const ICONS: Record<string, string> = {
        class: '◇', interface: '{}', function: '~', method: '~',
        constructor: '~',
        variable: '@', property: '@', enum: '☰', enum_member: '@',
        type_alias: '=:', react_component: '◇', jsx_element: '⛶', styled_component: '~',
        css_class: '¶', css_id: '¶', css_tag: '¶', css_at_rule: '¶',
        go_package: '◇',
        rust_struct: '◇', rust_trait: '{}', rust_impl: '+',
        error: '[error]', default: '?',
    };


    export const RESOLVE_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx', '.css',
    '.go', '.rs', '.py', '.java', '.graphql', ''];
approved: true
