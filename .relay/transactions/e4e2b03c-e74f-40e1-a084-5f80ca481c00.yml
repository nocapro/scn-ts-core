uuid: e4e2b03c-e74f-40e1-a084-5f80ca481c00
projectId: scn-ts-core
createdAt: '2025-09-05T03:03:32.370Z'
linesAdded: 7
linesRemoved: 6
gitCommitMsg: 'refactor: establish package entrypoint for scn-ts-core'
promptSummary: >-
  Fix TypeScript error in scn-ts-web-demo by creating a proper package
  entrypoint for scn-ts-core and updating imports.
reasoning:
  - >-
    Alright, let's get this sorted. The TypeScript compiler is having a moment
    with those relative imports. It's a classic monorepo setup issue. Some tools
    can resolve `scn-ts-core` for types, but for actual code, it gets lost
    without a proper package entrypoint. The hint "scn-ts-core should has
    index.ts" is a dead giveaway.
  - >-
    I'll create an `index.ts` for `scn-ts-core` to serve as a clean entrypoint,
    point the `package.json` to it, and then switch all those gnarly relative
    imports in the web demo to proper package imports. That should make
    TypeScript, Vite, and everyone else happy.
  - '### Step 1: Create `index.ts` as the package entrypoint'
  - >-
    I'll add an `index.ts` file in `src/` that just re-exports everything from
    `main.ts`. This is the least disruptive way to create a formal entrypoint
    for the `scn-ts-core` package.
  - '### Step 2: Update `package.json` to use the new entrypoint'
  - >-
    Now I'll point the `module` field in the root `package.json` to our new
    `src/index.ts`. This tells Node, bundlers, and TypeScript where to look for
    the package's code.
  - '### Step 3: Fix imports in the web demo app'
  - >-
    With a proper package entrypoint, I can now replace those brittle relative
    imports in the demo app with clean package imports.
  - First, `Legend.tsx`, which was the file that was erroring out.
  - Next, `App.tsx`.
  - >-
    Finally, `worker.ts`. This one was also using relative paths for code and
    types from `scn-ts-core`.
  - >-
    That should do it. Now the web demo correctly imports from `scn-ts-core` as
    a package, which should resolve the TypeScript error.
operations:
  - type: write
    path: src/index.ts
    content: export * from './main';
    patchStrategy: replace
  - type: write
    path: package.json
    content: |-
      <<<<<<< SEARCH
        "module": "src/main.ts",
      =======
        "module": "src/index.ts",
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: packages/scn-ts-web-demo/src/components/Legend.tsx
    content: |-
      <<<<<<< SEARCH
      import { ICONS, SCN_SYMBOLS } from '../../../src/main';
      =======
      import { ICONS, SCN_SYMBOLS } from 'scn-ts-core';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: |-
      <<<<<<< SEARCH
      import { generateScn } from '../../../src/main';
      import type { SourceFile } from '../../../src/main';
      =======
      import { generateScn } from 'scn-ts-core';
      import type { SourceFile } from 'scn-ts-core';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: packages/scn-ts-web-demo/src/worker.ts
    content: >-
      <<<<<<< SEARCH

      import { initializeParser, analyzeProject, logger } from
      '../../../src/main';

      import type { FileContent, LogLevel, SourceFile } from
      '../../../src/main';

      =======

      import { initializeParser, analyzeProject, logger } from 'scn-ts-core';

      import type { FileContent, LogLevel, SourceFile } from 'scn-ts-core';

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  src/index.ts: null
  package.json: |
    {
      "name": "scn-ts-core",
      "module": "src/main.ts",
      "type": "module",
      "private": true,
      "devDependencies": {
        "@types/bun": "latest",
        "web-tree-sitter": "0.25.6"
      },
      "peerDependencies": {
        "typescript": "^5"
      }
    }
  packages/scn-ts-web-demo/src/components/Legend.tsx: >-
    import * as React from 'react';

    import { Button } from './ui/button';

    import { HelpCircle, X } from 'lucide-react';

    import { ICONS, SCN_SYMBOLS } from '../../../src/main';

    import { Card, CardContent, CardHeader, CardTitle } from './ui/card';

    import {
      Accordion,
      AccordionContent,
      AccordionItem,
      AccordionTrigger,
    } from "./ui/accordion"


    const symbolIcons = [
      { symbol: ICONS.class, description: 'Class or Component' },
      { symbol: ICONS.react_component, description: 'Class or Component' },
      { symbol: ICONS.interface, description: 'Interface or Trait' },
      { symbol: ICONS.rust_trait, description: 'Interface or Trait' },
      { symbol: ICONS.function, description: 'Function or Method' },
      { symbol: ICONS.method, description: 'Function or Method' },
      { symbol: ICONS.styled_component, description: 'Function or Method' },
      { symbol: ICONS.variable, description: 'Variable or Property' },
      { symbol: ICONS.property, description: 'Variable or Property' },
      { symbol: ICONS.enum, description: 'Enum' },
      { symbol: ICONS.type_alias, description: 'Type Alias' },
      { symbol: ICONS.jsx_element, description: 'JSX Element' },
      { symbol: ICONS.css_class, description: 'CSS Selector' },
    ];


    const legendSections = [
      {
        title: 'Prefixes',
        items: [
          { symbol: SCN_SYMBOLS.FILE_PREFIX, description: 'File path' },
          { symbol: SCN_SYMBOLS.EXPORTED_PREFIX, description: 'Exported symbol' },
          { symbol: SCN_SYMBOLS.PRIVATE_PREFIX, description: 'Private/unexported symbol' },
        ],
      },
      {
        title: 'Symbol Icons',
        items: Array.from(new Map(symbolIcons.map(item => [item.symbol, item])).values()),
      },
      {
        title: 'Relationships',
        items: [
          { symbol: SCN_SYMBOLS.OUTGOING_ARROW, description: 'Outgoing dependency' },
          { symbol: SCN_SYMBOLS.INCOMING_ARROW, description: 'Incoming dependency' },
        ],
      },
      {
        title: 'Modifiers & Tags',
        items: [
          { symbol: SCN_SYMBOLS.ASYNC, description: 'Async' },
          { symbol: SCN_SYMBOLS.THROWS, description: 'Throws error' },
          { symbol: SCN_SYMBOLS.PURE, description: 'Pure (no side-effects)' },
          { symbol: SCN_SYMBOLS.TAG_STYLED, description: 'Styled component' },
          { symbol: SCN_SYMBOLS.TAG_DYNAMIC, description: 'Dynamic import' },
          { symbol: SCN_SYMBOLS.TAG_GENERATED, description: 'Generated file' },
        ],
      },
    ];


    const LegendItem: React.FC<{ symbol: string; description: string }> = ({
    symbol, description }) => (
      <div className="grid grid-cols-[3rem_1fr] items-center gap-x-3 text-sm">
        <code className="font-mono text-base font-bold text-foreground/90 justify-self-center">{symbol}</code>
        <span className="text-muted-foreground">{description}</span>
      </div>
    );


    export const Legend: React.FC = () => {
      const [isOpen, setIsOpen] = React.useState(false);

      if (!isOpen) {
        return (
          <div className="absolute top-4 right-4 z-30">
            <Button
              variant="secondary"
              size="icon"
              onClick={() => setIsOpen(true)}
              title="Show Legend"
              className="rounded-full shadow-lg"
            >
              <HelpCircle className="h-5 w-5" />
            </Button>
          </div>
        );
      }

      return (
        <div className="absolute top-4 right-4 z-30">
          <Card className="w-80 max-h-[80vh] flex flex-col shadow-2xl bg-background/90 backdrop-blur-sm">
            <CardHeader className="flex flex-row items-center justify-between py-3 px-4 border-b">
              <CardTitle className="text-base">Legend</CardTitle>
              <Button variant="ghost" size="icon" className="h-7 w-7" onClick={() => setIsOpen(false)}>
                <X className="h-4 w-4" />
              </Button>
            </CardHeader>
            <CardContent className="p-0 overflow-y-auto">
              <Accordion type="multiple" defaultValue={legendSections.map(s => s.title)} className="w-full">
                {legendSections.map(({ title, items }) => (
                  <AccordionItem key={title} value={title}>
                    <AccordionTrigger className="px-4 py-2 text-sm hover:no-underline">{title}</AccordionTrigger>
                    <AccordionContent className="px-4 pb-3">
                      <div className="space-y-1.5">
                        {items.map(({ symbol, description }) =>
                          symbol && <LegendItem key={`${symbol}-${description}`} symbol={symbol} description={description} />
                        )}
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </CardContent>
          </Card>
        </div>
      );
    };
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback, useRef } from 'react';

    import { get_encoding, type Tiktoken } from 'tiktoken';

    import * as Comlink from 'comlink';

    import type { Remote } from 'comlink';

    import { generateScn } from '../../../src/main';

    import type { SourceFile } from '../../../src/main';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import OutputOptions from './components/OutputOptions';

    import { Legend } from './components/Legend';

    import { Play, Loader, Copy, Check, StopCircle } from 'lucide-react';

    import type { LogEntry, ProgressData, FormattingOptions } from './types';

    import type { WorkerApi } from './worker';

    import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from
    './components/ui/accordion';


    function App() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [sidebarWidth, setSidebarWidth] = useState(480);
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
      const [isCopied, setIsCopied] = useState(false);
      const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
        showOutgoing: true,
        showIncoming: true,
        showIcons: true,
        showExportedIndicator: true,
        showPrivateIndicator: true,
        showModifiers: true,
        showTags: true,
        showSymbolIds: true,
        groupMembers: true,
        displayFilters: {},
        showFilePrefix: true,
        showFileIds: true,
      });
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [encoder, setEncoder] = useState<Tiktoken | null>(null);
      const [analysisTime, setAnalysisTime] = useState<number | null>(null);
      const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });
      
      const isResizing = useRef(false);
      const workerRef = useRef<Remote<WorkerApi> | null>(null);

      useEffect(() => {
        // Initialize Tokenizer on main thread
        try {
          const enc = get_encoding("cl100k_base");
          setEncoder(enc);
        } catch (e) {
          console.error("Failed to initialize tokenizer:", e);
          setLogs(prev => [...prev, { level: 'error', message: 'Failed to initialize tokenizer.', timestamp: Date.now() }]);
        }

        // Comlink setup
        const worker = new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' });
        const wrappedWorker = Comlink.wrap<WorkerApi>(worker);
        workerRef.current = wrappedWorker;

        const initializeWorker = async () => {
          try {
            await wrappedWorker.init();
            setIsInitialized(true);
            setLogs(prev => [...prev, { level: 'info', message: 'Analysis worker ready.', timestamp: Date.now() }]);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            setLogs(prev => [...prev, { level: 'error', message: `Worker failed to initialize: ${message}`, timestamp: Date.now() }]);
          }
        };

        initializeWorker();

        return () => {
          wrappedWorker[Comlink.releaseProxy]();
          worker.terminate();
        };
      }, []);

      useEffect(() => {
        if (!encoder) return;
        try {
          const inputTokens = encoder.encode(filesInput).length;
          const outputTokens = encoder.encode(scnOutput).length;
          setTokenCounts({ input: inputTokens, output: outputTokens });
        } catch (e) {
          console.error("Tokenization error:", e);
          setTokenCounts({ input: 0, output: 0 });
        }
      }, [filesInput, scnOutput, encoder]);

      useEffect(() => {
        if (analysisResult) {
          setScnOutput(generateScn(analysisResult, formattingOptions));
        }
      }, [analysisResult, formattingOptions]);

      const handleCopy = useCallback(() => {
        if (scnOutput) {
          navigator.clipboard.writeText(scnOutput).then(
            () => {
              setIsCopied(true);
              setTimeout(() => setIsCopied(false), 2000);
            }
          );
        }
      }, [scnOutput]);

      const handleStop = useCallback(() => {
        if (isLoading && workerRef.current) {
          workerRef.current.cancel();
          // The error propagation and finally block in handleAnalyze will handle state updates.
        }
      }, [isLoading]);

      const handleMouseDown = useCallback((e: React.MouseEvent) => {
        e.preventDefault();
        isResizing.current = true;
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';

        const handleMouseMove = (event: MouseEvent) => {
          if (isResizing.current) {
            const newWidth = event.clientX;
            const minWidth = 320; // 20rem
            const maxWidth = window.innerWidth * 0.8;
            setSidebarWidth(Math.min(maxWidth, Math.max(minWidth, newWidth)));
          }
        };

        const handleMouseUp = () => {
          isResizing.current = false;
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('mouseup', handleMouseUp);
        };

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
      }, []);

      const handleAnalyze = useCallback(async () => {
        if (!isInitialized || !workerRef.current) {
          setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
          return;
        }
        
        if (isLoading) {
          return; // Prevent multiple concurrent analyses
        }
        
        setIsLoading(true);
        setScnOutput('');
        setAnalysisResult(null);
        setAnalysisTime(null);
        setProgress(null);
        setLogs([]);

        const onLog = (log: LogEntry) => {
          setLogs(prev => [...prev, log]);
        };

        try {
          const { result, analysisTime } = await workerRef.current.analyze(
            { filesInput, logLevel: 'debug' },
            Comlink.proxy(setProgress),
            Comlink.proxy(onLog)
          );
          setAnalysisResult(result);
          setAnalysisTime(analysisTime);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          if ((error as Error).name === 'AbortError') {
            setLogs(prev => [...prev, { level: 'warn', message: 'Analysis canceled by user.', timestamp: Date.now() }]);
          } else {
            setLogs(prev => [...prev, { level: 'error', message: `Analysis error: ${message}`, timestamp: Date.now() }]);
          }
        } finally {
          setIsLoading(false);
          setProgress(null);
        }
      }, [filesInput, isInitialized, isLoading]);

      return (
        <div className="h-screen w-screen flex bg-background text-foreground overflow-hidden">
          {/* Sidebar */}
          <aside style={{ width: `${sidebarWidth}px` }} className="max-w-[80%] min-w-[320px] flex-shrink-0 flex flex-col border-r">
            <div className="flex-shrink-0 flex items-center justify-between p-4 border-b bg-background relative z-20">
              <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
              <div className="flex items-center space-x-2">
                {isLoading ? (
                  <>
                    <Button disabled className="w-32 justify-center">
                      <Loader className="mr-2 h-4 w-4 animate-spin" />
                      <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                    </Button>
                    <Button onClick={handleStop} variant="outline" size="icon" title="Stop analysis">
                      <StopCircle className="h-4 w-4" />
                    </Button>
                  </>
                ) : (
                  <Button onClick={handleAnalyze} disabled={!isInitialized} className="w-32 justify-center">
                    <Play className="mr-2 h-4 w-4" />
                    <span>Analyze</span>
                  </Button>
                )}
              </div>
            </div>

            <div className="flex-grow overflow-y-auto">
              <Accordion type="multiple" defaultValue={['input', 'options', 'logs']} className="w-full">
                <AccordionItem value="input">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                    <div className="flex w-full justify-between items-center">
                      <span>Input Files (JSON)</span>
                      <span className="text-xs font-normal text-muted-foreground tabular-nums">
                        {tokenCounts.input.toLocaleString()} tokens
                      </span>
                    </div>
                  </AccordionTrigger>
                  <AccordionContent>
                    <div className="px-4 pb-4 h-96">
                      <Textarea
                        value={filesInput}
                        onChange={(e) => setFilesInput(e.currentTarget.value)}
                        className="h-full w-full font-mono text-xs resize-none"
                        placeholder="Paste an array of FileContent objects here..."
                      />
                    </div>
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="options">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Formatting Options</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="logs">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Logs</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <LogViewer logs={logs} />
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </div>
          </aside>

          {/* Resizer */}
          <div
            role="separator"
            onMouseDown={handleMouseDown}
            className="w-1.5 flex-shrink-0 cursor-col-resize hover:bg-primary/20 transition-colors duration-200"
          />

          {/* Main Content Area */}
          <main className="flex-grow flex flex-col overflow-hidden relative">
            <Legend />
            <div className="flex justify-between items-center p-4 border-b flex-shrink-0">
              <h2 className="text-lg font-semibold leading-none tracking-tight">Output (SCN)</h2>
              <div className="flex items-center gap-4">
                {analysisTime !== null && (
                  <span className="text-sm text-muted-foreground">
                    Analyzed in {(analysisTime / 1000).toFixed(2)}s
                  </span>
                )}
                <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                <Button variant="ghost" size="icon" onClick={handleCopy} disabled={!scnOutput} title="Copy to clipboard">
                  {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                </Button>
              </div>
            </div>
            <div className="p-4 flex-grow overflow-auto font-mono text-xs">
              <pre className="whitespace-pre-wrap">
                {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
              </pre>
            </div>
          </main>
        </div>
      );
    }


    export default App;
  packages/scn-ts-web-demo/src/worker.ts: >-
    import * as Comlink from 'comlink';

    import { initializeParser, analyzeProject, logger } from
    '../../../src/main';

    import type { FileContent, LogLevel, SourceFile } from '../../../src/main';

    import type { LogEntry, ProgressData } from './types';


    // Define the API the worker will expose

    const workerApi = {
      isInitialized: false,
      abortController: null as AbortController | null,

      async init() {
        if (this.isInitialized) return;
        await initializeParser({ wasmBaseUrl: '/wasm/' });
        this.isInitialized = true;
      },

      async analyze(
        { filesInput, logLevel }: { filesInput: string; logLevel: LogLevel },
        onProgress: (progress: ProgressData) => void,
        onLog: (log: LogEntry) => void
      ): Promise<{ result: SourceFile[], analysisTime: number }> {
        if (!this.isInitialized) {
          throw new Error('Worker not initialized.');
        }

        this.abortController = new AbortController();

        logger.setLogHandler((level, ...args) => {
          const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
          onLog({ level, message, timestamp: Date.now() });
        });
        logger.setLevel(logLevel);

        try {
          let files: FileContent[] = [];
          try {
            files = JSON.parse(filesInput);
            if (!Array.isArray(files)) throw new Error("Input is not an array.");
          } catch (error) {
            throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
          }

          const { sourceFiles: analysisResult, analysisTime } = await analyzeProject({
            files,
            onProgress,
            logLevel,
            signal: this.abortController.signal,
          });

          // Sanitize the result to make it structured-clonable.
          analysisResult.forEach(file => {
            delete file.ast;
            if (file.language) {
              // The language object on the source file is a reference to a global
              // singleton. We must clone it before deleting non-serializable properties,
              // otherwise the parser state is destroyed for subsequent analysis runs.
              const sanitizedLanguage = { ...file.language };
              delete sanitizedLanguage.parser;
              delete sanitizedLanguage.loadedLanguage;
              file.language = sanitizedLanguage;
            }
          });
          
          return { result: analysisResult, analysisTime };
        } finally {
          logger.setLogHandler(null);
          this.abortController = null;
        }
      },

      cancel() {
        this.abortController?.abort();
      },
    };


    Comlink.expose(workerApi);


    export type WorkerApi = typeof workerApi;
approved: true
