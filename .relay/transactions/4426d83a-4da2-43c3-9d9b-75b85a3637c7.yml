uuid: 4426d83a-4da2-43c3-9d9b-75b85a3637c7
projectId: scn-ts-core
createdAt: '2025-09-05T14:40:42.398Z'
linesAdded: 71
linesRemoved: 3
gitCommitMsg: 'feat(core): add API to calculate token impact of formatting options'
promptSummary: >-
  Implement a feature to show the token cost/impact of toggling various
  formatting options in the SCN-TS web demo. This is the first of three phases,
  focusing on adding the core logic to the `scn-ts-core` library.
reasoning:
  - >-
    Alright, let's get this token impact feature plumbed into the core library.
    This is a neat idea; seeing the token cost of formatting options is super
    useful for prompt engineering. Phase one will be all about getting the heavy
    lifting done in `scn-ts-core`. I'll add a new API to calculate the token
    impact of each option. It's gonna be a bit brute-forcey—recalculating the
    SCN for each option toggle—but for this use case, correctness beats
    premature optimization, especially since we can offload it to a web worker
    later.
  - Here are the core changes for phase 1.
  - '### Phase 1: Core Logic Implementation'
  - >-
    First, I'll define the type for the token impact data. This will live in
    `src/types.ts`.
  - >-
    Next, I'll add the main logic in `src/main.ts`. This new function,
    `calculateTokenImpact`, will take the analyzed files and base formatting
    options, then iterate through each option to calculate the token delta. I'll
    also update the type exports here.
  - >-
    Finally, I'll expose the new function and type from the package's entry
    point, `src/index.ts`.
  - >-
    That's it for phase one. The core library is now equipped to calculate token
    impacts. Next phases will wire this up to the web demo.
operations:
  - type: write
    path: src/types.ts
    content: >-
      --- src/types.ts

      +++ src/types.ts

      @@ -29,6 +29,17 @@
           showFilePrefix?: boolean; // § prefix, defaults to true
           showFileIds?: boolean;    // (1) file identifiers in headers and references, defaults to true
       }
      +

      +/**

      + * Represents the token cost of toggling each formatting option.

      + * The value is the delta when an option is toggled from its state in the
      `baseOptions`.

      + * e.g. `new_token_count - base_token_count`.

      + */

      +export interface FormattingOptionsTokenImpact {

      +    options: Partial<{ [K in keyof Omit<FormattingOptions,
      'displayFilters'>]: number }>;

      +    displayFilters: Partial<Record<string, number>>;

      +}
       
       /**
        * Represents a file to be processed.
    patchStrategy: new-unified
  - type: write
    path: src/main.ts
    content: >-
      --- src/main.ts

      +++ src/main.ts

      @@ -1,10 +1,11 @@
       import { getLanguageForFile } from './languages';
       import { initializeParser as init, parse } from './parser';
      -import type { ParserInitOptions, SourceFile, InputFile, ScnTsConfig,
      AnalyzeProjectOptions, FormattingOptions } from './types';

      +import type { ParserInitOptions, SourceFile, InputFile, ScnTsConfig,
      AnalyzeProjectOptions, FormattingOptions, FormattingOptionsTokenImpact,
      SymbolKind } from './types';
       import { analyze } from './analyzer';
       import { formatScn } from './formatter';
       import path from './utils/path';
       import { getPathResolver } from './utils/tsconfig';
       import { resolveGraph } from './graph-resolver';
       import { logger } from './logger';
       import { initializeTokenizer as initTokenizer, countTokens as countTokensInternal } from './tokenizer';
      @@ -15,13 +16,13 @@
       export const initializeParser = (options: ParserInitOptions): Promise<void> => init(options);
       
       /**
      - * Initializes the tokenizer. Call this for consistency, although
      `countTokens` will auto-initialize.

      + * Initializes the tokenizer. Call this for consistency, although
      `countTokens` will auto-initialize on first use.
        * It's a synchronous and lightweight operation.
        */
       export const initializeTokenizer = (): boolean => initTokenizer();
       
       // Types for web demo
      -export type { ParserInitOptions, SourceFile, LogLevel, InputFile,
      TsConfig, ScnTsConfig, AnalyzeProjectOptions, LogHandler,
      FormattingOptions, CodeSymbol, SymbolKind } from './types';

      +export type { ParserInitOptions, SourceFile, LogLevel, InputFile,
      TsConfig, ScnTsConfig, AnalyzeProjectOptions, LogHandler,
      FormattingOptions, FormattingOptionsTokenImpact, CodeSymbol, SymbolKind }
      from './types';
       export type FileContent = InputFile;
       
       // Exports for web demo. The constants are exported from index.ts directly.
      @@ -35,6 +36,58 @@
        */
       export const generateScn = (analyzedFiles: SourceFile[], options?: FormattingOptions): string => {
           return formatScn(analyzedFiles, options);
      +};

      +

      +/**

      + * Calculates the token impact of toggling each formatting option.

      + * This can be slow as it re-generates the SCN for each option.

      + * @param analyzedFiles The result from `analyzeProject`.

      + * @param baseOptions The formatting options to calculate deltas from.

      + * @returns An object detailing the token change for toggling each
      option.

      + */

      +export const calculateTokenImpact = (

      +    analyzedFiles: SourceFile[],

      +    baseOptions: FormattingOptions

      +): FormattingOptionsTokenImpact => {

      +    logger.debug('Calculating token impact...');

      +    const startTime = performance.now();

      +

      +    const baseScn = formatScn(analyzedFiles, baseOptions);

      +    const baseTokens = countTokensInternal(baseScn);

      +

      +    const impact: FormattingOptionsTokenImpact = {

      +        options: {},

      +        displayFilters: {},

      +    };

      +

      +    const simpleOptionKeys: Array<keyof Omit<FormattingOptions,
      'displayFilters'>> = [

      +        'showOutgoing', 'showIncoming', 'showIcons',
      'showExportedIndicator',

      +        'showPrivateIndicator', 'showModifiers', 'showTags',
      'showSymbolIds',

      +        'groupMembers', 'showFilePrefix', 'showFileIds'

      +    ];

      +

      +    for (const key of simpleOptionKeys) {

      +        // All boolean options default to true.

      +        const currentValue = baseOptions[key] ?? true;

      +        const newOptions = { ...baseOptions, [key]: !currentValue };

      +        const newScn = formatScn(analyzedFiles, newOptions);

      +        const newTokens = countTokensInternal(newScn);

      +        impact.options[key] = newTokens - baseTokens;

      +    }

      +

      +    const allSymbolKinds = new Set<SymbolKind>(analyzedFiles.flatMap(file
      => file.symbols.map(s => s.kind)));

      +

      +    for (const kind of allSymbolKinds) {

      +        const currentFilterValue = baseOptions.displayFilters?.[kind] ??
      true;

      +        const newOptions = {

      +            ...baseOptions,

      +            displayFilters: { ...(baseOptions.displayFilters ?? {}),
      [kind]: !currentFilterValue }

      +        };

      +        const newScn = formatScn(analyzedFiles, newOptions);

      +        const newTokens = countTokensInternal(newScn);

      +        impact.displayFilters[kind] = newTokens - baseTokens;

      +    }

      +

      +    const duration = performance.now() - startTime;

      +    logger.debug(`Token impact calculation finished in
      ${duration.toFixed(2)}ms`);

      +

      +    return impact;
       };
       
       /**
        * Legacy API: Generate SCN from config (for backward compatibility)
    patchStrategy: new-unified
  - type: write
    path: src/index.ts
    content: |-
      --- src/index.ts
      +++ src/index.ts
      @@ -2,6 +2,7 @@
           initializeParser,
           generateScn,
           generateScnFromConfig,
      +    calculateTokenImpact,
           analyzeProject,
           logger,
           initializeTokenizer,
      @@ -17,6 +18,7 @@
           ScnTsConfig,
           AnalyzeProjectOptions,
           LogHandler,
           FormattingOptions,
      +    FormattingOptionsTokenImpact,
           FileContent,
           CodeSymbol,
           SymbolKind
    patchStrategy: new-unified
snapshot:
  src/types.ts: >-
    import type { Parser, Tree, Language } from 'web-tree-sitter';

    import type { PathResolver } from './utils/tsconfig';

    export type { PathResolver };


    export type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'silent';


    export type LogHandler = (level: Exclude<LogLevel, 'silent'>, ...args:
    any[]) => void;


    export interface TsConfig {
        compilerOptions?: {
            baseUrl?: string;
            paths?: Record<string, string[]>;
        };
    }


    export interface AnalyzeProjectOptions {
        files: InputFile[];
        tsconfig?: TsConfig;
        root?: string;
        onProgress?: (progress: { percentage: number; message: string }) => void;
        logLevel?: LogLevel;
        signal?: AbortSignal;
    }


    /**
     * Options to control the SCN output format.
     */
    export interface FormattingOptions {
        showOutgoing?: boolean;
        showIncoming?: boolean;
        showIcons?: boolean;
        showExportedIndicator?: boolean; // + prefix
        showPrivateIndicator?: boolean; // - prefix
        showModifiers?: boolean; // ..., !, o
        showTags?: boolean;      // [generated], [styled], etc.
        showSymbolIds?: boolean; // (1.2) identifiers
        groupMembers?: boolean;  // group class/interface members under parent
        displayFilters?: Partial<Record<SymbolKind, boolean>>;
        showFilePrefix?: boolean; // § prefix, defaults to true
        showFileIds?: boolean;    // (1) file identifiers in headers and references, defaults to true
    }


    /**
     * Represents a file to be processed.
     */
    export interface InputFile {
      path: string; // relative path from root
      content: string;
    }


    /**
     * Configuration for the SCN generation process.
     */
    export interface ScnTsConfig {
      files: InputFile[];
      tsconfig?: TsConfig;
      formattingOptions?: FormattingOptions;
      root?: string; // Optional: A virtual root path for resolution. Defaults to '/'.
      _test_id?: string; // Special property for test runner to identify fixtures
    }


    /**
     * Options for initializing the Tree-sitter parser.
     */
    export interface ParserInitOptions {
        wasmBaseUrl: string;
    }


    /**
     * Represents a supported programming language and its configuration.
     */
    export type SymbolKind =
      // TS/JS
      | 'class' | 'interface' | 'function' | 'method' | 'constructor'
      | 'variable' | 'property' | 'enum' | 'enum_member' | 'type_alias' | 'module'
      | 'decorator' | 'parameter' | 'type_parameter' | 'import_specifier' | 're_export'
      // React
      | 'react_component' | 'react_hook' | 'react_hoc' | 'jsx_attribute' | 'jsx_element' | 'styled_component'
      // CSS
      | 'css_class' | 'css_id' | 'css_tag' | 'css_at_rule' | 'css_property' | 'css_variable'
      // Generic / Meta
      | 'file' | 'reference' | 'comment' | 'error' | 'unresolved'
      // Other Languages
      | 'go_package' | 'go_struct' | 'go_goroutine' | 'rust_struct' | 'rust_trait' | 'rust_impl' | 'rust_macro'
      | 'java_package' | 'python_class'
      | 'unknown';

    export interface Position {
      line: number;
      column: number;
    }


    export interface Range {
      start: Position;
      end: Position;
    }


    export interface CodeSymbol {
      id: string;
      fileId: number;
      name: string;
      kind: SymbolKind;
      range: Range;
      // Modifiers and metadata
      isExported: boolean;
      isAbstract?: boolean;
      isStatic?: boolean;
      isReadonly?: boolean;
      isAsync?: boolean;
      isPure?: boolean; // for 'o'
      throws?: boolean; // for '!'
      labels?: string[]; // extra display labels like [symbol], [proxy]
      isGenerated?: boolean;
      languageDirectives?: string[]; // e.g. 'use server'
      superClass?: string;
      implementedInterfaces?: string[];
      scopeRange: Range; // The range of the entire scope (e.g., function body) for relationship association
      accessibility?: 'public' | 'private' | 'protected';
      // Type information and signatures
      signature?: string; // e.g., (a: #number, b: #number): #number
      typeAnnotation?: string; // e.g., #string for properties/variables
      typeAliasValue?: string; // e.g., #number|string for type aliases
      // Relationships
      dependencies: Relationship[];
    }


    export type RelationshipKind =
      | 'import'
      | 'dynamic_import'
      | 'reference'
      | 'tagged'
      | 'export'
      | 'call'
      | 'extends'
      | 'implements'
      | 'references'
      | 'aliased'
      | 'goroutine'
      | 'macro';

    export interface Relationship {
      targetName: string; // The raw name of the target (e.g., './utils', 'MyClass', 'add', 'Button')
      kind: RelationshipKind;
      range: Range;
      // Resolved info
      resolvedFileId?: number;
      resolvedSymbolId?: string;
    }


    export interface SourceFile {
      id: number;
      relativePath: string;
      absolutePath: string;
      language: LanguageConfig;
      sourceCode: string;
      ast?: Tree;
      symbols: CodeSymbol[];
      parseError: boolean;
      isGenerated?: boolean;
      languageDirectives?: string[];
      // File-level relationships (e.g., imports not tied to a specific symbol)
      fileRelationships?: Relationship[];
    }


    /**
     * Represents a supported programming language and its configuration.
     */
    export interface LanguageConfig {
        id: string;
        name: string;
        extensions: string[];
        wasmPath: string;
        parser?: Parser;
        loadedLanguage?: Language;
        queries?: Record<string, string>;
    }


    export interface AnalysisContext {
        sourceFiles: SourceFile[];
        pathResolver: PathResolver;
    }
  src/main.ts: >-
    import { getLanguageForFile } from './languages';

    import { initializeParser as init, parse } from './parser';

    import type { ParserInitOptions, SourceFile, InputFile, ScnTsConfig,
    AnalyzeProjectOptions, FormattingOptions } from './types';

    import { analyze } from './analyzer';

    import { formatScn } from './formatter';

    import path from './utils/path';

    import { getPathResolver } from './utils/tsconfig';

    import { resolveGraph } from './graph-resolver';

    import { logger } from './logger';

    import { initializeTokenizer as initTokenizer, countTokens as
    countTokensInternal } from './tokenizer';


    /**
     * Public API to initialize the parser. Must be called before any other APIs.
     */
    export const initializeParser = (options: ParserInitOptions): Promise<void>
    => init(options);


    /**
     * Initializes the tokenizer. Call this for consistency, although `countTokens` will auto-initialize.
     * It's a synchronous and lightweight operation.
     */
    export const initializeTokenizer = (): boolean => initTokenizer();


    // Types for web demo

    export type { ParserInitOptions, SourceFile, LogLevel, InputFile, TsConfig,
    ScnTsConfig, AnalyzeProjectOptions, LogHandler, FormattingOptions,
    CodeSymbol, SymbolKind } from './types';

    export type FileContent = InputFile;


    // Exports for web demo. The constants are exported from index.ts directly.

    export { logger };


    /**
     * Counts tokens in a string using the cl100k_base model.
     */
    export const countTokens = (text: string): number =>
    countTokensInternal(text);


    /**
     * Generate SCN from analyzed source files
     */
    export const generateScn = (analyzedFiles: SourceFile[], options?:
    FormattingOptions): string => {
        return formatScn(analyzedFiles, options);
    };


    /**
     * Legacy API: Generate SCN from config (for backward compatibility)
     */
    export const generateScnFromConfig = async (config: ScnTsConfig):
    Promise<string> => {
        const { sourceFiles: analyzedFiles } = await analyzeProject({
            files: config.files,
            tsconfig: config.tsconfig,
            root: config.root,
        });
        return formatScn(analyzedFiles, config.formattingOptions);
    };


    /**
     * Parses and analyzes a project's files to build a dependency graph.
     */
    export const analyzeProject = async (
        {
            files,
            tsconfig,
            root = '/',
            onProgress,
            logLevel,
            signal,
        }: AnalyzeProjectOptions
    ): Promise<{ sourceFiles: SourceFile[], analysisTime: number }> => {
        const startTime = performance.now();
        if (logLevel) {
            logger.setLevel(logLevel);
        }
        logger.info(`Starting analysis of ${files.length} files...`);
        const pathResolver = getPathResolver(tsconfig);

        const checkAborted = () => { if (signal?.aborted) throw new DOMException('Aborted', 'AbortError'); };
        let fileIdCounter = 1;

        onProgress?.({ percentage: 0, message: 'Creating source files...' });

        // Step 1: Create SourceFile objects for all files
        const sourceFiles = files.map((file) => {
            checkAborted();
            const absolutePath = path.join(root, file.path);
            const sourceFile: SourceFile = {
                id: fileIdCounter++,
                relativePath: file.path,
                absolutePath,
                sourceCode: file.content,
                language: getLanguageForFile(file.path)!,
                symbols: [],
                parseError: false,
            };
            return sourceFile;
        });

        logger.debug(`Created ${sourceFiles.length} SourceFile objects.`);
        onProgress?.({ percentage: 10, message: `Parsing ${sourceFiles.length} files...` });

        // Step 2: Parse all files
        const parsedFiles = sourceFiles.map((file, i) => {
            checkAborted();
            if (!file.language || !file.language.wasmPath || file.sourceCode.trim() === '') {
                return file;
            }
            logger.debug(`Parsing ${file.relativePath}`);
            const tree = parse(file.sourceCode, file.language);
            if (!tree) {
                file.parseError = true;
                logger.warn(`Failed to parse ${file.relativePath}`);
            } else {
                file.ast = tree;
            }
            const percentage = 10 + (40 * (i + 1) / sourceFiles.length);
            onProgress?.({ percentage, message: `Parsing ${file.relativePath}` });
            return file;
        });

        onProgress?.({ percentage: 50, message: 'Analyzing files...' });
        logger.info(`Parsing complete. Analyzing symbols and relationships...`);

        // Step 3: Analyze all parsed files
        const analyzedFiles = parsedFiles.map((file, i) => {
            checkAborted();
            if (file.ast) {
                logger.debug(`Analyzing ${file.relativePath}`);
                const analyzed = analyze(file);
                const percentage = 50 + (40 * (i + 1) / sourceFiles.length);
                onProgress?.({ percentage, message: `Analyzing ${file.relativePath}` });
                return analyzed;
            }
            return file;
        });
        
        onProgress?.({ percentage: 90, message: 'Resolving dependency graph...' });
        logger.info('Analysis complete. Resolving dependency graph...');

        // Step 4: Resolve the dependency graph across all files
        checkAborted();
        const resolvedGraph = resolveGraph(analyzedFiles, pathResolver, root);
        
        onProgress?.({ percentage: 100, message: 'Analysis complete.' });
        logger.info('Graph resolution complete. Project analysis finished.');
        const analysisTime = performance.now() - startTime;
        return { sourceFiles: resolvedGraph, analysisTime };
    };
  src/index.ts: |-
    export {
        initializeParser,
        generateScn,
        generateScnFromConfig,
        analyzeProject,
        logger,
        initializeTokenizer,
        countTokens,
    } from './main';

    export { ICONS, SCN_SYMBOLS } from './constants';

    export type {
        ParserInitOptions,
        SourceFile,
        LogLevel,
        InputFile,
        TsConfig,
        ScnTsConfig,
        AnalyzeProjectOptions,
        LogHandler,
        FormattingOptions,
        FileContent,
        CodeSymbol,
        SymbolKind
    } from './main';
approved: true
