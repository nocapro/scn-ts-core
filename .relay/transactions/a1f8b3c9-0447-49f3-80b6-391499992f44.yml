uuid: a1f8b3c9-0447-49f3-80b6-391499992f44
projectId: scn-ts-core
createdAt: '2025-09-05T02:14:05.909Z'
linesAdded: 19
linesRemoved: 19
gitCommitMsg: 'fix(web-demo): refactor worker cancellation to avoid AbortSignal cloning error'
promptSummary: >-
  User encountered a DataCloneError when passing an AbortSignal to the web
  worker. This change refactors the cancellation logic to be managed inside the
  worker to avoid the cloning issue.
reasoning:
  - >-
    Ah, my apologies. You're right, that `DataCloneError` is a dealbreaker.
    Passing `AbortSignal` directly to a worker can be problematic, as the
    browser's structured cloning algorithm doesn't support it in all cases. My
    previous attempt was too naive.
  - >-
    Let's fix this properly. I'll refactor the worker communication to avoid
    passing the signal across the boundary. Instead, the worker will create its
    own `AbortController` for each analysis run, and we'll expose a simple
    `cancel()` method that the main thread can call. This is much more robust
    and avoids the cloning issue entirely.
  - Here are the changes to implement this cancellation strategy.
  - >-
    First, I'll update the worker to manage its own `AbortController` and expose
    a `cancel` method.
  - >-
    Now, let's update the `App` component to use this new worker API. It no
    longer needs to manage an `AbortController`.
  - >-
    This should resolve the cloning error and make the cancellation logic much
    more stable.
operations:
  - type: write
    path: packages/scn-ts-web-demo/src/worker.ts
    content: |-
      <<<<<<< SEARCH
      import * as Comlink from 'comlink';
      import { initializeParser, analyzeProject, logger } from '../../../index';
      import type { FileContent, LogLevel, SourceFile } from '../../../index';
      import type { LogEntry, ProgressData } from './types';

      // Define the API the worker will expose
      const workerApi = {
        isInitialized: false,

        async init() {
          if (this.isInitialized) return;
          await initializeParser({ wasmBaseUrl: '/wasm/' });
          this.isInitialized = true;
        },

        async analyze(
          { filesInput, logLevel }: { filesInput: string; logLevel: LogLevel },
          onProgress: (progress: ProgressData) => void,
          onLog: (log: LogEntry) => void,
          signal: AbortSignal
        ): Promise<SourceFile[]> {
          if (!this.isInitialized) {
            throw new Error('Worker not initialized.');
          }

          logger.setLogHandler((level, ...args) => {
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
            onLog({ level, message, timestamp: Date.now() });
          });
          logger.setLevel(logLevel);

          try {
            let files: FileContent[] = [];
            try {
              files = JSON.parse(filesInput);
              if (!Array.isArray(files)) throw new Error("Input is not an array.");
            } catch (error) {
              throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
            }

            const analysisResult = await analyzeProject({
              files,
              onProgress,
              logLevel,
              signal,
            });

            // Sanitize the result to make it structured-clonable.
            analysisResult.forEach(file => {
              delete file.ast;
              if (file.language) {
                delete file.language.parser;
                delete file.language.loadedLanguage;
              }
            });
            
            return analysisResult;
          } finally {
            logger.setLogHandler(null);
          }
        },
      };

      Comlink.expose(workerApi);

      export type WorkerApi = typeof workerApi;
      =======
      import * as Comlink from 'comlink';
      import { initializeParser, analyzeProject, logger } from '../../../index';
      import type { FileContent, LogLevel, SourceFile } from '../../../index';
      import type { LogEntry, ProgressData } from './types';

      // Define the API the worker will expose
      const workerApi = {
        isInitialized: false,
        abortController: null as AbortController | null,

        async init() {
          if (this.isInitialized) return;
          await initializeParser({ wasmBaseUrl: '/wasm/' });
          this.isInitialized = true;
        },

        async analyze(
          { filesInput, logLevel }: { filesInput: string; logLevel: LogLevel },
          onProgress: (progress: ProgressData) => void,
          onLog: (log: LogEntry) => void
        ): Promise<SourceFile[]> {
          if (!this.isInitialized) {
            throw new Error('Worker not initialized.');
          }

          this.abortController = new AbortController();

          logger.setLogHandler((level, ...args) => {
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
            onLog({ level, message, timestamp: Date.now() });
          });
          logger.setLevel(logLevel);

          try {
            let files: FileContent[] = [];
            try {
              files = JSON.parse(filesInput);
              if (!Array.isArray(files)) throw new Error("Input is not an array.");
            } catch (error) {
              throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
            }

            const analysisResult = await analyzeProject({
              files,
              onProgress,
              logLevel,
              signal: this.abortController.signal,
            });

            // Sanitize the result to make it structured-clonable.
            analysisResult.forEach(file => {
              delete file.ast;
              if (file.language) {
                delete file.language.parser;
                delete file.language.loadedLanguage;
              }
            });
            
            return analysisResult;
          } finally {
            logger.setLogHandler(null);
            this.abortController = null;
          }
        },

        cancel() {
          this.abortController?.abort();
        },
      };

      Comlink.expose(workerApi);

      export type WorkerApi = typeof workerApi;
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: |-
      <<<<<<< SEARCH
        const workerRef = useRef<Remote<WorkerApi> | null>(null);
        const abortControllerRef = useRef<AbortController | null>(null);
      =======
        const workerRef = useRef<Remote<WorkerApi> | null>(null);
      >>>>>>> REPLACE
      <<<<<<< SEARCH
        const handleStop = useCallback(() => {
          if (abortControllerRef.current) {
            abortControllerRef.current.abort();
            abortControllerRef.current = null;
            setIsLoading(false);
            setProgress(null);
            setLogs(prev => [...prev, { level: 'warn', message: 'Analysis canceled by user.', timestamp: Date.now() }]);
          }
        }, []);
      =======
        const handleStop = useCallback(() => {
          if (isLoading && workerRef.current) {
            workerRef.current.cancel();
            // The error propagation and finally block in handleAnalyze will handle state updates.
          }
        }, [isLoading]);
      >>>>>>> REPLACE
      <<<<<<< SEARCH
        const handleAnalyze = useCallback(async () => {
          if (!isInitialized || !workerRef.current) {
            setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
            return;
          }
          
          if (isLoading) {
            return; // Prevent multiple concurrent analyses
          }
          
          setIsLoading(true);
          setScnOutput('');
          setAnalysisResult(null);
          setProgress(null);
          setLogs([]);

          abortControllerRef.current = new AbortController();
          const { signal } = abortControllerRef.current;

          const onLog = (log: LogEntry) => {
            setLogs(prev => [...prev, log]);
          };

          try {
            const result = await workerRef.current.analyze(
              { filesInput, logLevel: 'debug' },
              Comlink.proxy(setProgress),
              Comlink.proxy(onLog),
              signal,
            );
            setAnalysisResult(result);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            // Don't show error if it was a user cancellation
            if ((error as Error).name !== 'AbortError') {
              setLogs(prev => [...prev, { level: 'error', message: `Analysis error: ${message}`, timestamp: Date.now() }]);
            }
          } finally {
            setIsLoading(false);
            abortControllerRef.current = null;
          }
        }, [filesInput, isInitialized, isLoading]);
      =======
        const handleAnalyze = useCallback(async () => {
          if (!isInitialized || !workerRef.current) {
            setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
            return;
          }
          
          if (isLoading) {
            return; // Prevent multiple concurrent analyses
          }
          
          setIsLoading(true);
          setScnOutput('');
          setAnalysisResult(null);
          setProgress(null);
          setLogs([]);

          const onLog = (log: LogEntry) => {
            setLogs(prev => [...prev, log]);
          };

          try {
            const result = await workerRef.current.analyze(
              { filesInput, logLevel: 'debug' },
              Comlink.proxy(setProgress),
              Comlink.proxy(onLog)
            );
            setAnalysisResult(result);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            if ((error as Error).name === 'AbortError') {
              setLogs(prev => [...prev, { level: 'warn', message: 'Analysis canceled by user.', timestamp: Date.now() }]);
            } else {
              setLogs(prev => [...prev, { level: 'error', message: `Analysis error: ${message}`, timestamp: Date.now() }]);
            }
          } finally {
            setIsLoading(false);
            setProgress(null);
          }
        }, [filesInput, isInitialized, isLoading]);
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  packages/scn-ts-web-demo/src/worker.ts: |-
    import * as Comlink from 'comlink';
    import { initializeParser, analyzeProject, logger } from '../../../index';
    import type { FileContent, LogLevel, SourceFile } from '../../../index';
    import type { LogEntry, ProgressData } from './types';

    // Define the API the worker will expose
    const workerApi = {
      isInitialized: false,

      async init() {
        if (this.isInitialized) return;
        await initializeParser({ wasmBaseUrl: '/wasm/' });
        this.isInitialized = true;
      },

      async analyze(
        { filesInput, logLevel }: { filesInput: string; logLevel: LogLevel },
        onProgress: (progress: ProgressData) => void,
        onLog: (log: LogEntry) => void,
        signal: AbortSignal
      ): Promise<SourceFile[]> {
        if (!this.isInitialized) {
          throw new Error('Worker not initialized.');
        }

        logger.setLogHandler((level, ...args) => {
          const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
          onLog({ level, message, timestamp: Date.now() });
        });
        logger.setLevel(logLevel);

        try {
          let files: FileContent[] = [];
          try {
            files = JSON.parse(filesInput);
            if (!Array.isArray(files)) throw new Error("Input is not an array.");
          } catch (error) {
            throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
          }

          const analysisResult = await analyzeProject({
            files,
            onProgress,
            logLevel,
            signal,
          });

          // Sanitize the result to make it structured-clonable.
          analysisResult.forEach(file => {
            delete file.ast;
            if (file.language) {
              delete file.language.parser;
              delete file.language.loadedLanguage;
            }
          });
          
          return analysisResult;
        } finally {
          logger.setLogHandler(null);
        }
      },
    };

    Comlink.expose(workerApi);

    export type WorkerApi = typeof workerApi;
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback, useRef } from 'react';

    import { get_encoding, type Tiktoken } from 'tiktoken';

    import * as Comlink from 'comlink';

    import type { Remote } from 'comlink';

    import { generateScn } from '../../../index';

    import type { SourceFile } from '../../../index';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import OutputOptions from './components/OutputOptions';

    import { Play, Loader, Copy, Check, StopCircle } from 'lucide-react';

    import type { LogEntry, ProgressData, FormattingOptions } from './types';

    import type { WorkerApi } from './worker';

    import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from
    './components/ui/accordion';


    function App() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
      const [isCopied, setIsCopied] = useState(false);
      const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
        showOutgoing: true,
        showIncoming: true,
        showIcons: true,
        showExportedIndicator: true,
        showPrivateIndicator: true,
        showModifiers: true,
        showTags: true,
        showSymbolIds: true,
        groupMembers: true,
        displayFilters: {},
        showFilePrefix: true,
        showFileIds: true,
      });
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [encoder, setEncoder] = useState<Tiktoken | null>(null);
      const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });
      
      const workerRef = useRef<Remote<WorkerApi> | null>(null);
      const abortControllerRef = useRef<AbortController | null>(null);

      useEffect(() => {
        // Initialize Tokenizer on main thread
        try {
          const enc = get_encoding("cl100k_base");
          setEncoder(enc);
        } catch (e) {
          console.error("Failed to initialize tokenizer:", e);
          setLogs(prev => [...prev, { level: 'error', message: 'Failed to initialize tokenizer.', timestamp: Date.now() }]);
        }

        // Comlink setup
        const worker = new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' });
        const wrappedWorker = Comlink.wrap<WorkerApi>(worker);
        workerRef.current = wrappedWorker;

        const initializeWorker = async () => {
          try {
            await wrappedWorker.init();
            setIsInitialized(true);
            setLogs(prev => [...prev, { level: 'info', message: 'Analysis worker ready.', timestamp: Date.now() }]);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            setLogs(prev => [...prev, { level: 'error', message: `Worker failed to initialize: ${message}`, timestamp: Date.now() }]);
          }
        };

        initializeWorker();

        return () => {
          wrappedWorker[Comlink.releaseProxy]();
          worker.terminate();
        };
      }, []);

      useEffect(() => {
        if (!encoder) return;
        try {
          const inputTokens = encoder.encode(filesInput).length;
          const outputTokens = encoder.encode(scnOutput).length;
          setTokenCounts({ input: inputTokens, output: outputTokens });
        } catch (e) {
          console.error("Tokenization error:", e);
          setTokenCounts({ input: 0, output: 0 });
        }
      }, [filesInput, scnOutput, encoder]);

      useEffect(() => {
        if (analysisResult) {
          setScnOutput(generateScn(analysisResult, formattingOptions));
        }
      }, [analysisResult, formattingOptions]);

      const handleCopy = useCallback(() => {
        if (scnOutput) {
          navigator.clipboard.writeText(scnOutput).then(
            () => {
              setIsCopied(true);
              setTimeout(() => setIsCopied(false), 2000);
            }
          );
        }
      }, [scnOutput]);

      const handleStop = useCallback(() => {
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
          abortControllerRef.current = null;
          setIsLoading(false);
          setProgress(null);
          setLogs(prev => [...prev, { level: 'warn', message: 'Analysis canceled by user.', timestamp: Date.now() }]);
        }
      }, []);

      const handleAnalyze = useCallback(async () => {
        if (!isInitialized || !workerRef.current) {
          setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
          return;
        }
        
        if (isLoading) {
          return; // Prevent multiple concurrent analyses
        }
        
        setIsLoading(true);
        setScnOutput('');
        setAnalysisResult(null);
        setProgress(null);
        setLogs([]);

        abortControllerRef.current = new AbortController();
        const { signal } = abortControllerRef.current;

        const onLog = (log: LogEntry) => {
          setLogs(prev => [...prev, log]);
        };

        try {
          const result = await workerRef.current.analyze(
            { filesInput, logLevel: 'debug' },
            Comlink.proxy(setProgress),
            Comlink.proxy(onLog),
            signal,
          );
          setAnalysisResult(result);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          // Don't show error if it was a user cancellation
          if ((error as Error).name !== 'AbortError') {
            setLogs(prev => [...prev, { level: 'error', message: `Analysis error: ${message}`, timestamp: Date.now() }]);
          }
        } finally {
          setIsLoading(false);
          abortControllerRef.current = null;
        }
      }, [filesInput, isInitialized, isLoading]);

      return (
        <div className="h-screen w-screen flex bg-background text-foreground">
          {/* Sidebar */}
          <aside className="w-[30rem] max-w-[40%] flex-shrink-0 flex flex-col border-r">
            <div className="flex-shrink-0 flex items-center justify-between p-4 border-b">
              <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
              <div className="flex items-center space-x-2">
                {isLoading ? (
                  <>
                    <Button disabled className="w-32 justify-center">
                      <Loader className="mr-2 h-4 w-4 animate-spin" />
                      <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                    </Button>
                    <Button onClick={handleStop} variant="outline" size="icon" title="Stop analysis">
                      <StopCircle className="h-4 w-4" />
                    </Button>
                  </>
                ) : (
                  <Button onClick={handleAnalyze} disabled={!isInitialized} className="w-32 justify-center">
                    <Play className="mr-2 h-4 w-4" />
                    <span>Analyze</span>
                  </Button>
                )}
              </div>
            </div>

            <div className="flex-grow overflow-y-auto">
              <Accordion type="multiple" defaultValue={['input', 'options', 'logs']} className="w-full">
                <AccordionItem value="input">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                    <div className="flex w-full justify-between items-center">
                      <span>Input Files (JSON)</span>
                      <span className="text-xs font-normal text-muted-foreground tabular-nums">
                        {tokenCounts.input.toLocaleString()} tokens
                      </span>
                    </div>
                  </AccordionTrigger>
                  <AccordionContent>
                    <div className="px-4 pb-4 h-96">
                      <Textarea
                        value={filesInput}
                        onChange={(e) => setFilesInput(e.currentTarget.value)}
                        className="h-full w-full font-mono text-xs resize-none"
                        placeholder="Paste an array of FileContent objects here..."
                      />
                    </div>
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="options">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Formatting Options</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="logs" className="border-b-0">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Logs</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <div className="h-96">
                      <LogViewer logs={logs} />
                    </div>
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </div>
          </aside>

          {/* Main Content Area */}
          <main className="flex-grow flex flex-col overflow-hidden">
            <div className="flex justify-between items-center p-4 border-b flex-shrink-0">
              <h2 className="text-lg font-semibold leading-none tracking-tight">Output (SCN)</h2>
              <div className="flex items-center gap-4">
                <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                <Button variant="ghost" size="icon" onClick={handleCopy} disabled={!scnOutput} title="Copy to clipboard">
                  {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                </Button>
              </div>
            </div>
            <div className="p-4 flex-grow overflow-auto font-mono text-xs">
              <pre className="whitespace-pre-wrap">
                {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
              </pre>
            </div>
          </main>
        </div>
      );
    }


    export default App;
approved: true
