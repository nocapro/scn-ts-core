uuid: 1ec3f135-21d3-4690-955c-a521469e354a
projectId: scn-ts-core
createdAt: '2025-09-05T01:20:03.770Z'
linesAdded: 31
linesRemoved: 12
gitCommitMsg: 'fix(web-demo): improve state management and logging for stability'
promptSummary: >-
  User reports instability, inconsistent results, and incomplete logs in the web
  demo. The issues point to race conditions and UI performance problems.
reasoning:
  - >-
    you're right to call that out. a flaky demo is worse than no demo. the
    issues you're seeing—inconsistent results and incomplete logs—scream "race
    condition" and "ui performance bottleneck". my previous fixes were patches;
    this needs a proper fix to the state management logic.
  - 'i''m going to make three key changes to stabilize the app:'
  - >-
    1.  **Log Batching**: Instead of trying to render every single log message
    the moment it arrives, which can choke React, i'll batch them and render
    them in chunks. this will fix the "missing logs" issue (which is really a
    "can't render fast enough" issue) and make the UI much smoother.
  - >-
    2.  **Robust State Resets**: i'll ensure that stopping or restarting an
    analysis *aggressively* clears all previous results and state. this will
    prevent data from one run from bleeding into the next, which is likely the
    cause of the inconsistent results.
  - >-
    3.  **Smarter "Analyze" Button**: if you click "Analyze" while a run is in
    progress, it will now act as a "cancel and restart," giving you predictable
    behavior instead of queueing up another run that could lead to confusing
    state.
  - here's the patch for `App.tsx`.
  - >-
    this should make the demo feel solid and reliable. thanks for pushing on
    this.
  - '---'
operations:
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: >-
      --- packages/scn-ts-web-demo/src/App.tsx

      +++ packages/scn-ts-web-demo/src/App.tsx

      @@ -1,5 +1,5 @@

      -import { useState, useEffect, useCallback, useRef, useMemo } from
      'react';

      +import { useState, useEffect, useCallback, useRef } from 'react';
       import { get_encoding, type Tiktoken } from 'tiktoken';
       import { generateScn } from '../../../index';
       import type { SourceFile } from '../../../index';
      @@ -23,8 +23,10 @@
         const [logs, setLogs] = useState<LogEntry[]>([]);
         const [encoder, setEncoder] = useState<Tiktoken | null>(null);
         const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });
      +  
         const workerRef = useRef<Worker | null>(null);
         const [workerKey, setWorkerKey] = useState(0);
      +  const logQueue = useRef<LogEntry[]>([]);
       
         useEffect(() => {
           // Initialize Tokenizer on main thread
      @@ -38,13 +40,24 @@
           // Initialize Web Worker
           workerRef.current = new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' });
       
      +    const flushLogQueue = () => {

      +      if (logQueue.current.length > 0) {

      +        setLogs(prev => [...prev, ...logQueue.current]);

      +        logQueue.current = [];

      +      }

      +    };

      +
           const handleWorkerMessage = (event: MessageEvent<WorkerResponse>) => {
             const { type, payload } = event.data;
             switch(type) {
               case 'init_success':
                 setIsInitialized(true);
      -          setLogs(prev => [...prev, { level: 'info', message: 'Analysis
      worker initialized.', timestamp: Date.now() }]);

      +          // Don't use log queue here, as it might not be flushed if no
      other logs arrive.

      +          setLogs(prev => [...prev, { level: 'info', message: 'Analysis
      worker ready.', timestamp: Date.now() }]);
                 break;
               case 'init_error':
                 setLogs(prev => [...prev, { level: 'error', message: `Worker failed to initialize: ${payload.message}`, timestamp: Date.now() }]);
                 break;
               case 'log':
      -          setLogs(prev => [...prev, payload]);

      +          logQueue.current.push(payload);

      +          // Batch log updates to avoid excessive re-renders

      +          setTimeout(flushLogQueue, 50);
                 break;
               case 'progress':
                 setProgress(payload);
      @@ -52,9 +65,11 @@
               case 'result':
                 setAnalysisResult(payload.analysisResult);
                 setIsLoading(false);
      +          flushLogQueue(); // Flush any remaining logs
                 break;
               case 'error':
                 setLogs(prev => [...prev, { level: 'error', message: `Analysis error: ${payload.message}`, timestamp: Date.now() }]);
                 setIsLoading(false);
      +          flushLogQueue(); // Flush any remaining logs
                 break;
             }
           };
      @@ -73,15 +88,10 @@
           }
         }, [filesInput, scnOutput, encoder]);
       
      -  const scnString = useMemo(() => {

      +  useEffect(() => {
           if (analysisResult) {
      -      return generateScn(analysisResult, formattingOptions);

      +      setScnOutput(generateScn(analysisResult, formattingOptions));
           }
      -    return '';
         }, [analysisResult, formattingOptions]);
      -

      -  useEffect(() => {

      -    setScnOutput(scnString);

      -  }, [scnString]);
       
         const handleCopy = useCallback(() => {
           if (scnOutput) {
      @@ -95,29 +105,40 @@
         }, [scnOutput]);
       
         const handleStop = useCallback(() => {
      +    if (!isLoading) return;
           // This triggers the useEffect cleanup to terminate the old worker
           // and create a new one, ensuring a clean state.
           setWorkerKey(k => k + 1);
           setIsLoading(false);
           setProgress(null);
      +    setAnalysisResult(null);

      +    setScnOutput('');
           setLogs(prev => [...prev, { level: 'warn', message: 'Analysis canceled by user.', timestamp: Date.now() }]);
      -  }, []);

      +    logQueue.current = [];

      +  }, [isLoading]);
       
         const handleAnalyze = useCallback(() => {
           if (!isInitialized) {
             setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
             return;
           }
       
      +    if (isLoading) {

      +      // Effectively a "cancel and restart" if clicked while running

      +      handleStop();

      +    }

      +
           setIsLoading(true);
           setScnOutput('');
           setAnalysisResult(null);
           setProgress(null);
           setLogs([]);
      +    logQueue.current = [];
       
           workerRef.current?.postMessage({
             type: 'analyze',
             payload: { filesInput, logLevel: 'debug' },
           } as WorkerRequest);
      -  }, [filesInput, isInitialized]);

      +  }, [filesInput, isInitialized, isLoading, handleStop]);
       
         return (
           <div className="h-screen w-screen flex bg-background text-foreground">
    patchStrategy: new-unified
snapshot:
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback, useRef, useMemo } from 'react';

    import { get_encoding, type Tiktoken } from 'tiktoken';

    import { generateScn } from '../../../index';

    import type { SourceFile } from '../../../index';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import OutputOptions from './components/OutputOptions';

    import { Play, Loader, Copy, Check, StopCircle } from 'lucide-react';

    import type { LogEntry, ProgressData, FormattingOptions } from './types';

    import type { WorkerRequest, WorkerResponse } from './worker';

    import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from
    './components/ui/accordion';


    function App() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
      const [isCopied, setIsCopied] = useState(false);
      const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
        showOutgoing: true,
        showIncoming: true,
        showIcons: true,
        showExportedIndicator: true,
        showPrivateIndicator: true,
        showModifiers: true,
        showTags: true,
        showSymbolIds: true,
        groupMembers: true,
        displayFilters: {},
        showFilePrefix: true,
        showFileIds: true,
      });
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [encoder, setEncoder] = useState<Tiktoken | null>(null);
      const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });
      const workerRef = useRef<Worker | null>(null);
      const [workerKey, setWorkerKey] = useState(0);

      useEffect(() => {
        // Initialize Tokenizer on main thread
        try {
          const enc = get_encoding("cl100k_base");
          setEncoder(enc);
        } catch (e) {
          console.error("Failed to initialize tokenizer:", e);
          setLogs(prev => [...prev, { level: 'error', message: 'Failed to initialize tokenizer.', timestamp: Date.now() }]);
        }

        // Initialize Web Worker
        workerRef.current = new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' });

        const handleWorkerMessage = (event: MessageEvent<WorkerResponse>) => {
          const { type, payload } = event.data;
          switch(type) {
            case 'init_success':
              setIsInitialized(true);
              setLogs(prev => [...prev, { level: 'info', message: 'Analysis worker initialized.', timestamp: Date.now() }]);
              break;
            case 'init_error':
              setLogs(prev => [...prev, { level: 'error', message: `Worker failed to initialize: ${payload.message}`, timestamp: Date.now() }]);
              break;
            case 'log':
              setLogs(prev => [...prev, payload]);
              break;
            case 'progress':
              setProgress(payload);
              break;
            case 'result':
              setAnalysisResult(payload.analysisResult);
              setIsLoading(false);
              break;
            case 'error':
              setLogs(prev => [...prev, { level: 'error', message: `Analysis error: ${payload.message}`, timestamp: Date.now() }]);
              setIsLoading(false);
              break;
          }
        };

        workerRef.current.onmessage = handleWorkerMessage;

        return () => {
          workerRef.current?.terminate();
        };
      }, [workerKey]);

      useEffect(() => {
        if (!encoder) return;
        try {
          const inputTokens = encoder.encode(filesInput).length;
          const outputTokens = encoder.encode(scnOutput).length;
          setTokenCounts({ input: inputTokens, output: outputTokens });
        } catch (e) {
          console.error("Tokenization error:", e);
          setTokenCounts({ input: 0, output: 0 });
        }
      }, [filesInput, scnOutput, encoder]);

      const scnString = useMemo(() => {
        if (analysisResult) {
          return generateScn(analysisResult, formattingOptions);
        }
        return '';
      }, [analysisResult, formattingOptions]);

      useEffect(() => {
        setScnOutput(scnString);
      }, [scnString]);

      const handleCopy = useCallback(() => {
        if (scnOutput) {
          navigator.clipboard.writeText(scnOutput).then(
            () => {
              setIsCopied(true);
              setTimeout(() => setIsCopied(false), 2000);
            }
          );
        }
      }, [scnOutput]);

      const handleStop = useCallback(() => {
        // This triggers the useEffect cleanup to terminate the old worker
        // and create a new one, ensuring a clean state.
        setWorkerKey(k => k + 1);
        setIsLoading(false);
        setProgress(null);
        setLogs(prev => [...prev, { level: 'warn', message: 'Analysis canceled by user.', timestamp: Date.now() }]);
      }, []);

      const handleAnalyze = useCallback(() => {
        if (!isInitialized) {
          setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
          return;
        }

        setIsLoading(true);
        setScnOutput('');
        setAnalysisResult(null);
        setProgress(null);
        setLogs([]);

        workerRef.current?.postMessage({
          type: 'analyze',
          payload: { filesInput, logLevel: 'debug' },
        } as WorkerRequest);
      }, [filesInput, isInitialized]);

      return (
        <div className="h-screen w-screen flex bg-background text-foreground">
          {/* Sidebar */}
          <aside className="w-[30rem] max-w-[40%] flex-shrink-0 flex flex-col border-r">
            <div className="flex-shrink-0 flex items-center justify-between p-4 border-b">
              <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
              <div className="flex items-center space-x-2">
                {isLoading ? (
                  <>
                    <Button disabled className="w-32 justify-center">
                      <Loader className="mr-2 h-4 w-4 animate-spin" />
                      <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                    </Button>
                    <Button onClick={handleStop} variant="outline" size="icon" title="Stop analysis">
                      <StopCircle className="h-4 w-4" />
                    </Button>
                  </>
                ) : (
                  <Button onClick={handleAnalyze} disabled={!isInitialized} className="w-32 justify-center">
                    <Play className="mr-2 h-4 w-4" />
                    <span>Analyze</span>
                  </Button>
                )}
              </div>
            </div>

            <div className="flex-grow overflow-y-auto">
              <Accordion type="multiple" defaultValue={['input', 'options', 'logs']} className="w-full">
                <AccordionItem value="input">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                    <div className="flex w-full justify-between items-center">
                      <span>Input Files (JSON)</span>
                      <span className="text-xs font-normal text-muted-foreground tabular-nums">
                        {tokenCounts.input.toLocaleString()} tokens
                      </span>
                    </div>
                  </AccordionTrigger>
                  <AccordionContent>
                    <div className="px-4 pb-4 h-96">
                      <Textarea
                        value={filesInput}
                        onChange={(e) => setFilesInput(e.currentTarget.value)}
                        className="h-full w-full font-mono text-xs resize-none"
                        placeholder="Paste an array of FileContent objects here..."
                      />
                    </div>
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="options">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Formatting Options</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="logs" className="border-b-0">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Logs</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <div className="h-96">
                      <LogViewer logs={logs} />
                    </div>
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </div>
          </aside>

          {/* Main Content Area */}
          <main className="flex-grow flex flex-col overflow-hidden">
            <div className="flex justify-between items-center p-4 border-b flex-shrink-0">
              <h2 className="text-lg font-semibold leading-none tracking-tight">Output (SCN)</h2>
              <div className="flex items-center gap-4">
                <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                <Button variant="ghost" size="icon" onClick={handleCopy} disabled={!scnOutput} title="Copy to clipboard">
                  {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                </Button>
              </div>
            </div>
            <div className="p-4 flex-grow overflow-auto font-mono text-xs">
              <pre className="whitespace-pre-wrap">
                {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
              </pre>
            </div>
          </main>
        </div>
      );
    }


    export default App;
approved: true
