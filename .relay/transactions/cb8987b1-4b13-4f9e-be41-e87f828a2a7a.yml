uuid: cb8987b1-4b13-4f9e-be41-e87f828a2a7a
projectId: scn-ts-core
createdAt: '2025-09-05T04:12:56.464Z'
linesAdded: 57
linesRemoved: 49
gitCommitMsg: 'refactor: Radically DRY up web-demo components and logic'
promptSummary: >-
  Make the codebase radically DRY without regression. For less code, less
  redundancy
reasoning:
  - >-
    Yo, what's up, HN. anton here. Got a request to make the codebase "radically
    DRY". You know how it is, less code, less problems. I went through the
    `scn-ts-web-demo` and found some sweet spots for refactoring without
    breaking things. No over-engineering, just clean, logical improvements.
    Let's get this PR merged.
  - '### Step 1: DRY up the Legend component'
  - >-
    First, `Legend.tsx`. That `symbolIcons` array was a bit wet with all those
    repeated description strings. I grouped 'em up by description. It's way
    cleaner now and easier to manage if you need to add more icons.
  - '### Step 2: Refactor OutputOptions to be data-driven'
  - >-
    Next, `OutputOptions.tsx` had a bunch of hardcoded `filter:thing` strings in
    its tree structure. That's a classic DRY violation. I pulled out the symbol
    kinds into arrays and now we build the tree from that data. Much more
    maintainable.
  - '### Step 3: Clean up state management in App.tsx'
  - >-
    In `App.tsx`, the `handleAnalyze` function was resetting a bunch of state
    variables one by one. I bundled that logic into a `resetAnalysisState`
    function. It's a small change, but it makes the main analysis handler
    cleaner and its intent clearer.
  - '### Step 4: Encapsulate logic in the worker'
  - >-
    Finally, the web worker (`worker.ts`) had some logic to sanitize the
    analysis result before sending it back to the main thread. This kind of data
    transformation is perfect for its own function. I extracted it into
    `sanitizeAnalysisResult`. Good encapsulation, better readability.
  - >-
    That's it. Four files, four solid improvements. Code is cleaner, more
    maintainable, and most importantly, DRYer. Peace.
operations:
  - type: write
    path: packages/scn-ts-web-demo/src/components/Legend.tsx
    content: >-
      --- packages/scn-ts-web-demo/src/components/Legend.tsx

      +++ packages/scn-ts-web-demo/src/components/Legend.tsx

      @@ -10,21 +10,21 @@
         AccordionTrigger,
       } from "./ui/accordion"
       
      -const symbolIcons = [

      -  { symbol: ICONS.class, description: 'Class or Component' },

      -  { symbol: ICONS.react_component, description: 'Class or Component' },

      -  { symbol: ICONS.interface, description: 'Interface or Trait' },

      -  { symbol: ICONS.rust_trait, description: 'Interface or Trait' },

      -  { symbol: ICONS.function, description: 'Function or Method' },

      -  { symbol: ICONS.method, description: 'Function or Method' },

      -  { symbol: ICONS.styled_component, description: 'Function or Method' },

      -  { symbol: ICONS.variable, description: 'Variable or Property' },

      -  { symbol: ICONS.property, description: 'Variable or Property' },

      -  { symbol: ICONS.enum, description: 'Enum' },

      -  { symbol: ICONS.type_alias, description: 'Type Alias' },

      -  { symbol: ICONS.jsx_element, description: 'JSX Element' },

      -  { symbol: ICONS.css_class, description: 'CSS Selector' },

      -];

      +const symbolIconGroups: Record<string, (keyof typeof ICONS)[]> = {

      +  'Class or Component': ['class', 'react_component'],

      +  'Interface or Trait': ['interface', 'rust_trait'],

      +  'Function or Method': ['function', 'method', 'styled_component'],

      +  'Variable or Property': ['variable', 'property'],

      +  Enum: ['enum'],

      +  'Type Alias': ['type_alias'],

      +  'JSX Element': ['jsx_element'],

      +  'CSS Selector': ['css_class'],

      +};

      +

      +const symbolIcons =
      Object.entries(symbolIconGroups).flatMap(([description, iconKeys]) =>

      +  iconKeys.map(key => ({ symbol: ICONS[key], description }))

      +);
       
       const legendSections = [
         {
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/components/OutputOptions.tsx
    content: >-
      --- packages/scn-ts-web-demo/src/components/OutputOptions.tsx

      +++ packages/scn-ts-web-demo/src/components/OutputOptions.tsx

      @@ -48,34 +48,34 @@
         rust_impl: 'Rust Impls',
       };
       
      +const tsDeclarationKinds = ['class', 'interface', 'function', 'variable',
      'enum', 'type_alias', 'module'];

      +const tsMemberKinds = ['method', 'constructor', 'property',
      'enum_member'];

      +const reactKinds = ['react_component', 'styled_component',
      'jsx_element'];

      +const cssKinds = ['css_class', 'css_id', 'css_tag', 'css_at_rule',
      'css_variable'];

      +const goKinds = ['go_package'];

      +const rustKinds = ['rust_struct', 'rust_trait', 'rust_impl'];

      +

      +const toFilter = (kind: string): string => `filter:${kind}`;

      +
       const symbolVisibilityTree: OptionItem = {
         name: 'Symbol Visibility',
         children: [
           {
             name: 'TypeScript/JavaScript',
             children: [
      -        {

      -          name: 'Declarations',

      -          children: [

      -            'filter:class', 'filter:interface', 'filter:function',
      'filter:variable',

      -            'filter:enum', 'filter:type_alias', 'filter:module',

      -          ],

      -        },

      -        { name: 'Members', children: ['filter:method',
      'filter:constructor', 'filter:property', 'filter:enum_member'] },

      +        { name: 'Declarations', children:
      tsDeclarationKinds.map(toFilter) },

      +        { name: 'Members', children: tsMemberKinds.map(toFilter) },
             ],
           },
      -    { name: 'React', children: ['filter:react_component',
      'filter:styled_component', 'filter:jsx_element'] },

      -    { name: 'CSS', children: ['filter:css_class', 'filter:css_id',
      'filter:css_tag', 'filter:css_at_rule', 'filter:css_variable'] },

      +    { name: 'React', children: reactKinds.map(toFilter) },

      +    { name: 'CSS', children: cssKinds.map(toFilter) },
           {
             name: 'Other Languages',
             children: [
      -        { name: 'Go', children: ['filter:go_package'] },

      -        { name: 'Rust', children: ['filter:rust_struct',
      'filter:rust_trait', 'filter:rust_impl'] },

      +        { name: 'Go', children: goKinds.map(toFilter) },

      +        { name: 'Rust', children: rustKinds.map(toFilter) },
             ],
           },
         ],
       };
       
       const optionTree: OptionItem[] = [
         {
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: |-
      --- packages/scn-ts-web-demo/src/App.tsx
      +++ packages/scn-ts-web-demo/src/App.tsx
      @@ -150,6 +150,14 @@
           window.addEventListener('mouseup', handleMouseUp);
         }, []);
       
      +  const resetAnalysisState = useCallback(() => {
      +    setScnOutput('');
      +    setAnalysisResult(null);
      +    setAnalysisTime(null);
      +    setProgress(null);
      +    setLogs([]);
      +  }, []);
      +
         const handleAnalyze = useCallback(async () => {
           if (!isInitialized || !workerRef.current) {
             setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
      @@ -161,12 +169,7 @@
           }
           
           setIsLoading(true);
      -    setScnOutput('');
      -    setAnalysisResult(null);
      -    setAnalysisTime(null);
      -    setProgress(null);
      -    setLogs([]);
      -
      +    resetAnalysisState();
           const onLog = (log: LogEntry) => {
             setLogs(prev => [...prev, log]);
           };
      @@ -192,7 +195,7 @@
             setIsLoading(false);
             setProgress(null);
           }
      -  }, [filesInput, isInitialized, isLoading]);
      +  }, [filesInput, isInitialized, isLoading, resetAnalysisState]);
       
         return (
           <div className="h-screen w-screen flex bg-background text-foreground overflow-hidden">
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/worker.ts
    content: >-
      --- packages/scn-ts-web-demo/src/worker.ts

      +++ packages/scn-ts-web-demo/src/worker.ts

      @@ -4,6 +4,23 @@
       import type { FileContent, LogLevel, SourceFile } from 'scn-ts-core';
       import type { LogEntry, ProgressData } from './types';
       
      +function sanitizeAnalysisResult(result: SourceFile[]): SourceFile[] {

      +  // Sanitize the result to make it structured-clonable for Comlink.

      +  result.forEach(file => {

      +    delete file.ast;

      +    if (file.language) {

      +      // The language object on the source file is a reference to a
      global

      +      // singleton. We must clone it before deleting non-serializable
      properties,

      +      // otherwise the parser state is destroyed for subsequent analysis
      runs.

      +      const sanitizedLanguage = { ...file.language };

      +      delete sanitizedLanguage.parser;

      +      delete sanitizedLanguage.loadedLanguage;

      +      file.language = sanitizedLanguage;

      +    }

      +  });

      +  return result;

      +}

      +
       // Define the API the worker will expose
       const workerApi = {
         isInitialized: false,
      @@ -49,23 +66,7 @@
               signal: this.abortController.signal,
             });
       
      -      // Sanitize the result to make it structured-clonable.

      -      analysisResult.forEach(file => {

      -        delete file.ast;

      -        if (file.language) {

      -          // The language object on the source file is a reference to a
      global

      -          // singleton. We must clone it before deleting non-serializable
      properties,

      -          // otherwise the parser state is destroyed for subsequent
      analysis runs.

      -          const sanitizedLanguage = { ...file.language };

      -          delete sanitizedLanguage.parser;

      -          delete sanitizedLanguage.loadedLanguage;

      -          file.language = sanitizedLanguage;

      -        }

      -      });

      -      

      -      return { result: analysisResult, analysisTime };

      +      return { result: sanitizeAnalysisResult(analysisResult),
      analysisTime };
           } finally {
             logger.setLogHandler(null);
             this.abortController = null;
    patchStrategy: new-unified
snapshot:
  packages/scn-ts-web-demo/src/components/Legend.tsx: >-
    import * as React from 'react';

    import { Button } from './ui/button';

    import { HelpCircle, X } from 'lucide-react';

    import { ICONS, SCN_SYMBOLS } from 'scn-ts-core';

    import { Card, CardContent, CardHeader, CardTitle } from './ui/card';

    import {
      Accordion,
      AccordionContent,
      AccordionItem,
      AccordionTrigger,
    } from "./ui/accordion"


    const symbolIcons = [
      { symbol: ICONS.class, description: 'Class or Component' },
      { symbol: ICONS.react_component, description: 'Class or Component' },
      { symbol: ICONS.interface, description: 'Interface or Trait' },
      { symbol: ICONS.rust_trait, description: 'Interface or Trait' },
      { symbol: ICONS.function, description: 'Function or Method' },
      { symbol: ICONS.method, description: 'Function or Method' },
      { symbol: ICONS.styled_component, description: 'Function or Method' },
      { symbol: ICONS.variable, description: 'Variable or Property' },
      { symbol: ICONS.property, description: 'Variable or Property' },
      { symbol: ICONS.enum, description: 'Enum' },
      { symbol: ICONS.type_alias, description: 'Type Alias' },
      { symbol: ICONS.jsx_element, description: 'JSX Element' },
      { symbol: ICONS.css_class, description: 'CSS Selector' },
    ];


    const legendSections = [
      {
        title: 'Prefixes',
        items: [
          { symbol: SCN_SYMBOLS.FILE_PREFIX, description: 'File path' },
          { symbol: SCN_SYMBOLS.EXPORTED_PREFIX, description: 'Exported symbol' },
          { symbol: SCN_SYMBOLS.PRIVATE_PREFIX, description: 'Private/unexported symbol' },
        ],
      },
      {
        title: 'Symbol Icons',
        items: Array.from(new Map(symbolIcons.map(item => [item.symbol, item])).values()),
      },
      {
        title: 'Relationships',
        items: [
          { symbol: SCN_SYMBOLS.OUTGOING_ARROW, description: 'Outgoing dependency' },
          { symbol: SCN_SYMBOLS.INCOMING_ARROW, description: 'Incoming dependency' },
        ],
      },
      {
        title: 'Modifiers & Tags',
        items: [
          { symbol: SCN_SYMBOLS.ASYNC, description: 'Async' },
          { symbol: SCN_SYMBOLS.THROWS, description: 'Throws error' },
          { symbol: SCN_SYMBOLS.PURE, description: 'Pure (no side-effects)' },
          { symbol: SCN_SYMBOLS.TAG_STYLED, description: 'Styled component' },
          { symbol: SCN_SYMBOLS.TAG_DYNAMIC, description: 'Dynamic import' },
          { symbol: SCN_SYMBOLS.TAG_GENERATED, description: 'Generated file' },
        ],
      },
    ];


    const LegendItem: React.FC<{ symbol: string; description: string }> = ({
    symbol, description }) => (
      <div className="grid grid-cols-[3rem_1fr] items-center gap-x-3 text-sm">
        <code className="font-mono text-base font-bold text-foreground/90 justify-self-center">{symbol}</code>
        <span className="text-muted-foreground">{description}</span>
      </div>
    );


    export const Legend: React.FC = () => {
      const [isOpen, setIsOpen] = React.useState(false);

      if (!isOpen) {
        return (
          <div className="sticky top-4 right-4 z-30 float-right">
            <Button
              variant="secondary"
              size="icon"
              onClick={() => setIsOpen(true)}
              title="Show Legend"
              className="rounded-full shadow-lg"
            >
              <HelpCircle className="h-5 w-5" />
            </Button>
          </div>
        );
      }

      return (
        <div className="sticky top-4 right-4 z-30 float-right">
          <Card className="w-80 max-h-[80vh] flex flex-col shadow-2xl bg-background/90 backdrop-blur-sm">
            <CardHeader className="flex flex-row items-center justify-between py-3 px-4 border-b">
              <CardTitle className="text-base">Legend</CardTitle>
              <Button variant="ghost" size="icon" className="h-7 w-7" onClick={() => setIsOpen(false)}>
                <X className="h-4 w-4" />
              </Button>
            </CardHeader>
            <CardContent className="p-0 overflow-y-auto">
              <Accordion type="multiple" defaultValue={legendSections.map(s => s.title)} className="w-full">
                {legendSections.map(({ title, items }) => (
                  <AccordionItem key={title} value={title}>
                    <AccordionTrigger className="px-4 py-2 text-sm hover:no-underline">{title}</AccordionTrigger>
                    <AccordionContent className="px-4 pb-3">
                      <div className="space-y-1.5">
                        {items.map(({ symbol, description }) =>
                          symbol && <LegendItem key={`${symbol}-${description}`} symbol={symbol} description={description} />
                        )}
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </CardContent>
          </Card>
        </div>
      );
    };
  packages/scn-ts-web-demo/src/components/OutputOptions.tsx: >-
    import * as React from 'react';

    import type { FormattingOptions } from '../types';

    import { ChevronDown, ChevronRight, Expand, Shrink } from 'lucide-react';

    import { Button } from './ui/button';

    import { Checkbox } from './ui/checkbox';

    import { Label } from './ui/label';


    interface OutputOptionsProps {
      options: FormattingOptions;
      setOptions: React.Dispatch<React.SetStateAction<FormattingOptions>>;
    }



    type RegularOptionKey = keyof Omit<FormattingOptions, 'displayFilters'>;

    type OptionItem = RegularOptionKey | string | { name: string; children:
    OptionItem[] };


    const symbolKindLabels: Record<string, string> = {
      // TS/JS
      class: 'Classes',
      interface: 'Interfaces',
      function: 'Functions',
      method: 'Methods',
      constructor: 'Constructors',
      variable: 'Variables',
      property: 'Properties',
      enum: 'Enums',
      enum_member: 'Enum Members',
      type_alias: 'Type Aliases',
      module: 'Modules',
      // React
      react_component: 'React Components',
      styled_component: 'Styled Components',
      jsx_element: 'JSX Elements',
      // CSS
      css_class: 'CSS Classes',
      css_id: 'CSS IDs',
      css_tag: 'CSS Tags',
      css_at_rule: 'CSS At-Rules',
      css_variable: 'CSS Variables',
      // Go
      go_package: 'Go Packages',
      // Rust
      rust_struct: 'Rust Structs',
      rust_trait: 'Rust Traits',
      rust_impl: 'Rust Impls',
    };


    const symbolVisibilityTree: OptionItem = {
      name: 'Symbol Visibility',
      children: [
        {
          name: 'TypeScript/JavaScript',
          children: [
            {
              name: 'Declarations',
              children: [
                'filter:class', 'filter:interface', 'filter:function', 'filter:variable',
                'filter:enum', 'filter:type_alias', 'filter:module',
              ],
            },
            { name: 'Members', children: ['filter:method', 'filter:constructor', 'filter:property', 'filter:enum_member'] },
          ],
        },
        { name: 'React', children: ['filter:react_component', 'filter:styled_component', 'filter:jsx_element'] },
        { name: 'CSS', children: ['filter:css_class', 'filter:css_id', 'filter:css_tag', 'filter:css_at_rule', 'filter:css_variable'] },
        {
          name: 'Other Languages',
          children: [
            { name: 'Go', children: ['filter:go_package'] },
            { name: 'Rust', children: ['filter:rust_struct', 'filter:rust_trait', 'filter:rust_impl'] },
          ],
        },
      ],
    };


    const optionTree: OptionItem[] = [
      {
        name: 'Display Elements',
        children: [
          'showIcons',
          {
            name: 'Indicators',
            children: ['showExportedIndicator', 'showPrivateIndicator'],
          },
          'showModifiers',
          'showTags',
          {
            name: 'Identifiers',
            children: ['showFilePrefix', 'showFileIds', 'showSymbolIds'],
          },
        ],
      },
      {
        name: 'Relationships',
        children: ['showOutgoing', 'showIncoming'],
      },
      {
        name: 'Structure',
        children: ['groupMembers'],
      },
      symbolVisibilityTree,
    ];


    const optionLabels: Record<RegularOptionKey, string> & Record<string,
    string> = {
      ...symbolKindLabels,
      showIcons: 'Icons',
      showExportedIndicator: 'Exported (+)',
      showPrivateIndicator: 'Private (-)',
      showModifiers: 'Modifiers',
      showTags: 'Tags',
      showSymbolIds: 'Symbol IDs',
      showFilePrefix: 'File Prefix (ยง)',
      showFileIds: 'File IDs',
      showOutgoing: 'Outgoing',
      showIncoming: 'Incoming',
      groupMembers: 'Group Members',
    };


    function getAllKeys(item: OptionItem): string[] {
      if (typeof item === 'string') {
        return [item];
      }
      return item.children.flatMap(getAllKeys);
    }


    const getAllGroupNames = (items: OptionItem[]): string[] => {
      return items.flatMap(item => {
        if (typeof item === 'object' && 'name' in item) {
          return [item.name, ...getAllGroupNames(item.children)];
        }
        return [];
      });
    }


    const OutputOptions: React.FC<OutputOptionsProps> = ({ options, setOptions
    }) => {
      const [expandedGroups, setExpandedGroups] = React.useState<Set<string>>(
        () =>
          new Set([
            'Display Elements', 'Indicators', 'Relationships', 'Structure',
            'TypeScript/JavaScript',
            'React', 'Identifiers',
          ])
      );

      const allGroupNames = React.useMemo(() => getAllGroupNames(optionTree), []);

      const expandAll = () => {
        setExpandedGroups(new Set(allGroupNames));
      };

      const collapseAll = () => {
        setExpandedGroups(new Set());
      };

      const toggleGroup = (groupName: string) => {
        setExpandedGroups(prev => {
          const newSet = new Set(prev);
          if (newSet.has(groupName)) {
            newSet.delete(groupName);
          } else {
            newSet.add(groupName);
          }
          return newSet;
        });
      };

      const handleChange = (optionKey: string) => (checked: boolean | 'indeterminate') => {
        const isChecked = checked === true;
        if (optionKey.startsWith('filter:')) {
          const kind = optionKey.substring('filter:'.length);
          setOptions(prev => ({
            ...prev,
            displayFilters: { ...(prev.displayFilters ?? {}), [kind]: isChecked },
          }));
        } else {
          setOptions(prev => ({ ...prev, [optionKey]: isChecked }));
        }
      };

      const handleGroupChange = (keys: ReadonlyArray<string>) => (checked: boolean | 'indeterminate') => {
        const isChecked = checked === true;
        setOptions(prev => {
          const newOptions: FormattingOptions = { ...prev };
          const newDisplayFilters = { ...(prev.displayFilters ?? {}) };

          for (const key of keys) {
            if (key.startsWith('filter:')) {
              newDisplayFilters[key.substring('filter:'.length)] = isChecked;
            } else {
              newOptions[key as RegularOptionKey] = isChecked;
            }
          }
          newOptions.displayFilters = newDisplayFilters;
          return newOptions;
        });
      };

      const renderItem = (item: OptionItem, level: number): React.ReactNode => {
        if (typeof item === 'string') {
          const key = item as string;
          const isFilter = key.startsWith('filter:');
          const filterKind = isFilter ? key.substring('filter:'.length) : null;
          const labelKey = filterKind ?? key;

          return (
            <div key={key} style={{ paddingLeft: `${level * 1.5}rem` }} className="flex items-center space-x-1.5">
              <Checkbox
                id={key}
                checked={
                  isFilter ? options.displayFilters?.[filterKind!] ?? true : options[key as RegularOptionKey] ?? true
                }
                onCheckedChange={handleChange(key)}
              />
              <Label htmlFor={key} className="cursor-pointer select-none text-sm text-muted-foreground font-normal">
                {optionLabels[labelKey as keyof typeof optionLabels] ?? labelKey}
              </Label>
            </div>
          );
        }

        const { name, children } = item;
        const isExpanded = expandedGroups.has(name);
        const allKeys = getAllKeys(item);
        const allChecked = allKeys.every(key => {
          if (key.startsWith('filter:')) {
            return options.displayFilters?.[key.substring('filter:'.length)] ?? true;
          }
          return options[key as RegularOptionKey] ?? true;
        });

        return (
          <div key={name}>
            <div
              className="flex items-center space-x-1.5 py-1 rounded-md hover:bg-accent/50 cursor-pointer select-none -mx-2 px-2"
              style={{ paddingLeft: `calc(${level * 1.5}rem + 0.5rem)` }}
              onClick={() => toggleGroup(name)}
            >
              {isExpanded ? <ChevronDown className="h-4 w-4 flex-shrink-0" /> : <ChevronRight className="h-4 w-4 flex-shrink-0" />}
              <Checkbox
                id={`group-${name.replace(/\s+/g, '-')}`}
                title={`Toggle all in ${name}`}
                checked={allChecked}
                onCheckedChange={handleGroupChange(allKeys)}
                onClick={(e) => e.stopPropagation()} // Prevent row click from firing
              />
              <Label
                htmlFor={`group-${name.replace(/\s+/g, '-')}`}
                className="font-semibold text-sm cursor-pointer select-none"
              >
                {name}
              </Label>
            </div>
            {isExpanded && (
              <div className="pt-1.5 space-y-1.5">
                {children.map(child => renderItem(child, level + 1))}
              </div>
            )}
          </div>
        );
      };

      return (
        <div className="space-y-2">
          <div className="flex items-center space-x-2 -mx-2">
            <Button variant="ghost" size="sm" onClick={expandAll} className="text-muted-foreground hover:text-foreground h-auto px-2 py-1 text-xs">
              <Expand className="mr-1.5 h-3.5 w-3.5" />
              Expand all
            </Button>
            <Button variant="ghost" size="sm" onClick={collapseAll} className="text-muted-foreground hover:text-foreground h-auto px-2 py-1 text-xs">
              <Shrink className="mr-1.5 h-3.5 w-3.5" />
              Collapse all
            </Button>
          </div>
          <div className="space-y-1">
            {optionTree.map(item => renderItem(item, 0))}
          </div>
        </div>
      );
    };


    export default OutputOptions;
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback, useRef } from 'react';

    import { get_encoding, type Tiktoken } from 'tiktoken';

    import * as Comlink from 'comlink';

    import type { Remote } from 'comlink';

    import { generateScn } from 'scn-ts-core';

    import type { SourceFile } from 'scn-ts-core';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import OutputOptions from './components/OutputOptions';

    import { Legend } from './components/Legend';

    import { Play, Loader, Copy, Check, StopCircle } from 'lucide-react';

    import type { LogEntry, ProgressData, FormattingOptions } from './types';

    import type { WorkerApi } from './worker';

    import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from
    './components/ui/accordion';


    function App() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [sidebarWidth, setSidebarWidth] = useState(480);
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
      const [isCopied, setIsCopied] = useState(false);
      const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>({
        showOutgoing: true,
        showIncoming: true,
        showIcons: true,
        showExportedIndicator: true,
        showPrivateIndicator: true,
        showModifiers: true,
        showTags: true,
        showSymbolIds: true,
        groupMembers: true,
        displayFilters: {},
        showFilePrefix: true,
        showFileIds: true,
      });
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [encoder, setEncoder] = useState<Tiktoken | null>(null);
      const [analysisTime, setAnalysisTime] = useState<number | null>(null);
      const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });
      
      const isResizing = useRef(false);
      const workerRef = useRef<Remote<WorkerApi> | null>(null);

      useEffect(() => {
        // Initialize Tokenizer on main thread
        try {
          const enc = get_encoding("cl100k_base");
          setEncoder(enc);
        } catch (e) {
          console.error("Failed to initialize tokenizer:", e);
          setLogs(prev => [...prev, { level: 'error', message: 'Failed to initialize tokenizer.', timestamp: Date.now() }]);
        }

        // Comlink setup
        const worker = new Worker(new URL('./worker.ts', import.meta.url), { type: 'module' });
        const wrappedWorker = Comlink.wrap<WorkerApi>(worker);
        workerRef.current = wrappedWorker;

        const initializeWorker = async () => {
          try {
            await wrappedWorker.init();
            setIsInitialized(true);
            setLogs(prev => [...prev, { level: 'info', message: 'Analysis worker ready.', timestamp: Date.now() }]);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            setLogs(prev => [...prev, { level: 'error', message: `Worker failed to initialize: ${message}`, timestamp: Date.now() }]);
          }
        };

        initializeWorker();

        return () => {
          wrappedWorker[Comlink.releaseProxy]();
          worker.terminate();
        };
      }, []);

      useEffect(() => {
        if (!encoder) return;
        try {
          const inputTokens = encoder.encode(filesInput).length;
          const outputTokens = encoder.encode(scnOutput).length;
          setTokenCounts({ input: inputTokens, output: outputTokens });
        } catch (e) {
          console.error("Tokenization error:", e);
          setTokenCounts({ input: 0, output: 0 });
        }
      }, [filesInput, scnOutput, encoder]);

      useEffect(() => {
        if (analysisResult) {
          setScnOutput(generateScn(analysisResult, formattingOptions));
        }
      }, [analysisResult, formattingOptions]);

      const handleCopy = useCallback(() => {
        if (scnOutput) {
          navigator.clipboard.writeText(scnOutput).then(
            () => {
              setIsCopied(true);
              setTimeout(() => setIsCopied(false), 2000);
            }
          );
        }
      }, [scnOutput]);

      const handleStop = useCallback(() => {
        if (isLoading && workerRef.current) {
          workerRef.current.cancel();
          // The error propagation and finally block in handleAnalyze will handle state updates.
        }
      }, [isLoading]);

      const handleMouseDown = useCallback((e: React.MouseEvent) => {
        e.preventDefault();
        isResizing.current = true;
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';

        const handleMouseMove = (event: MouseEvent) => {
          if (isResizing.current) {
            const newWidth = event.clientX;
            const minWidth = 320; // 20rem
            const maxWidth = window.innerWidth * 0.8;
            setSidebarWidth(Math.min(maxWidth, Math.max(minWidth, newWidth)));
          }
        };

        const handleMouseUp = () => {
          isResizing.current = false;
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('mouseup', handleMouseUp);
        };

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
      }, []);

      const handleAnalyze = useCallback(async () => {
        if (!isInitialized || !workerRef.current) {
          setLogs(prev => [...prev, { level: 'warn', message: 'Analysis worker not ready.', timestamp: Date.now() }]);
          return;
        }
        
        if (isLoading) {
          return; // Prevent multiple concurrent analyses
        }
        
        setIsLoading(true);
        setScnOutput('');
        setAnalysisResult(null);
        setAnalysisTime(null);
        setProgress(null);
        setLogs([]);

        const onLog = (log: LogEntry) => {
          setLogs(prev => [...prev, log]);
        };

        try {
          const { result, analysisTime } = await workerRef.current.analyze(
            { filesInput, logLevel: 'debug' },
            Comlink.proxy(setProgress),
            Comlink.proxy(onLog)
          );
          setAnalysisResult(result);
          setAnalysisTime(analysisTime);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          if ((error as Error).name === 'AbortError') {
            setLogs(prev => [...prev, { level: 'warn', message: 'Analysis canceled by user.', timestamp: Date.now() }]);
          } else {
            setLogs(prev => [...prev, { level: 'error', message: `Analysis error: ${message}`, timestamp: Date.now() }]);
          }
        } finally {
          setIsLoading(false);
          setProgress(null);
        }
      }, [filesInput, isInitialized, isLoading]);

      return (
        <div className="h-screen w-screen flex bg-background text-foreground overflow-hidden">
          {/* Sidebar */}
          <aside style={{ width: `${sidebarWidth}px` }} className="max-w-[80%] min-w-[320px] flex-shrink-0 flex flex-col border-r">
            <div className="flex-shrink-0 flex items-center justify-between p-4 border-b bg-background relative z-20">
              <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
              <div className="flex items-center space-x-2">
                {isLoading ? (
                  <>
                    <Button disabled className="w-32 justify-center">
                      <Loader className="mr-2 h-4 w-4 animate-spin" />
                      <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                    </Button>
                    <Button onClick={handleStop} variant="outline" size="icon" title="Stop analysis">
                      <StopCircle className="h-4 w-4" />
                    </Button>
                  </>
                ) : (
                  <Button onClick={handleAnalyze} disabled={!isInitialized} className="w-32 justify-center">
                    <Play className="mr-2 h-4 w-4" />
                    <span>Analyze</span>
                  </Button>
                )}
              </div>
            </div>

            <div className="flex-grow overflow-y-auto">
              <Accordion type="multiple" defaultValue={['input', 'options', 'logs']} className="w-full">
                <AccordionItem value="input">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                    <div className="flex w-full justify-between items-center">
                      <span>Input Files (JSON)</span>
                      <span className="text-xs font-normal text-muted-foreground tabular-nums">
                        {tokenCounts.input.toLocaleString()} tokens
                      </span>
                    </div>
                  </AccordionTrigger>
                  <AccordionContent>
                    <div className="px-4 pb-4 h-96">
                      <Textarea
                        value={filesInput}
                        onChange={(e) => setFilesInput(e.currentTarget.value)}
                        className="h-full w-full font-mono text-xs resize-none"
                        placeholder="Paste an array of FileContent objects here..."
                      />
                    </div>
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="options">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Formatting Options</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="logs">
                  <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Logs</AccordionTrigger>
                  <AccordionContent className="px-4">
                    <LogViewer logs={logs} />
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </div>
          </aside>

          {/* Resizer */}
          <div
            role="separator"
            onMouseDown={handleMouseDown}
            className="w-1.5 flex-shrink-0 cursor-col-resize hover:bg-primary/20 transition-colors duration-200"
          />

          {/* Main Content Area */}
          <main className="flex-grow flex flex-col overflow-hidden relative">
            <div className="flex justify-between items-center p-4 border-b flex-shrink-0">
              <h2 className="text-lg font-semibold leading-none tracking-tight">Output (SCN)</h2>
              <div className="flex items-center gap-4">
                {analysisTime !== null && (
                  <span className="text-sm text-muted-foreground">
                    Analyzed in {(analysisTime / 1000).toFixed(2)}s
                  </span>
                )}
                <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                <Button variant="ghost" size="icon" onClick={handleCopy} disabled={!scnOutput} title="Copy to clipboard">
                  {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                </Button>
              </div>
            </div>
            <div className="p-4 flex-grow overflow-auto font-mono text-xs relative">
              <Legend />
              <pre className="whitespace-pre-wrap">
                {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
              </pre>
            </div>
          </main>
        </div>
      );
    }


    export default App;
  packages/scn-ts-web-demo/src/worker.ts: |-
    import * as Comlink from 'comlink';
    import { initializeParser, analyzeProject, logger } from 'scn-ts-core';
    import type { FileContent, LogLevel, SourceFile } from 'scn-ts-core';
    import type { LogEntry, ProgressData } from './types';

    // Define the API the worker will expose
    const workerApi = {
      isInitialized: false,
      abortController: null as AbortController | null,

      async init() {
        if (this.isInitialized) return;
        await initializeParser({ wasmBaseUrl: '/wasm/' });
        this.isInitialized = true;
      },

      async analyze(
        { filesInput, logLevel }: { filesInput: string; logLevel: LogLevel },
        onProgress: (progress: ProgressData) => void,
        onLog: (log: LogEntry) => void
      ): Promise<{ result: SourceFile[], analysisTime: number }> {
        if (!this.isInitialized) {
          throw new Error('Worker not initialized.');
        }

        this.abortController = new AbortController();

        logger.setLogHandler((level, ...args) => {
          const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
          onLog({ level, message, timestamp: Date.now() });
        });
        logger.setLevel(logLevel);

        try {
          let files: FileContent[] = [];
          try {
            files = JSON.parse(filesInput);
            if (!Array.isArray(files)) throw new Error("Input is not an array.");
          } catch (error) {
            throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
          }

          const { sourceFiles: analysisResult, analysisTime } = await analyzeProject({
            files,
            onProgress,
            logLevel,
            signal: this.abortController.signal,
          });

          // Sanitize the result to make it structured-clonable.
          analysisResult.forEach(file => {
            delete file.ast;
            if (file.language) {
              // The language object on the source file is a reference to a global
              // singleton. We must clone it before deleting non-serializable properties,
              // otherwise the parser state is destroyed for subsequent analysis runs.
              const sanitizedLanguage = { ...file.language };
              delete sanitizedLanguage.parser;
              delete sanitizedLanguage.loadedLanguage;
              file.language = sanitizedLanguage;
            }
          });
          
          return { result: analysisResult, analysisTime };
        } finally {
          logger.setLogHandler(null);
          this.abortController = null;
        }
      },

      cancel() {
        this.abortController?.abort();
      },
    };

    Comlink.expose(workerApi);

    export type WorkerApi = typeof workerApi;
approved: true
