uuid: a69700f1-01f1-47fa-80b6-19349c25f617
projectId: scn-ts-core
createdAt: '2025-09-08T01:10:46.441Z'
gitCommitMsg: 'feat(web-demo): add UI and plumbing for glob filtering'
promptSummary: 'Add glob include/exclude feature to the UI, phase 1: plumbing.'
reasoning:
  - >-
    alright, let's get this glob filtering feature roughed in. phase one, as you
    said. we'll get the UI and all the plumbing sorted out, from the React
    components down to the core analysis function. the actual filtering logic
    can wait for phase two. sound good? let's do it.
  - '### 1. State Management'
  - >-
    first up, we need a place to store the include/exclude patterns. i'll add
    them to `useAppStore`. i'm defaulting `includePattern` to `**/*` so we see
    all files by default. `excludePattern` can start empty.
  - '### 2. UI Components'
  - >-
    next, let's add the UI for these patterns in `App.tsx`. i'll create a new
    collapsible section in the sidebar for "File Filtering". inside, two text
    areas for include and exclude globs. i'll also update the `handleAnalyze`
    call to pass these new values down the line.
  - '### 3. Hook Update'
  - >-
    now to pipe the patterns from the UI into the analysis hook.
    `useAnalysis.hook.ts`'s `handleAnalyze` function will now accept
    `includePattern` and `excludePattern` and pass them to the analysis service.
  - '### 4. Worker Update'
  - >-
    the web worker is next. it'll receive the patterns, split the
    newline-separated strings into arrays, and then pass them along to the core
    `analyzeProject` function.
  - '### 5. Core API Types'
  - >-
    we're getting close to the core. let's update the type definitions.
    `AnalyzeProjectOptions` in `src/types.ts` needs to know about our new
    `include` and `exclude` arrays.
  - '### 6. Core API Function Signature'
  - >-
    finally, let's update the `analyzeProject` function signature in
    `src/main.ts` to accept the new options. we're not using them yet, but this
    completes the plumbing for phase one.
  - >-
    that's it for phase one. we've got the UI in place and the patterns are
    piped all the way down to the core analyzer. ready for phase two when you
    are.
operations:
  - type: write
    path: packages/scn-ts-web-demo/src/stores/app.store.ts
    content: |-
      --- packages/scn-ts-web-demo/src/stores/app.store.ts
      +++ packages/scn-ts-web-demo/src/stores/app.store.ts
      @@ -6,6 +6,8 @@
         const [filesInput, setFilesInput] = useState(defaultFilesJSON);
         const [scnOutput, setScnOutput] = useState('');
         const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>(getFormattingOptionsForPreset('default'));
      +  const [includePattern, setIncludePattern] = useState('**/*');
      +  const [excludePattern, setExcludePattern] = useState('');
       
         return {
           filesInput,
      @@ -14,6 +16,10 @@
           setScnOutput,
           formattingOptions,
           setFormattingOptions,
      +    includePattern,
      +    setIncludePattern,
      +    excludePattern,
      +    setExcludePattern,
         };
       }
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: >-
      --- packages/scn-ts-web-demo/src/App.tsx

      +++ packages/scn-ts-web-demo/src/App.tsx

      @@ -21,6 +21,10 @@
           setScnOutput,
           formattingOptions,
           setFormattingOptions,
      +    includePattern,

      +    setIncludePattern,

      +    excludePattern,

      +    setExcludePattern,
         } = useAppStore();
       
         const {
      @@ -73,8 +77,8 @@
         }, [performCopy, scnOutput]);
       
         const handleAnalyze = useCallback(async () => {
      -    performAnalysis(filesInput, formattingOptions);

      -  }, [performAnalysis, filesInput, formattingOptions]);

      +    performAnalysis(filesInput, formattingOptions, includePattern,
      excludePattern);

      +  }, [performAnalysis, filesInput, formattingOptions, includePattern,
      excludePattern]);
       
         const { totalSymbols, visibleSymbols } = useMemo(() => {
           if (!analysisResult) {
      @@ -122,7 +126,7 @@
               </div>
       
               <div className="flex-grow overflow-y-auto">
      -          <Accordion type="multiple" defaultValue={['input', 'options',
      'logs']} className="w-full">

      +          <Accordion type="multiple" defaultValue={['input', 'filtering',
      'options', 'logs']} className="w-full">
                   <AccordionItem value="input">
                     <AccordionHeader>
                       <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
      @@ -145,6 +149,36 @@
                     </AccordionContent>
                   </AccordionItem>
       
      +            <AccordionItem value="filtering">

      +              <AccordionHeader>

      +                <AccordionTrigger className="px-4 text-sm font-semibold
      hover:no-underline">

      +                  File Filtering (Globs)

      +                </AccordionTrigger>

      +              </Header>

      +              <AccordionContent className="p-4 space-y-4">

      +                <div>

      +                  <label htmlFor="include-glob" className="text-xs
      font-medium">Include</label>

      +                  <Textarea

      +                    id="include-glob"

      +                    value={includePattern}

      +                    onChange={(e) =>
      setIncludePattern(e.currentTarget.value)}

      +                    className="h-24 w-full font-mono text-xs resize-y
      mt-1"

      +                    placeholder="e.g. src/**/*.ts"

      +                  />

      +                  <p className="text-xs text-muted-foreground mt-1">One
      pattern per line. Matches against file paths.</p>

      +                </div>

      +                <div>

      +                  <label htmlFor="exclude-glob" className="text-xs
      font-medium">Exclude</label>

      +                  <Textarea

      +                    id="exclude-glob"

      +                    value={excludePattern}

      +                    onChange={(e) =>
      setExcludePattern(e.currentTarget.value)}

      +                    className="h-24 w-full font-mono text-xs resize-y
      mt-1"

      +                    placeholder="e.g.
      **/*.spec.ts&#10;**/node_modules/**"

      +                  />

      +                  <p className="text-xs text-muted-foreground mt-1">One
      pattern per line. Exclude takes precedence.</p>

      +                </div>

      +              </AccordionContent>

      +            </AccordionItem>

      +
                   <AccordionItem value="options">
                     <AccordionHeader className="items-center">
                       <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/hooks/useAnalysis.hook.ts
    content: >-
      --- packages/scn-ts-web-demo/src/hooks/useAnalysis.hook.ts

      +++ packages/scn-ts-web-demo/src/hooks/useAnalysis.hook.ts

      @@ -62,7 +62,12 @@
           setLogs([]);
         }, []);
       
      -  const handleAnalyze = useCallback(async (filesInput: string,
      formattingOptions: FormattingOptions) => {

      +  const handleAnalyze = useCallback(async (

      +    filesInput: string,

      +    formattingOptions: FormattingOptions,

      +    includePattern: string,

      +    excludePattern: string,

      +  ) => {
           if (!isInitialized || !serviceRef.current) {
             onLogPartial({ level: 'warn', message: 'Analysis worker not ready.' });
             return;
      @@ -81,7 +86,9 @@
               'debug',
               formattingOptions,
               setProgress,
      -        onLog

      +        onLog,

      +        includePattern,

      +        excludePattern,
             );
             setAnalysisResult(result);
             setAnalysisTime(analysisTime);
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/worker.ts
    content: >-
      --- packages/scn-ts-web-demo/src/worker.ts

      +++ packages/scn-ts-web-demo/src/worker.ts

      @@ -37,7 +37,14 @@
         }
       
         async function analyze(
      -    { filesInput, logLevel, formattingOptions }: { filesInput: string;
      logLevel: LogLevel, formattingOptions: FormattingOptions },

      +    { filesInput, logLevel, formattingOptions, includePattern,
      excludePattern }: {

      +      filesInput: string;

      +      logLevel: LogLevel;

      +      formattingOptions: FormattingOptions;

      +      includePattern?: string;

      +      excludePattern?: string;

      +    },
           onProgress: (progress: ProgressData) => void,
           onLog: (log: LogEntry) => void
         ): Promise<{ result: SourceFile[], analysisTime: number, tokenImpact: FormattingOptionsTokenImpact }> {
      @@ -62,11 +69,16 @@
               throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
             }
       
      +      const include = includePattern?.split('\n').filter(p => p.trim()
      !== '');

      +      const exclude = excludePattern?.split('\n').filter(p => p.trim()
      !== '');

      +
             const { sourceFiles: analysisResult, analysisTime } = await analyzeProject({
               files,
               onProgress,
               logLevel,
               signal: abortController.signal,
      +        include,

      +        exclude,
             });
       
             const tokenImpact = calculateTokenImpact(analysisResult, formattingOptions);
    patchStrategy: new-unified
  - type: write
    path: src/types.ts
    content: |-
      --- src/types.ts
      +++ src/types.ts
      @@ -12,6 +12,8 @@
           onProgress?: (progress: { percentage: number; message: string }) => void;
           logLevel?: LogLevel;
           signal?: AbortSignal;
      +    include?: string[];
      +    exclude?: string[];
       }
       
       export type FormattingPreset = 'minimal' | 'compact' | 'default' | 'detailed' | 'verbose';
    patchStrategy: new-unified
  - type: write
    path: src/main.ts
    content: |-
      --- src/main.ts
      +++ src/main.ts
      @@ -201,6 +201,8 @@
               onProgress,
               logLevel,
               signal,
      +        include,
      +        exclude,
           }: AnalyzeProjectOptions
       ): Promise<{ sourceFiles: SourceFile[], analysisTime: number }> => {
           const startTime = performance.now();
    patchStrategy: new-unified
snapshot:
  packages/scn-ts-web-demo/src/stores/app.store.ts: |-
    import { useState } from 'react';
    import { defaultFilesJSON } from '../default-files';
    import type { FormattingOptions } from '../types';
    import { getFormattingOptionsForPreset } from 'scn-ts-core';

    export function useAppStore() {
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [formattingOptions, setFormattingOptions] = useState<FormattingOptions>(getFormattingOptionsForPreset('default'));

      return {
        filesInput,
        setFilesInput,
        scnOutput,
        setScnOutput,
        formattingOptions,
        setFormattingOptions,
      };
    }
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useEffect, useCallback, useMemo, useRef, useState } from 'react';

    import { generateScn, initializeTokenizer, countTokens } from 'scn-ts-core';

    import { Button } from './components/ui/button';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import { OutputOptions } from './components/OutputOptions';

    import { Legend } from './components/Legend';

    import { Play, Loader, Copy, Check, StopCircle, ZoomIn, ZoomOut, RefreshCw }
    from 'lucide-react';

    import { Accordion, AccordionContent, AccordionItem, AccordionHeader,
    AccordionTrigger } from './components/ui/accordion';

    import { useAnalysis } from './hooks/useAnalysis.hook';

    import { useClipboard } from './hooks/useClipboard.hook';

    import { useResizableSidebar } from './hooks/useResizableSidebar.hook';

    import { useAppStore } from './stores/app.store';

    import { cn } from './lib/utils';

    import type { CodeSymbol } from 'scn-ts-core';


    function App() {
      const {
        filesInput,
        setFilesInput,
        scnOutput,
        setScnOutput,
        formattingOptions,
        setFormattingOptions,
      } = useAppStore();

      const {
        isInitialized,
        isLoading,
        analysisResult,
        progress,
        logs,
        analysisTime,
        tokenImpact,
        handleAnalyze: performAnalysis,
        handleStop,
        onLogPartial,
      } = useAnalysis();

      const [zoomLevel, setZoomLevel] = useState(1);
      const baseFontSizeRem = 0.75; // Corresponds to text-xs

      const handleZoomIn = () => setZoomLevel(z => Math.min(z * 1.2, 4));
      const handleZoomOut = () => setZoomLevel(z => Math.max(z / 1.2, 0.25));
      const handleZoomReset = () => setZoomLevel(1);

      const { sidebarWidth, handleMouseDown } = useResizableSidebar(480);
      const { isCopied, handleCopy: performCopy } = useClipboard();

      useEffect(() => {
        if (!initializeTokenizer()) {
          onLogPartial({ level: 'error', message: 'Failed to initialize tokenizer.' });
        }
      }, [onLogPartial]);

      useEffect(() => {
        if (analysisResult) {
          setScnOutput(generateScn(analysisResult, formattingOptions));
        } else {
          setScnOutput('');
        }
      }, [analysisResult, formattingOptions]);

      const { tokenCounts, tokenReductionPercent } = useMemo(() => {
        const input = countTokens(filesInput);
        const output = countTokens(scnOutput);
        let reductionPercent: number | null = null;
        if (input > 0) {
          reductionPercent = ((input - output) / input) * 100;
        }
        return {
          tokenCounts: { input, output },
          tokenReductionPercent: reductionPercent,
        };
      }, [filesInput, scnOutput]);

      const handleCopy = useCallback(() => {
        performCopy(scnOutput);
      }, [performCopy, scnOutput]);

      const handleAnalyze = useCallback(async () => {
        performAnalysis(filesInput, formattingOptions);
      }, [performAnalysis, filesInput, formattingOptions]);

      const { totalSymbols, visibleSymbols } = useMemo(() => {
        if (!analysisResult) {
          return { totalSymbols: 0, visibleSymbols: 0 };
        }
        const allSymbols: CodeSymbol[] = analysisResult.flatMap(file => file.symbols);
        const total = allSymbols.length;
        let visibleSymbolsArr = allSymbols;
        if (formattingOptions.showOnlyExports) {
          visibleSymbolsArr = visibleSymbolsArr.filter(symbol => symbol.isExported);
        }
        if (formattingOptions.displayFilters) {
          const filters = formattingOptions.displayFilters;
          visibleSymbolsArr = visibleSymbolsArr.filter(symbol => {
            return (filters[symbol.kind] ?? filters['*'] ?? true);
          });
        }
        return { totalSymbols: total, visibleSymbols: visibleSymbolsArr.length };
      }, [analysisResult, formattingOptions.displayFilters, formattingOptions.showOnlyExports]);

      return (
        <div className="h-screen w-screen flex bg-background text-foreground overflow-hidden">
          {/* Sidebar */}
          <aside style={{ width: `${sidebarWidth}px` }} className="max-w-[80%] min-w-[320px] flex-shrink-0 flex flex-col border-r">
            <div className="flex-shrink-0 flex items-center justify-between p-4 border-b bg-background relative z-20">
              <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
              <div className="flex items-center space-x-2">
                {isLoading ? (
                  <>
                    <Button disabled className="w-32 justify-center">
                      <Loader className="mr-2 h-4 w-4 animate-spin" />
                      <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                    </Button>
                    <Button onClick={handleStop} variant="outline" size="icon" title="Stop analysis">
                      <StopCircle className="h-4 w-4" />
                    </Button>
                  </>
                ) : (
                  <Button onClick={handleAnalyze} disabled={!isInitialized} className="w-32 justify-center">
                    <Play className="mr-2 h-4 w-4" />
                    <span>Analyze</span>
                  </Button>
                )}
              </div>
            </div>

            <div className="flex-grow overflow-y-auto">
              <Accordion type="multiple" defaultValue={['input', 'options', 'logs']} className="w-full">
                <AccordionItem value="input">
                  <AccordionHeader>
                    <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                      <div className="flex w-full justify-between items-center">
                        <span>Input Files (JSON)</span>
                        <span className="text-xs font-normal text-muted-foreground tabular-nums">
                          {tokenCounts.input.toLocaleString()} tokens
                        </span>
                      </div>
                    </AccordionTrigger>
                  </AccordionHeader>
                  <AccordionContent className="p-4">
                    <div className="h-96">
                      <Textarea
                        value={filesInput}
                        onChange={(e) => setFilesInput(e.currentTarget.value)}
                        className="h-full w-full font-mono text-xs resize-none"
                        placeholder="Paste an array of FileContent objects here..."
                      />
                    </div>
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="options">
                  <AccordionHeader className="items-center">
                    <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">
                      <div className="flex w-full items-center justify-between">
                        <span>Formatting Options</span>
                          {analysisResult && (
                            <span className="text-xs font-normal text-muted-foreground tabular-nums">
                              {visibleSymbols} / {totalSymbols} symbols
                            </span>
                          )}
                      </div>
                    </AccordionTrigger>
                  </AccordionHeader>
                  <AccordionContent className="px-4 pt-4">
                    <OutputOptions options={formattingOptions} setOptions={setFormattingOptions} tokenImpact={tokenImpact} />
                  </AccordionContent>
                </AccordionItem>

                <AccordionItem value="logs">
                  <AccordionHeader>
                    <AccordionTrigger className="px-4 text-sm font-semibold hover:no-underline">Logs</AccordionTrigger>
                  </AccordionHeader>
                  <AccordionContent className="px-4 pt-4">
                    <LogViewer logs={logs} />
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </div>
          </aside>

          {/* Resizer */}
          <div
            role="separator"
            onMouseDown={handleMouseDown}
            className="w-1.5 flex-shrink-0 cursor-col-resize hover:bg-primary/20 transition-colors duration-200"
          />

          {/* Main Content Area */}
          <main className="flex-grow flex flex-col overflow-hidden relative group">
            <div className="flex justify-between items-center p-4 border-b flex-shrink-0">
              <h2 className="text-lg font-semibold leading-none tracking-tight">Output (SCN)</h2>
              <div className="flex items-center gap-4">
                {analysisTime !== null && (
                  <span className="text-sm text-muted-foreground">
                    Analyzed in {(analysisTime / 1000).toFixed(2)}s
                  </span>
                )}
                <span className="text-sm font-normal text-muted-foreground tabular-nums">{tokenCounts.output.toLocaleString()} tokens</span>
                {tokenReductionPercent !== null && analysisResult && (
                  <span
                    className={cn(
                      "text-sm font-medium tabular-nums",
                      tokenReductionPercent >= 0 ? "text-green-500" : "text-red-500"
                    )}
                    title="Token count change from input to output"
                  >
                    {tokenReductionPercent >= 0 ? '▼' : '▲'}{' '}
                    {Math.abs(tokenReductionPercent).toFixed(0)}%
                  </span>
                )}
                <Button variant="ghost" size="icon" onClick={handleCopy} disabled={!scnOutput} title="Copy to clipboard">
                  {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                </Button>
              </div>
            </div>
            <div className="p-4 flex-grow overflow-auto font-mono text-xs relative group">
              <Legend />
              <pre
                className="whitespace-pre-wrap"
                style={{
                  fontSize: `${baseFontSizeRem * zoomLevel}rem`,
                  lineHeight: `${zoomLevel}rem`,
                }}
              >
                {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
              </pre>
            </div>
            <div className="absolute bottom-4 right-4 z-10 flex items-center gap-1 rounded-md border bg-background/80 p-1 opacity-0 backdrop-blur-sm transition-opacity duration-200 group-hover:opacity-100">
              <Button variant="ghost" size="icon" onClick={handleZoomOut} title="Zoom out" className="h-7 w-7">
                <ZoomOut className="h-4 w-4" />
              </Button>
              <Button variant="ghost" size="icon" onClick={handleZoomReset} title="Reset zoom" className="h-7 w-7">
                <RefreshCw className="h-4 w-4" />
              </Button>
              <Button variant="ghost" size="icon" onClick={handleZoomIn} title="Zoom in" className="h-7 w-7">
                <ZoomIn className="h-4 w-4" />
              </Button>
            </div>
          </main>
        </div>
      );
    }


    export default App;
  packages/scn-ts-web-demo/src/hooks/useAnalysis.hook.ts: >-
    import { useState, useEffect, useCallback, useRef } from 'react';

    import type { SourceFile, FormattingOptions, FormattingOptionsTokenImpact }
    from 'scn-ts-core';

    import type { LogEntry, ProgressData } from '../types';

    import { createAnalysisService, type AnalysisServiceAPI } from
    '../services/analysis.service';


    export function useAnalysis() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [analysisResult, setAnalysisResult] = useState<SourceFile[] | null>(null);
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [analysisTime, setAnalysisTime] = useState<number | null>(null);
      const [tokenImpact, setTokenImpact] = useState<FormattingOptionsTokenImpact | null>(null);
      const serviceRef = useRef<AnalysisServiceAPI | null>(null);

      const onLog = useCallback((log: LogEntry) => {
        setLogs(prev => [...prev, log]);
      }, []);

      const onLogPartial = useCallback((log: Pick<LogEntry, 'level' | 'message'>) => {
        onLog({ ...log, timestamp: Date.now() });
      }, [onLog]);

      useEffect(() => {
        const service = createAnalysisService();
        serviceRef.current = service;

        const initializeWorker = async () => {
          try {
            await service.init();
            setIsInitialized(true);
            onLogPartial({ level: 'info', message: 'Analysis worker ready.' });
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            onLogPartial({ level: 'error', message: `Worker failed to initialize: ${message}` });
          }
        };

        initializeWorker();

        return () => {
          service.cleanup();
          serviceRef.current = null;
        };
      }, [onLogPartial]);

      const resetAnalysisState = useCallback(() => {
        setAnalysisResult(null);
        setAnalysisTime(null);
        setProgress(null);
        setTokenImpact(null);
        setLogs([]);
      }, []);

      const handleAnalyze = useCallback(async (filesInput: string, formattingOptions: FormattingOptions) => {
        if (!isInitialized || !serviceRef.current) {
          onLogPartial({ level: 'warn', message: 'Analysis worker not ready.' });
          return;
        }
        
        if (isLoading) {
          return; // Prevent multiple concurrent analyses
        }
        
        setIsLoading(true);
        resetAnalysisState();
        
        try {
          const { result, analysisTime, tokenImpact } = await serviceRef.current.analyze(
            filesInput,
            'debug',
            formattingOptions,
            setProgress,
            onLog
          );
          setAnalysisResult(result);
          setAnalysisTime(analysisTime);
          setTokenImpact(tokenImpact);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          if ((error as Error).name === 'AbortError') {
            onLogPartial({ level: 'warn', message: 'Analysis canceled by user.' });
          } else {
            onLogPartial({ level: 'error', message: `Analysis error: ${message}` });
          }
        } finally {
          setIsLoading(false);
          setProgress(null);
        }
      }, [isInitialized, isLoading, resetAnalysisState, onLog, onLogPartial]);

      const handleStop = useCallback(() => {
        if (isLoading && serviceRef.current) {
          serviceRef.current.cancel();
        }
      }, [isLoading]);

      return {
        isInitialized,
        isLoading,
        analysisResult,
        progress,
        logs,
        analysisTime,
        tokenImpact,
        handleAnalyze,
        handleStop,
        onLogPartial,
      };
    }
  packages/scn-ts-web-demo/src/worker.ts: >-
    import * as Comlink from 'comlink';

    import { initializeParser, analyzeProject, logger, calculateTokenImpact }
    from 'scn-ts-core';

    import type { FileContent, LogLevel, SourceFile, FormattingOptions,
    FormattingOptionsTokenImpact } from 'scn-ts-core';

    import type { LogEntry, ProgressData } from './types';


    function sanitizeAnalysisResult(result: SourceFile[]): SourceFile[] {
      // Sanitize the result to make it structured-clonable for Comlink.
      result.forEach(file => {
        delete file.ast;
        if (file.language) {
          // The language object on the source file is a reference to a global
          // singleton. We must clone it before deleting non-serializable properties,
          // otherwise the parser state is destroyed for subsequent analysis runs.
          const sanitizedLanguage = { ...file.language };
          delete sanitizedLanguage.parser;
          delete sanitizedLanguage.loadedLanguage;
          file.language = sanitizedLanguage;
        }
      });
      return result;
    }


    // Define the API the worker will expose

    function createWorkerApi() {
      let isInitialized = false;
      let abortController: AbortController | null = null;

      async function init() {
        if (isInitialized) return;
        await initializeParser({ wasmBaseUrl: '/wasm/' });
        isInitialized = true;
      }

      async function analyze(
        { filesInput, logLevel, formattingOptions }: { filesInput: string; logLevel: LogLevel, formattingOptions: FormattingOptions },
        onProgress: (progress: ProgressData) => void,
        onLog: (log: LogEntry) => void
      ): Promise<{ result: SourceFile[], analysisTime: number, tokenImpact: FormattingOptionsTokenImpact }> {
        if (!isInitialized) {
          throw new Error('Worker not initialized.');
        }

        abortController = new AbortController();

        logger.setLogHandler((level, ...args) => {
          const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
          onLog({ level, message, timestamp: Date.now() });
        });
        logger.setLevel(logLevel);

        try {
          let files: FileContent[] = [];
          try {
            files = JSON.parse(filesInput);
            if (!Array.isArray(files)) throw new Error("Input is not an array.");
          } catch (error) {
            throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
          }

          const { sourceFiles: analysisResult, analysisTime } = await analyzeProject({
            files,
            onProgress,
            logLevel,
            signal: abortController.signal,
          });

          const tokenImpact = calculateTokenImpact(analysisResult, formattingOptions);

          return { result: sanitizeAnalysisResult(analysisResult), analysisTime, tokenImpact };
        } finally {
          logger.setLogHandler(null);
          abortController = null;
        }
      }

      function cancel() {
        abortController?.abort();
      }
      
      return { init, analyze, cancel };
    }


    const workerApi = createWorkerApi();


    Comlink.expose(workerApi);


    export type WorkerApi = typeof workerApi;
  src/types.ts: >-
    import type { Parser, Tree, Language } from 'web-tree-sitter';

    import type { PathResolver } from './utils/tsconfig';

    export type { PathResolver };


    export type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'silent';


    export type LogHandler = (level: Exclude<LogLevel, 'silent'>, ...args:
    any[]) => void;


    export interface TsConfig {
        compilerOptions?: {
            baseUrl?: string;
            paths?: Record<string, string[]>;
        };
    }


    export interface AnalyzeProjectOptions {
        files: InputFile[];
        tsconfig?: TsConfig;
        root?: string;
        onProgress?: (progress: { percentage: number; message: string }) => void;
        logLevel?: LogLevel;
        signal?: AbortSignal;
    }


    export type FormattingPreset = 'minimal' | 'compact' | 'default' |
    'detailed' | 'verbose';


    /**
     * Options to control the SCN output format.
     */
    export interface FormattingOptions {
        preset?: FormattingPreset;
        showOutgoing?: boolean;
        showIncoming?: boolean;
        showIcons?: boolean;
        showExportedIndicator?: boolean; // + prefix
        showPrivateIndicator?: boolean; // - prefix
        showModifiers?: boolean; // ..., !, o
        showTags?: boolean;      // [generated], [styled], etc.
        showSymbolIds?: boolean; // (1.2) identifiers
        groupMembers?: boolean;  // group class/interface members under parent
        displayFilters?: Partial<Record<string, boolean>>;
        showFilePrefix?: boolean; // § prefix, defaults to true
        showFileIds?: boolean;    // (1) file identifiers in headers and references, defaults to true
        showOnlyExports?: boolean;
    }


    /**
     * Represents the token cost of toggling each formatting option.
     * The value is the delta when an option is toggled from its state in the `baseOptions`.
     * e.g. `new_token_count - base_token_count`.
     */
    export interface FormattingOptionsTokenImpact {
        options: Partial<{ [K in keyof Omit<FormattingOptions, 'displayFilters'>]: number }>;
        displayFilters: Partial<Record<string, number>>;
    }


    /**
     * Represents a file to be processed.
     */
    export interface InputFile {
      path: string; // relative path from root
      content: string;
    }


    /**
     * Configuration for the SCN generation process.
     */
    export interface ScnTsConfig {
      files: InputFile[];
      tsconfig?: TsConfig;
      formattingOptions?: FormattingOptions;
      root?: string; // Optional: A virtual root path for resolution. Defaults to '/'.
      _test_id?: string; // Special property for test runner to identify fixtures
    }


    /**
     * Options for initializing the Tree-sitter parser.
     */
    export interface ParserInitOptions {
        wasmBaseUrl: string;
    }


    /**
     * Represents a supported programming language and its configuration.
     */
    export type SymbolKind =
      // TS/JS
      | 'class' | 'interface' | 'function' | 'method' | 'constructor'
      | 'variable' | 'property' | 'enum' | 'enum_member' | 'type_alias' | 'module'
      | 'decorator' | 'parameter' | 'type_parameter' | 'import_specifier' | 're_export'
      // React
      | 'react_component' | 'react_hook' | 'react_hoc' | 'jsx_attribute' | 'jsx_element' | 'styled_component'
      // CSS
      | 'css_class' | 'css_id' | 'css_tag' | 'css_at_rule' | 'css_property' | 'css_variable'
      // Generic / Meta
      | 'file' | 'reference' | 'comment' | 'error' | 'unresolved'
      // Other Languages
      | 'go_package' | 'go_struct' | 'go_goroutine' | 'rust_struct' | 'rust_trait' | 'rust_impl' | 'rust_macro'
      | 'java_package' | 'python_class'
      | 'unknown';

    export interface Position {
      line: number;
      column: number;
    }


    export interface Range {
      start: Position;
      end: Position;
    }


    export interface CodeSymbol {
      id: string;
      fileId: number;
      name: string;
      kind: SymbolKind;
      range: Range;
      // Modifiers and metadata
      isExported: boolean;
      isAbstract?: boolean;
      isStatic?: boolean;
      isReadonly?: boolean;
      isAsync?: boolean;
      isPure?: boolean; // for 'o'
      throws?: boolean; // for '!'
      labels?: string[]; // extra display labels like [symbol], [proxy]
      isGenerated?: boolean;
      languageDirectives?: string[]; // e.g. 'use server'
      superClass?: string;
      implementedInterfaces?: string[];
      scopeRange: Range; // The range of the entire scope (e.g., function body) for relationship association
      accessibility?: 'public' | 'private' | 'protected';
      // Type information and signatures
      signature?: string; // e.g., (a: #number, b: #number): #number
      typeAnnotation?: string; // e.g., #string for properties/variables
      typeAliasValue?: string; // e.g., #number|string for type aliases
      // Relationships
      dependencies: Relationship[];
    }


    export type RelationshipKind =
      | 'import'
      | 'dynamic_import'
      | 'reference'
      | 'tagged'
      | 'export'
      | 'call'
      | 'extends'
      | 'implements'
      | 'references'
      | 'aliased'
      | 'goroutine'
      | 'macro';

    export interface Relationship {
      targetName: string; // The raw name of the target (e.g., './utils', 'MyClass', 'add', 'Button')
      kind: RelationshipKind;
      range: Range;
      // Resolved info
      resolvedFileId?: number;
      resolvedSymbolId?: string;
    }


    export interface SourceFile {
      id: number;
      relativePath: string;
      absolutePath: string;
      language: LanguageConfig;
      sourceCode: string;
      ast?: Tree;
      symbols: CodeSymbol[];
      parseError: boolean;
      isGenerated?: boolean;
      languageDirectives?: string[];
      // File-level relationships (e.g., imports not tied to a specific symbol)
      fileRelationships?: Relationship[];
    }


    /**
     * Represents a supported programming language and its configuration.
     */
    export interface LanguageConfig {
        id: string;
        name: string;
        extensions: string[];
        wasmPath: string;
        parser?: Parser;
        loadedLanguage?: Language;
        queries?: Record<string, string>;
    }


    export interface AnalysisContext {
        sourceFiles: SourceFile[];
        pathResolver: PathResolver;
    }
  src/main.ts: >-
    import { getLanguageForFile } from './languages';

    import { initializeParser as init, parse } from './parser';

    import type { ParserInitOptions, SourceFile, InputFile, ScnTsConfig,
    AnalyzeProjectOptions, FormattingOptions, FormattingOptionsTokenImpact,
    SymbolKind } from './types';

    import { analyze } from './analyzer';

    import { formatScn } from './formatter';

    import path from './utils/path';

    import { getPathResolver } from './utils/tsconfig';

    import { resolveGraph } from './graph-resolver';

    import { logger } from './logger';

    import { initializeTokenizer as initTokenizer, countTokens as
    countTokensInternal } from './tokenizer';


    import type { FormattingPreset } from './types';


    /**
     * Public API to initialize the parser. Must be called before any other APIs.
     */
    export const initializeParser = (options: ParserInitOptions): Promise<void>
    => init(options);


    /**
     * Initializes the tokenizer. Call this for consistency, although `countTokens` will auto-initialize on first use.
     * It's a synchronous and lightweight operation.
     */
    export const initializeTokenizer = (): boolean => initTokenizer();


    // Types for web demo

    export type { ParserInitOptions, SourceFile, LogLevel, InputFile, TsConfig,
    ScnTsConfig, AnalyzeProjectOptions, LogHandler, FormattingOptions,
    FormattingPreset, FormattingOptionsTokenImpact, CodeSymbol, SymbolKind }
    from './types';

    export type FileContent = InputFile;


    // Exports for web demo. The constants are exported from index.ts directly.

    export { logger };


    const defaultFormattingOptions: Omit<FormattingOptions, 'preset'> = {
      showOutgoing: true,
      showIncoming: true,
      showIcons: true,
      showExportedIndicator: true,
      showPrivateIndicator: true,
      showModifiers: true,
      showTags: true,
      showSymbolIds: true,
      groupMembers: true,
      displayFilters: {},
      showFilePrefix: true,
      showFileIds: true,
      showOnlyExports: false,
    };


    export function getFormattingOptionsForPreset(preset: FormattingPreset):
    FormattingOptions {
      switch (preset) {
        case 'minimal':
          return {
            preset: 'minimal',
            ...defaultFormattingOptions,
            showIcons: false,
            showExportedIndicator: false,
            showPrivateIndicator: false,
            showModifiers: false,
            showTags: false,
            showSymbolIds: false,
            groupMembers: false,
            displayFilters: { '*': false },
          };
        case 'compact':
          return {
            preset: 'compact',
            ...defaultFormattingOptions,
            showPrivateIndicator: false,
            showModifiers: false,
            showTags: false,
            showSymbolIds: false,
            displayFilters: {
              'property': false,
              'method': false,
              'constructor': false,
              'enum_member': false,
              'import_specifier': false,
            },
            showOnlyExports: true,
          };
        case 'detailed':
          return {
            preset: 'detailed',
            ...defaultFormattingOptions,
            groupMembers: false,
          };
        case 'verbose':
          return {
            preset: 'verbose',
            ...defaultFormattingOptions,
            groupMembers: false,
            displayFilters: { '*': true },
          };
        case 'default':
        default:
          return {
            preset: 'default',
            ...defaultFormattingOptions,
          };
      }
    }


    /**
     * Counts tokens in a string using the cl100k_base model.
     */
    export const countTokens = (text: string): number =>
    countTokensInternal(text);


    /**
     * Generate SCN from analyzed source files
     */
    export const generateScn = (analyzedFiles: SourceFile[], options:
    FormattingOptions = {}): string => {
        const formattingOptions = options.preset
            ? { ...getFormattingOptionsForPreset(options.preset), ...options }
            : options;
        return formatScn(analyzedFiles, formattingOptions);
    };


    /**
     * Calculates the token impact of toggling each formatting option.
     * This can be slow as it re-generates the SCN for each option.
     * @param analyzedFiles The result from `analyzeProject`.
     * @param baseOptions The formatting options to calculate deltas from.
     * @returns An object detailing the token change for toggling each option.
     */
    export const calculateTokenImpact = (
        analyzedFiles: SourceFile[],
        baseOptions: FormattingOptions
    ): FormattingOptionsTokenImpact => {
        logger.debug('Calculating token impact...');
        const startTime = performance.now();

        const resolvedBaseOptions = baseOptions.preset
            ? { ...getFormattingOptionsForPreset(baseOptions.preset), ...baseOptions }
            : baseOptions;

        const baseScn = formatScn(analyzedFiles, resolvedBaseOptions);
        const baseTokens = countTokensInternal(baseScn);

        const impact: FormattingOptionsTokenImpact = {
            options: {},
            displayFilters: {},
        };

        const simpleOptionKeys: Array<keyof Omit<FormattingOptions, 'displayFilters'>> = [
            'showOutgoing', 'showIncoming', 'showIcons', 'showExportedIndicator',
            'showPrivateIndicator', 'showModifiers', 'showTags', 'showSymbolIds',
            'groupMembers', 'showFilePrefix', 'showFileIds'
        ];

        for (const key of simpleOptionKeys) {
            // All boolean options default to true.
            const currentValue = resolvedBaseOptions[key] ?? true;
            const newOptions = { ...resolvedBaseOptions, [key]: !currentValue };
            const newScn = formatScn(analyzedFiles, newOptions);
            const newTokens = countTokensInternal(newScn);
            impact.options[key] = newTokens - baseTokens;
        }

        const allSymbolKinds = new Set<SymbolKind>(analyzedFiles.flatMap(file => file.symbols.map(s => s.kind)));

        for (const kind of allSymbolKinds) {
            const currentFilterValue = resolvedBaseOptions.displayFilters?.[kind] ?? true;
            const newOptions = {
                ...resolvedBaseOptions,
                displayFilters: { ...(resolvedBaseOptions.displayFilters ?? {}), [kind]: !currentFilterValue }
            };
            const newScn = formatScn(analyzedFiles, newOptions);
            const newTokens = countTokensInternal(newScn);
            impact.displayFilters[kind] = newTokens - baseTokens;
        }

        const duration = performance.now() - startTime;
        logger.debug(`Token impact calculation finished in ${duration.toFixed(2)}ms`);

        return impact;
    };


    /**
     * Legacy API: Generate SCN from config (for backward compatibility)
     */
    export const generateScnFromConfig = async (config: ScnTsConfig):
    Promise<string> => {
        const { sourceFiles: analyzedFiles } = await analyzeProject({
            files: config.files,
            tsconfig: config.tsconfig,
            root: config.root,
        });
        return formatScn(analyzedFiles, config.formattingOptions);
    };


    /**
     * Parses and analyzes a project's files to build a dependency graph.
     */
    export const analyzeProject = async (
        {
            files,
            tsconfig,
            root = '/',
            onProgress,
            logLevel,
            signal,
        }: AnalyzeProjectOptions
    ): Promise<{ sourceFiles: SourceFile[], analysisTime: number }> => {
        const startTime = performance.now();
        if (logLevel) {
            logger.setLevel(logLevel);
        }
        logger.info(`Starting analysis of ${files.length} files...`);
        const pathResolver = getPathResolver(tsconfig);

        const checkAborted = () => { if (signal?.aborted) throw new DOMException('Aborted', 'AbortError'); };
        let fileIdCounter = 1;

        onProgress?.({ percentage: 0, message: 'Creating source files...' });

        // Step 1: Create SourceFile objects for all files
        const sourceFiles = files.map((file) => {
            checkAborted();
            const absolutePath = path.join(root, file.path);
            const sourceFile: SourceFile = {
                id: fileIdCounter++,
                relativePath: file.path,
                absolutePath,
                sourceCode: file.content,
                language: getLanguageForFile(file.path)!,
                symbols: [],
                parseError: false,
            };
            return sourceFile;
        });

        logger.debug(`Created ${sourceFiles.length} SourceFile objects.`);
        onProgress?.({ percentage: 10, message: `Parsing ${sourceFiles.length} files...` });

        // Step 2: Parse all files
        const parsedFiles = sourceFiles.map((file, i) => {
            checkAborted();
            if (!file.language || !file.language.wasmPath || file.sourceCode.trim() === '') {
                return file;
            }
            logger.debug(`Parsing ${file.relativePath}`);
            const tree = parse(file.sourceCode, file.language);
            if (!tree) {
                file.parseError = true;
                logger.warn(`Failed to parse ${file.relativePath}`);
            } else {
                file.ast = tree;
            }
            const percentage = 10 + (40 * (i + 1) / sourceFiles.length);
            onProgress?.({ percentage, message: `Parsing ${file.relativePath}` });
            return file;
        });

        onProgress?.({ percentage: 50, message: 'Analyzing files...' });
        logger.info(`Parsing complete. Analyzing symbols and relationships...`);

        // Step 3: Analyze all parsed files
        const analyzedFiles = parsedFiles.map((file, i) => {
            checkAborted();
            if (file.ast) {
                logger.debug(`Analyzing ${file.relativePath}`);
                const analyzed = analyze(file);
                const percentage = 50 + (40 * (i + 1) / sourceFiles.length);
                onProgress?.({ percentage, message: `Analyzing ${file.relativePath}` });
                return analyzed;
            }
            return file;
        });
        
        onProgress?.({ percentage: 90, message: 'Resolving dependency graph...' });
        logger.info('Analysis complete. Resolving dependency graph...');

        // Step 4: Resolve the dependency graph across all files
        checkAborted();
        const resolvedGraph = resolveGraph(analyzedFiles, pathResolver, root);
        
        onProgress?.({ percentage: 100, message: 'Analysis complete.' });
        logger.info('Graph resolution complete. Project analysis finished.');
        const analysisTime = performance.now() - startTime;
        return { sourceFiles: resolvedGraph, analysisTime };
    };
approved: false
