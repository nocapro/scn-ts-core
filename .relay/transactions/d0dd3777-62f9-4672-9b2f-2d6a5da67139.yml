uuid: d0dd3777-62f9-4672-9b2f-2d6a5da67139
projectId: scn-ts-core
createdAt: '2025-09-04T17:11:15.387Z'
linesAdded: 80
linesRemoved: 28
gitCommitMsg: 'feat: add formatting options to control SCN relationship visibility'
promptSummary: >-
  The user wants to add granular controls to the SCN output to manage token
  usage, specifically by showing or hiding incoming and outgoing relationships.
  This requires changes to the core library's formatter and exposing these
  options through the API to the web demo UI.
reasoning:
  - >-
    yoooo, heard you wanted to slim down that SCN output. tokens are expensive,
    i get it. i've wired up some options to give you more control over what gets
    printed. you can now toggle incoming/outgoing relationships. this is all
    plumbed through from the core library to the web demo, with some shiny new
    checkboxes to play with.
  - let's get this shipped.
  - >-
    First, I'll define the new formatting options in our types. This will be the
    contract for controlling the SCN output.
  - >-
    Next, I'll update the main API functions in `src/main.ts` to accept these
    new options and pass them along to the formatter. I'll also export the new
    `FormattingOptions` type for our web demo to use.
  - >-
    Now for the core logic in `src/formatter.ts`. I'll update the formatting
    functions to conditionally include or exclude relationship lines based on
    the provided options. This is where we actually cut down on the tokens.
  - >-
    Finally, I'll hook this up to the web demo UI. I'm adding state to hold the
    analysis results and formatting options, and a `useEffect` to regenerate the
    SCN instantly when the checkboxes are toggled. This makes the experience
    super responsive.
  - '---'
operations:
  - type: write
    path: src/types.ts
    content: |-
      --- src/types.ts
      +++ src/types.ts
      @@ -16,6 +16,15 @@
           logLevel?: LogLevel;
       }
       
      +/**
      + * Options to control the SCN output format.
      + */
      +export interface FormattingOptions {
      +    showOutgoing?: boolean; // default true
      +    showIncoming?: boolean; // default true
      +}
      +
       /**
        * Represents a file to be processed.
        */
      @@ -28,6 +37,7 @@
       export interface ScnTsConfig {
         files: InputFile[];
         tsconfig?: TsConfig;
      +  formattingOptions?: FormattingOptions;
         root?: string; // Optional: A virtual root path for resolution. Defaults to '/'.
         _test_id?: string; // Special property for test runner to identify fixtures
       }
    patchStrategy: new-unified
  - type: write
    path: src/main.ts
    content: >-
      --- src/main.ts

      +++ src/main.ts

      @@ -1,5 +1,5 @@
       import { getLanguageForFile } from './languages';
       import { initializeParser as init, parse } from './parser';
      -import type { ParserInitOptions, SourceFile, InputFile, ScnTsConfig,
      AnalyzeProjectOptions } from './types';

      +import type { ParserInitOptions, SourceFile, InputFile, ScnTsConfig,
      AnalyzeProjectOptions, FormattingOptions } from './types';
       import { analyze } from './analyzer';
       import { formatScn } from './formatter';
       import path from './utils/path';
      @@ -12,24 +12,25 @@
       export const initializeParser = (options: ParserInitOptions): Promise<void> => init(options);
       
       // Types for web demo
      -export type { ParserInitOptions, SourceFile, LogLevel, InputFile,
      TsConfig, ScnTsConfig, AnalyzeProjectOptions, LogHandler } from './types';

      +export type { ParserInitOptions, SourceFile, LogLevel, InputFile,
      TsConfig, ScnTsConfig, AnalyzeProjectOptions, LogHandler,
      FormattingOptions } from './types';
       export type FileContent = InputFile;
       
       // Exports for web demo
       export { logger };
       
       /**
        * Generate SCN from analyzed source files
        */
      -export const generateScn = (analyzedFiles: SourceFile[]): string => {

      -    return formatScn(analyzedFiles);

      +export const generateScn = (analyzedFiles: SourceFile[], options?:
      FormattingOptions): string => {

      +    return formatScn(analyzedFiles, options);
       };
       
       /**
        * Legacy API: Generate SCN from config (for backward compatibility)
        */
       export const generateScnFromConfig = async (config: ScnTsConfig): Promise<string> => {
           const analyzedFiles = await analyzeProject({
               files: config.files,
               tsconfig: config.tsconfig,
      -        root: config.root

      +        root: config.root,
           });
      -    return formatScn(analyzedFiles);

      +    return formatScn(analyzedFiles, config.formattingOptions);
       };
       
       /**
    patchStrategy: new-unified
  - type: write
    path: src/formatter.ts
    content: >-
      --- src/formatter.ts

      +++ src/formatter.ts

      @@ -1,4 +1,4 @@

      -import type { CodeSymbol, SourceFile } from './types';

      +import type { CodeSymbol, SourceFile, FormattingOptions } from './types';
       import { topologicalSort } from './utils/graph';
       import { ICONS, SCN_SYMBOLS } from './constants';
       
      @@ -20,7 +20,7 @@
           return `(${file.id}.${idx})`;
       };
       
      -const formatSymbol = (symbol: CodeSymbol, allFiles: SourceFile[]):
      string[] => {

      +const formatSymbol = (symbol: CodeSymbol, allFiles: SourceFile[],
      options: FormattingOptions): string[] => {
           let icon = ICONS[symbol.kind] || ICONS.default || '?';
           const prefix = symbol.isExported ? SCN_SYMBOLS.EXPORTED_PREFIX : SCN_SYMBOLS.PRIVATE_PREFIX;
           let name = symbol.name === '<anonymous>' ? '' : symbol.name;
      @@ -62,6 +62,8 @@
           const line = `  ${segments.filter(Boolean).join(' ')}`;
           const result = [line];
       
      +    const { showOutgoing = true, showIncoming = true } = options;

      +
           const outgoing = new Map<number, Set<string>>();
           const unresolvedDeps: string[] = [];
           symbol.dependencies.forEach(dep => {
      @@ -98,10 +100,12 @@
           }
           outgoingParts.push(...unresolvedDeps);
       
      -    if (outgoingParts.length > 0) {

      +    if (showOutgoing && outgoingParts.length > 0) {
               result.push(`    ${SCN_SYMBOLS.OUTGOING_ARROW} ${outgoingParts.join(', ')}`);
           }
           
      +    if (!showIncoming) return result;

      +
           const incoming = new Map<number, Set<string>>();
           allFiles.forEach(file => {
               file.symbols.forEach(s => {
      @@ -165,7 +169,7 @@
           return map;
       };
       
      -const formatFile = (file: SourceFile, allFiles: SourceFile[]): string =>
      {

      +const formatFile = (file: SourceFile, allFiles: SourceFile[], options:
      FormattingOptions): string => {
           if (file.parseError) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath} [error]`;
           if (!file.sourceCode.trim()) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath}`;
       
      @@ -177,6 +181,8 @@
           const header = `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath}${directiveStr}`;
       
           const headerLines: string[] = [header];
      +

      +    const { showOutgoing = true, showIncoming = true } = options;
       
           // File-level outgoing/incoming dependencies
           const outgoing: string[] = [];
      @@ -190,21 +196,23 @@
                       outgoing.push(text);
                   }
               });
      -        if (outgoing.length > 0) headerLines.push(` 
      ${SCN_SYMBOLS.OUTGOING_ARROW} ${Array.from(new
      Set(outgoing)).sort().join(', ')}`);

      +        if (showOutgoing && outgoing.length > 0) {

      +            headerLines.push(`  ${SCN_SYMBOLS.OUTGOING_ARROW}
      ${Array.from(new Set(outgoing)).sort().join(', ')}`);

      +        }
           }
       
           // Incoming: any other file that has a file-level relationship pointing here
           const incoming: string[] = [];
      -    allFiles.forEach(other => {

      -        if (other.id === file.id) return;

      -        other.fileRelationships?.forEach(rel => {

      -            if (rel.resolvedFileId === file.id)
      incoming.push(`(${other.id}.0)`);

      +    if (showIncoming) {

      +        allFiles.forEach(other => {

      +            if (other.id === file.id) return;

      +            other.fileRelationships?.forEach(rel => {

      +                if (rel.resolvedFileId === file.id)
      incoming.push(`(${other.id}.0)`);

      +            });
               });
      -    });

      -    if (incoming.length > 0) headerLines.push(` 
      ${SCN_SYMBOLS.INCOMING_ARROW} ${Array.from(new
      Set(incoming)).sort().join(', ')}`);

      -

      +        if (incoming.length > 0) headerLines.push(` 
      ${SCN_SYMBOLS.INCOMING_ARROW} ${Array.from(new
      Set(incoming)).sort().join(', ')}`);

      +    }
           // If file has no exported symbols, only show symbols that are "entry points" for analysis,
           // which we define as having outgoing dependencies.
           const hasExports = file.symbols.some(s => s.isExported);
      @@ -219,12 +227,12 @@
       
           const symbolLines: string[] = [];
           for (const sym of topLevel) {
      -        const lines = formatSymbol(sym, allFiles);

      +        const lines = formatSymbol(sym, allFiles, options);
               symbolLines.push(...lines);
               if (childrenMap.has(sym.id)) {
                   const kids = childrenMap.get(sym.id)!;
                   for (const kid of kids) {
      -                const kLines = formatSymbol(kid, allFiles).map(l => ` 
      ${l}`);

      +                const kLines = formatSymbol(kid, allFiles, options).map(l
      => `  ${l}`);
                       symbolLines.push(...kLines);
                   }
               }
      @@ -232,7 +240,7 @@
       
           // If we hid symbols (or there were none to begin with for an entry file),
           // aggregate outgoing dependencies from all symbols onto the file header
      -    if (symbolsToPrint.length === 0) {

      +    if (showOutgoing && symbolsToPrint.length === 0) {
               const aggOutgoing = new Map<number, Set<string>>();
               const unresolvedDeps: string[] = [];
       
      @@ -276,9 +284,9 @@
           return [...headerLines, ...symbolLines].join('\n');
       };
       
      -export const formatScn = (analyzedFiles: SourceFile[]): string => {

      +export const formatScn = (analyzedFiles: SourceFile[], options:
      FormattingOptions = {}): string => {
           const sortedFiles = topologicalSort(analyzedFiles);
      -    return sortedFiles.map(file => formatFile(file,
      analyzedFiles)).join('\n\n');

      -};

      +    return sortedFiles.map(file => formatFile(file, analyzedFiles,
      options)).join('\n\n');

      +};
    patchStrategy: new-unified
  - type: write
    path: packages/scn-ts-web-demo/src/App.tsx
    content: >-
      --- packages/scn-ts-web-demo/src/App.tsx

      +++ packages/scn-ts-web-demo/src/App.tsx

      @@ -5,17 +5,23 @@
         analyzeProject,
         generateScn,
       } from '../../../index';
      -import type { FileContent, LogHandler } from '../../../index';

      +import type { FileContent, LogHandler, SourceFile, FormattingOptions }
      from '../../../index';
       import { defaultFilesJSON } from './default-files';
       import { Button } from './components/ui/button';
       import { Card, CardContent, CardHeader, CardTitle } from './components/ui/card';
       import { Textarea } from './components/ui/textarea';
       import LogViewer from './components/LogViewer';
       import { Play, Loader } from 'lucide-react';
       import type { LogEntry, ProgressData } from './types';
       
       function App() {
         const [isInitialized, setIsInitialized] = useState(false);
         const [isLoading, setIsLoading] = useState(false);
         const [filesInput, setFilesInput] = useState(defaultFilesJSON);
         const [scnOutput, setScnOutput] = useState('');
      +  const [analysisResult, setAnalysisResult] = useState<SourceFile[] |
      null>(null);

      +  const [formattingOptions, setFormattingOptions] =
      useState<FormattingOptions>({

      +    showOutgoing: true,

      +    showIncoming: true,

      +  });
         const [progress, setProgress] = useState<ProgressData | null>(null);
         const [logs, setLogs] = useState<LogEntry[]>([]);
         const [encoder, setEncoder] = useState<Tiktoken | null>(null);
      @@ -53,6 +59,13 @@
           }
         }, [filesInput, scnOutput, encoder]);
       
      +  useEffect(() => {

      +    if (analysisResult) {

      +      const scn = generateScn(analysisResult, formattingOptions);

      +      setScnOutput(scn);

      +    }

      +  }, [analysisResult, formattingOptions]);

      +
         const handleAnalyze = useCallback(async () => {
           if (!isInitialized) {
             setLogs(prev => [...prev, { level: 'warn', message: 'Parser not ready.', timestamp: Date.now() }]);
      @@ -62,6 +75,7 @@
           setIsLoading(true);
           setLogs([]);
           setScnOutput('');
      +    setAnalysisResult(null);
           setProgress(null);
       
           const logHandler: LogHandler = (level, ...args) => {
      @@ -84,8 +98,7 @@
             }
       
             const rankedGraph = await analyzeProject({ files, onProgress, logLevel: 'debug' });
      -      const scn = generateScn(rankedGraph);

      -      setScnOutput(scn);

      +      setAnalysisResult(rankedGraph);
             logger.info('Analysis complete.');
           } catch (error) {
             const message = error instanceof Error ? error.message : String(error);
      @@ -134,8 +147,30 @@
               <Card className="flex flex-col overflow-hidden">
                 <CardHeader>
                   <CardTitle className="flex justify-between items-center">
      -              <span>Output (SCN)</span>

      -              <span className="text-sm font-normal
      text-muted-foreground">{tokenCounts.output.toLocaleString()} tokens</span>

      +              <span className="whitespace-nowrap">Output (SCN)</span>

      +              <div className="flex items-center space-x-4 text-sm
      font-normal text-muted-foreground w-full justify-end">

      +                <div className="flex items-center space-x-1.5">

      +                  <input

      +                    type="checkbox"

      +                    id="showOutgoing"

      +                    checked={formattingOptions.showOutgoing}

      +                    onChange={(e) => setFormattingOptions(prev => ({
      ...prev, showOutgoing: e.target.checked }))}

      +                    className="h-4 w-4 rounded border-muted-foreground/50
      bg-transparent text-primary focus:ring-primary"

      +                  />

      +                  <label htmlFor="showOutgoing" className="cursor-pointer
      select-none">Outgoing</label>

      +                </div>

      +                <div className="flex items-center space-x-1.5">

      +                  <input

      +                    type="checkbox"

      +                    id="showIncoming"

      +                    checked={formattingOptions.showIncoming}

      +                    onChange={(e) => setFormattingOptions(prev => ({
      ...prev, showIncoming: e.target.checked }))}

      +                    className="h-4 w-4 rounded border-muted-foreground/50
      bg-transparent text-primary focus:ring-primary"

      +                  />

      +                  <label htmlFor="showIncoming" className="cursor-pointer
      select-none">Incoming</label>

      +                </div>

      +                <span className="text-right tabular-nums
      w-24">{tokenCounts.output.toLocaleString()} tokens</span>

      +              </div>
                   </CardTitle>
                 </CardHeader>
                 <CardContent className="flex-grow overflow-auto">
    patchStrategy: new-unified
snapshot:
  src/types.ts: >-
    import type { Parser, Tree, Language } from 'web-tree-sitter';

    import type { PathResolver } from './utils/tsconfig';

    export type { PathResolver };


    export type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'silent';


    export type LogHandler = (level: Exclude<LogLevel, 'silent'>, ...args:
    any[]) => void;


    export interface TsConfig {
        compilerOptions?: {
            baseUrl?: string;
            paths?: Record<string, string[]>;
        };
    }


    export interface AnalyzeProjectOptions {
        files: InputFile[];
        tsconfig?: TsConfig;
        root?: string;
        onProgress?: (progress: { percentage: number; message: string }) => void;
        logLevel?: LogLevel;
    }


    /**
     * Represents a file to be processed.
     */
    export interface InputFile {
      path: string; // relative path from root
      content: string;
    }


    /**
     * Configuration for the SCN generation process.
     */
    export interface ScnTsConfig {
      files: InputFile[];
      tsconfig?: TsConfig;
      root?: string; // Optional: A virtual root path for resolution. Defaults to '/'.
      _test_id?: string; // Special property for test runner to identify fixtures
    }


    /**
     * Options for initializing the Tree-sitter parser.
     */
    export interface ParserInitOptions {
        wasmBaseUrl: string;
    }


    /**
     * Represents a supported programming language and its configuration.
     */
    export type SymbolKind =
      // TS/JS
      | 'class' | 'interface' | 'function' | 'method' | 'constructor'
      | 'variable' | 'property' | 'enum' | 'enum_member' | 'type_alias' | 'module'
      | 'decorator' | 'parameter' | 'type_parameter' | 'import_specifier' | 're_export'
      // React
      | 'react_component' | 'react_hook' | 'react_hoc' | 'jsx_attribute' | 'jsx_element' | 'styled_component'
      // CSS
      | 'css_class' | 'css_id' | 'css_tag' | 'css_at_rule' | 'css_property' | 'css_variable'
      // Generic / Meta
      | 'file' | 'reference' | 'comment' | 'error' | 'unresolved'
      // Other Languages
      | 'go_package' | 'go_struct' | 'go_goroutine' | 'rust_struct' | 'rust_trait' | 'rust_impl' | 'rust_macro'
      | 'java_package' | 'python_class'
      | 'unknown';

    export interface Position {
      line: number;
      column: number;
    }


    export interface Range {
      start: Position;
      end: Position;
    }


    export interface CodeSymbol {
      id: string;
      fileId: number;
      name: string;
      kind: SymbolKind;
      range: Range;
      // Modifiers and metadata
      isExported: boolean;
      isAbstract?: boolean;
      isStatic?: boolean;
      isReadonly?: boolean;
      isAsync?: boolean;
      isPure?: boolean; // for 'o'
      throws?: boolean; // for '!'
      labels?: string[]; // extra display labels like [symbol], [proxy]
      isGenerated?: boolean;
      languageDirectives?: string[]; // e.g. 'use server'
      superClass?: string;
      implementedInterfaces?: string[];
      scopeRange: Range; // The range of the entire scope (e.g., function body) for relationship association
      accessibility?: 'public' | 'private' | 'protected';
      // Type information and signatures
      signature?: string; // e.g., (a: #number, b: #number): #number
      typeAnnotation?: string; // e.g., #string for properties/variables
      typeAliasValue?: string; // e.g., #number|string for type aliases
      // Relationships
      dependencies: Relationship[];
    }


    export type RelationshipKind =
      | 'import'
      | 'dynamic_import'
      | 'reference'
      | 'tagged'
      | 'export'
      | 'call'
      | 'extends'
      | 'implements'
      | 'references'
      | 'aliased'
      | 'goroutine'
      | 'macro';

    export interface Relationship {
      targetName: string; // The raw name of the target (e.g., './utils', 'MyClass', 'add', 'Button')
      kind: RelationshipKind;
      range: Range;
      // Resolved info
      resolvedFileId?: number;
      resolvedSymbolId?: string;
    }


    export interface SourceFile {
      id: number;
      relativePath: string;
      absolutePath: string;
      language: LanguageConfig;
      sourceCode: string;
      ast?: Tree;
      symbols: CodeSymbol[];
      parseError: boolean;
      isGenerated?: boolean;
      languageDirectives?: string[];
      // File-level relationships (e.g., imports not tied to a specific symbol)
      fileRelationships?: Relationship[];
    }


    /**
     * Represents a supported programming language and its configuration.
     */
    export interface LanguageConfig {
        id: string;
        name: string;
        extensions: string[];
        wasmPath: string;
        parser?: Parser;
        loadedLanguage?: Language;
        queries?: Record<string, string>;
    }


    export interface AnalysisContext {
        sourceFiles: SourceFile[];
        pathResolver: PathResolver;
    }
  src/main.ts: >-
    import { getLanguageForFile } from './languages';

    import { initializeParser as init, parse } from './parser';

    import type { ParserInitOptions, SourceFile, InputFile, ScnTsConfig,
    AnalyzeProjectOptions } from './types';

    import { analyze } from './analyzer';

    import { formatScn } from './formatter';

    import path from './utils/path';

    import { getPathResolver } from './utils/tsconfig';

    import { resolveGraph } from './graph-resolver';

    import { logger } from './logger';


    /**
     * Public API to initialize the parser. Must be called before any other APIs.
     */
    export const initializeParser = (options: ParserInitOptions): Promise<void>
    => init(options);


    // Types for web demo

    export type { ParserInitOptions, SourceFile, LogLevel, InputFile, TsConfig,
    ScnTsConfig, AnalyzeProjectOptions, LogHandler } from './types';

    export type FileContent = InputFile;


    // Exports for web demo

    export { logger };


    /**
     * Generate SCN from analyzed source files
     */
    export const generateScn = (analyzedFiles: SourceFile[]): string => {
        return formatScn(analyzedFiles);
    };


    /**
     * Legacy API: Generate SCN from config (for backward compatibility)
     */
    export const generateScnFromConfig = async (config: ScnTsConfig):
    Promise<string> => {
        const analyzedFiles = await analyzeProject({
            files: config.files,
            tsconfig: config.tsconfig,
            root: config.root
        });
        return formatScn(analyzedFiles);
    };


    /**
     * Parses and analyzes a project's files to build a dependency graph.
     */
    export const analyzeProject = async ({
        files,
        tsconfig,
        root = '/',
        onProgress,
        logLevel
    }: AnalyzeProjectOptions): Promise<SourceFile[]> => {
        if (logLevel) {
            logger.setLevel(logLevel);
        }
        const pathResolver = getPathResolver(tsconfig);

        let fileIdCounter = 1;

        onProgress?.({ percentage: 0, message: 'Creating source files...' });
        logger.debug('Creating source files...');

        // Step 1: Create SourceFile objects for all files
        const sourceFiles = files.map((file) => {
            const lang = getLanguageForFile(file.path);
            const absolutePath = path.join(root, file.path);
            const sourceFile: SourceFile = {
                id: fileIdCounter++,
                relativePath: file.path,
                absolutePath,
                sourceCode: file.content,
                language: lang!,
                symbols: [],
                parseError: false,
            };
            return sourceFile;
        });

        onProgress?.({ percentage: 10, message: `Parsing ${sourceFiles.length} files...` });
        logger.debug(`Parsing ${sourceFiles.length} files...`);

        // Step 2: Parse all files
        const parsedFiles = sourceFiles.map((file, i) => {
            if (!file.language || !file.language.wasmPath || file.sourceCode.trim() === '') {
                return file;
            }
            const tree = parse(file.sourceCode, file.language);
            if (!tree) {
                file.parseError = true;
                logger.warn(`Failed to parse ${file.relativePath}`);
            } else {
                file.ast = tree;
            }
            const percentage = 10 + (40 * (i + 1) / sourceFiles.length);
            onProgress?.({ percentage, message: `Parsing ${file.relativePath}` });
            logger.debug(`[${Math.round(percentage)}%] Parsed ${file.relativePath}`);
            return file;
        });

        onProgress?.({ percentage: 50, message: 'Analyzing files...' });
        logger.debug('Analyzing files...');

        // Step 3: Analyze all parsed files
        const analyzedFiles = parsedFiles.map((file, i) => {
            if (file.ast) {
                const analyzed = analyze(file);
                const percentage = 50 + (40 * (i + 1) / sourceFiles.length);
                onProgress?.({ percentage, message: `Analyzing ${file.relativePath}` });
                logger.debug(`[${Math.round(percentage)}%] Analyzed ${file.relativePath}`);
                return analyzed;
            }
            return file;
        });
        
        onProgress?.({ percentage: 90, message: 'Resolving dependency graph...' });
        logger.debug('Resolving dependency graph...');

        // Step 4: Resolve the dependency graph across all files
        const resolvedGraph = resolveGraph(analyzedFiles, pathResolver, root);
        
        onProgress?.({ percentage: 100, message: 'Analysis complete.' });
        logger.debug('Analysis complete.');
        return resolvedGraph;
    };
  src/formatter.ts: >-
    import type { CodeSymbol, SourceFile } from './types';

    import { topologicalSort } from './utils/graph';

    import { ICONS, SCN_SYMBOLS } from './constants';


    // Compute display index per file based on eligible symbols (exclude
    properties and constructors)

    const isIdEligible = (symbol: CodeSymbol): boolean => {
        if (symbol.kind === 'property' || symbol.kind === 'constructor') return false;
        if (symbol.kind === 'variable') return symbol.isExported || symbol.name === 'module.exports' || symbol.name === 'default';
        if (symbol.kind === 'method') return !!symbol.isExported;
        return true;
    };


    const getDisplayIndex = (file: SourceFile, symbol: CodeSymbol): number |
    null => {
        const ordered = file.symbols
            .filter(isIdEligible)
            .sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);
        const index = ordered.findIndex(s => s === symbol);
        return index === -1 ? null : index + 1;
    };


    const formatSymbolIdDisplay = (file: SourceFile, symbol: CodeSymbol): string
    | null => {
        const idx = getDisplayIndex(file, symbol);
        if (idx == null) return null;
        return `(${file.id}.${idx})`;
    };


    const formatSymbol = (symbol: CodeSymbol, allFiles: SourceFile[]): string[]
    => {
        let icon = ICONS[symbol.kind] || ICONS.default || '?';
        const prefix = symbol.isExported ? SCN_SYMBOLS.EXPORTED_PREFIX : SCN_SYMBOLS.PRIVATE_PREFIX;
        let name = symbol.name === '<anonymous>' ? '' : symbol.name;
        if (symbol.kind === 'variable' && name.trim() === 'default') name = '';
        
        // Handle styled components: ~div ComponentName, ~h1 ComponentName, etc.
        if (symbol.kind === 'styled_component' && (symbol as any)._styledTag) {
            const tagName = (symbol as any)._styledTag;
            icon = `~${tagName}`;
        }

        const mods: string[] = [];
        if (symbol.isAbstract) mods.push(SCN_SYMBOLS.TAG_ABSTRACT.slice(1, -1));
        if (symbol.isStatic) mods.push(SCN_SYMBOLS.TAG_STATIC.slice(1, -1));
        const modStr = mods.length > 0 ? ` [${mods.join(' ')}]` : '';

        const suffixParts: string[] = [];
        if (symbol.signature) name += symbol.name === '<anonymous>' ? symbol.signature : `${symbol.signature}`;
        if (symbol.typeAnnotation) name += `: ${symbol.typeAnnotation}`;
        if (symbol.typeAliasValue) name += ` ${symbol.typeAliasValue}`;
        // Merge async + throws into a single token
        const asyncToken = symbol.isAsync ? SCN_SYMBOLS.ASYNC : '';
        const throwsToken = symbol.throws ? SCN_SYMBOLS.THROWS : '';
        const asyncThrows = (asyncToken + throwsToken) || '';
        if (asyncThrows) suffixParts.push(asyncThrows);
        if (symbol.isPure) suffixParts.push(SCN_SYMBOLS.PURE);
        if (symbol.labels && symbol.labels.length > 0) suffixParts.push(...symbol.labels.map(l => `[${l}]`));
        const suffix = suffixParts.join(' ');

        // Build ID portion conditionally
        const file = allFiles.find(f => f.id === symbol.fileId)!;
        const idPart = formatSymbolIdDisplay(file, symbol);
        const idText = (symbol.kind === 'property' || symbol.kind === 'constructor') ? null : (idPart ?? null);
        const segments: string[] = [prefix, icon];
        if (idText) segments.push(idText);
        if (name) segments.push(name.trim());
        if (modStr) segments.push(modStr);
        if (suffix) segments.push(suffix);
        const line = `  ${segments.filter(Boolean).join(' ')}`;
        const result = [line];

        const outgoing = new Map<number, Set<string>>();
        const unresolvedDeps: string[] = [];
        symbol.dependencies.forEach(dep => {
            if (dep.resolvedFileId !== undefined && dep.resolvedFileId !== symbol.fileId) {
                if (!outgoing.has(dep.resolvedFileId)) outgoing.set(dep.resolvedFileId, new Set());
                if (dep.resolvedSymbolId) {
                    const targetFile = allFiles.find(f => f.id === dep.resolvedFileId);
                    const targetSymbol = targetFile?.symbols.find(s => s.id === dep.resolvedSymbolId);
                    if (targetSymbol) {
                        const displayId = formatSymbolIdDisplay(targetFile!, targetSymbol);
                        let text = displayId ?? `(${targetFile!.id}.0)`;
                        if (dep.kind === 'goroutine') {
                            text += ` ${SCN_SYMBOLS.TAG_GOROUTINE}`;
                        }
                        outgoing.get(dep.resolvedFileId)!.add(text);
                    }
                } else {
                    let text = `(${dep.resolvedFileId}.0)`;
                    if (dep.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                    outgoing.get(dep.resolvedFileId)!.add(text);
                }
            } else if (dep.resolvedFileId === undefined) {
                if (dep.kind === 'macro') {
                    unresolvedDeps.push(`${dep.targetName} ${SCN_SYMBOLS.TAG_MACRO}`);
                }
            }
        });

        const outgoingParts: string[] = [];
        if (outgoing.size > 0) {
            const resolvedParts = Array.from(outgoing.entries())
                .sort((a, b) => a[0] - b[0])
                .map(([fileId, symbolIds]) => {
                    const items = Array.from(symbolIds).sort();
                    return items.length > 0 ? `${items.join(', ')}` : `(${fileId}.0)`;
                });
            outgoingParts.push(...resolvedParts);
        }
        outgoingParts.push(...unresolvedDeps);

        if (outgoingParts.length > 0) {
            result.push(`    ${SCN_SYMBOLS.OUTGOING_ARROW} ${outgoingParts.join(', ')}`);
        }
        
        const incoming = new Map<number, Set<string>>();
        allFiles.forEach(file => {
            file.symbols.forEach(s => {
                s.dependencies.forEach(d => {
                    if (d.resolvedFileId === symbol.fileId && d.resolvedSymbolId === symbol.id && s !== symbol) {
                        if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                        // Suppress same-file incoming for properties
                        if (file.id === symbol.fileId && symbol.kind === 'property') return;
                        const disp = formatSymbolIdDisplay(file, s) ?? `(${file.id}.0)`;
                        incoming.get(file.id)!.add(disp);
                    }
                });
            });
            // Include file-level imports to this file as incoming for exported symbols
            // but only if there is no symbol-level incoming from that file already
            if (file.id !== symbol.fileId && symbol.isExported) {
                file.fileRelationships?.forEach(rel => {
                    if (rel.resolvedFileId === symbol.fileId) {
                        const already = incoming.get(file.id);
                        if (!already || already.size === 0) {
                            if(!incoming.has(file.id)) incoming.set(file.id, new Set());
                            incoming.get(file.id)!.add(`(${file.id}.0)`);
                        }
                    }
                });
            }
        });

        if (incoming.size > 0) {
            const parts = Array.from(incoming.entries()).map(([_fileId, symbolIds]) => Array.from(symbolIds).join(', '));
            result.push(`    ${SCN_SYMBOLS.INCOMING_ARROW} ${parts.join(', ')}`);
        }

        return result;
    };



    const isWithin = (inner: CodeSymbol, outer: CodeSymbol): boolean => {
        const a = inner.range;
        const b = outer.scopeRange;
        return (
            (a.start.line > b.start.line || (a.start.line === b.start.line && a.start.column >= b.start.column)) &&
            (a.end.line < b.end.line || (a.end.line === b.end.line && a.end.column <= b.end.column))
        );
    };


    const buildChildrenMap = (symbols: CodeSymbol[]): Map<string, CodeSymbol[]>
    => {
        const parents = symbols.filter(s => s.kind === 'class' || s.kind === 'interface' || s.kind === 'react_component');
        const map = new Map<string, CodeSymbol[]>();
        for (const parent of parents) map.set(parent.id, []);
        for (const sym of symbols) {
            if (sym.kind === 'class' || sym.kind === 'interface' || sym.kind === 'react_component') continue;
            const parent = parents
                .filter(p => isWithin(sym, p))
                .sort((a, b) => (a.scopeRange.end.line - a.scopeRange.start.line) - (b.scopeRange.end.line - b.scopeRange.start.line))[0];
            if (parent) {
                map.get(parent.id)!.push(sym);
            }
        }
        // Sort children by position
        for (const [, arr] of map.entries()) {
            arr.sort((a, b) => a.range.start.line - b.range.start.line || a.range.start.column - b.range.start.column);
        }
        return map;
    };


    const formatFile = (file: SourceFile, allFiles: SourceFile[]): string => {
        if (file.parseError) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath} [error]`;
        if (!file.sourceCode.trim()) return `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath}`;

        const directives = [
            file.isGenerated && SCN_SYMBOLS.TAG_GENERATED.slice(1, -1),
            ...(file.languageDirectives || [])
        ].filter(Boolean);
        const directiveStr = directives.length > 0 ? ` [${directives.join(' ')}]` : '';
        const header = `${SCN_SYMBOLS.FILE_PREFIX} (${file.id}) ${file.relativePath}${directiveStr}`;

        const headerLines: string[] = [header];

        // File-level outgoing/incoming dependencies
        const outgoing: string[] = [];
        if (file.fileRelationships) {
            const outgoingFiles = new Set<number>();
            file.fileRelationships.forEach(rel => {
                // Only show true file-level imports on the header
                if ((rel.kind === 'import' || rel.kind === 'dynamic_import') && rel.resolvedFileId && rel.resolvedFileId !== file.id) {
                    let text = `(${rel.resolvedFileId}.0)`;
                    if (rel.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                    outgoingFiles.add(rel.resolvedFileId);
                    outgoing.push(text);
                }
            });
            if (outgoing.length > 0) headerLines.push(`  ${SCN_SYMBOLS.OUTGOING_ARROW} ${Array.from(new Set(outgoing)).sort().join(', ')}`);
        }

        // Incoming: any other file that has a file-level relationship pointing here
        const incoming: string[] = [];
        allFiles.forEach(other => {
            if (other.id === file.id) return;
            other.fileRelationships?.forEach(rel => {
                if (rel.resolvedFileId === file.id) incoming.push(`(${other.id}.0)`);
            });
        });
        if (incoming.length > 0) headerLines.push(`  ${SCN_SYMBOLS.INCOMING_ARROW} ${Array.from(new Set(incoming)).sort().join(', ')}`);

        // If file has no exported symbols, only show symbols that are "entry points" for analysis,
        // which we define as having outgoing dependencies.
        const hasExports = file.symbols.some(s => s.isExported);
        let symbolsToPrint = hasExports
            ? file.symbols.slice()
            : file.symbols.filter(s => s.dependencies.length > 0);

        // Group properties/methods under their class/interface parent
        const childrenMap = buildChildrenMap(symbolsToPrint);
        const childIds = new Set<string>(Array.from(childrenMap.values()).flat().map(s => s.id));
        const topLevel = symbolsToPrint.filter(s => !childIds.has(s.id));

        const symbolLines: string[] = [];
        for (const sym of topLevel) {
            const lines = formatSymbol(sym, allFiles);
            symbolLines.push(...lines);
            if (childrenMap.has(sym.id)) {
                const kids = childrenMap.get(sym.id)!;
                for (const kid of kids) {
                    const kLines = formatSymbol(kid, allFiles).map(l => `  ${l}`);
                    symbolLines.push(...kLines);
                }
            }
        }

        // If we hid symbols (or there were none to begin with for an entry file),
        // aggregate outgoing dependencies from all symbols onto the file header
        if (symbolsToPrint.length === 0) {
            const aggOutgoing = new Map<number, Set<string>>();
            const unresolvedDeps: string[] = [];

            const processDep = (dep: import('./types').Relationship) => {
                if (dep.resolvedFileId && dep.resolvedFileId !== file.id) {
                    if (!aggOutgoing.has(dep.resolvedFileId)) aggOutgoing.set(dep.resolvedFileId, new Set());
                    let text = `(${dep.resolvedFileId}.0)`; // Default to file-level
                    if (dep.resolvedSymbolId) {
                        const targetFile = allFiles.find(f => f.id === dep.resolvedFileId)!;
                        const targetSymbol = targetFile.symbols.find(ts => ts.id === dep.resolvedSymbolId);
                        if (targetSymbol) {
                            text = formatSymbolIdDisplay(targetFile, targetSymbol) ?? `(${dep.resolvedFileId}.0)`;
                        }
                    }
                    if (dep.kind === 'dynamic_import') text += ` ${SCN_SYMBOLS.TAG_DYNAMIC}`;
                    aggOutgoing.get(dep.resolvedFileId)!.add(text);
                } else if (dep.resolvedFileId === undefined && dep.kind === 'macro') {
                    unresolvedDeps.push(`${dep.targetName} ${SCN_SYMBOLS.TAG_MACRO}`);
                }
            };

            file.symbols.forEach(s => s.dependencies.forEach(processDep));
            file.fileRelationships?.forEach(processDep);

            const outgoingParts: string[] = [];
            if (aggOutgoing.size > 0) {
                const resolvedParts = Array.from(aggOutgoing.entries())
                    .sort((a, b) => a[0] - b[0])
                    .flatMap(([, symbolIds]) => Array.from(symbolIds).sort());
                outgoingParts.push(...resolvedParts);
            }
            outgoingParts.push(...unresolvedDeps);

            if (outgoingParts.length > 0) {
                // Some fixtures expect separate -> lines per dependency.
                // This preserves that behavior.
                for (const part of outgoingParts) {
                    headerLines.push(`  ${SCN_SYMBOLS.OUTGOING_ARROW} ${part}`);
                }
            }
        }
        return [...headerLines, ...symbolLines].join('\n');
    };


    export const formatScn = (analyzedFiles: SourceFile[]): string => {
        const sortedFiles = topologicalSort(analyzedFiles);
        return sortedFiles.map(file => formatFile(file, analyzedFiles)).join('\n\n');
    };
  packages/scn-ts-web-demo/src/App.tsx: >
    import { useState, useEffect, useCallback, useRef } from 'react';

    import { get_encoding, type Tiktoken } from 'tiktoken';

    import {
      initializeParser,
      logger,
      analyzeProject,
      generateScn,
    } from '../../../index';

    import type { FileContent, LogHandler } from '../../../index';

    import { defaultFilesJSON } from './default-files';

    import { Button } from './components/ui/button';

    import { Card, CardContent, CardHeader, CardTitle } from
    './components/ui/card';

    import { Textarea } from './components/ui/textarea';

    import LogViewer from './components/LogViewer';

    import { Play, Loader } from 'lucide-react';

    import type { LogEntry, ProgressData } from './types';


    function App() {
      const [isInitialized, setIsInitialized] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [filesInput, setFilesInput] = useState(defaultFilesJSON);
      const [scnOutput, setScnOutput] = useState('');
      const [progress, setProgress] = useState<ProgressData | null>(null);
      const [logs, setLogs] = useState<LogEntry[]>([]);
      const [encoder, setEncoder] = useState<Tiktoken | null>(null);
      const [tokenCounts, setTokenCounts] = useState({ input: 0, output: 0 });

      useEffect(() => {
        const init = async () => {
          try {
            await initializeParser({ wasmBaseUrl: '/wasm/' });
            const enc = get_encoding("cl100k_base");
            setEncoder(enc);
            setIsInitialized(true);
            setLogs(prev => [...prev, { level: 'info', message: 'Parser and tokenizer initialized.', timestamp: Date.now() }]);
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            setLogs(prev => [...prev, { level: 'error', message: `Failed to initialize: ${message}`, timestamp: Date.now() }]);
          }
        };
        init();
      }, []);

      useEffect(() => {
        if (!encoder) return;
        try {
          const inputTokens = encoder.encode(filesInput).length;
          const outputTokens = encoder.encode(scnOutput).length;
          setTokenCounts({ input: inputTokens, output: outputTokens });
        } catch (e) {
          console.error("Tokenization error:", e);
          setTokenCounts({ input: 0, output: 0 });
        }
      }, [filesInput, scnOutput, encoder]);

      const handleAnalyze = useCallback(async () => {
        if (!isInitialized) {
          setLogs(prev => [...prev, { level: 'warn', message: 'Parser not ready.', timestamp: Date.now() }]);
          return;
        }

        setIsLoading(true);
        setLogs([]);
        setScnOutput('');
        setProgress(null);

        const logHandler: LogHandler = (level, ...args) => {
          const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
          setLogs(prev => [...prev, { level, message, timestamp: Date.now() }]);
        };
        logger.setLogHandler(logHandler);
        logger.setLevel('debug');

        const onProgress = (progressData: ProgressData) => {
          setProgress(progressData);
          logger.info(`[${Math.round(progressData.percentage)}%] ${progressData.message}`);
        };

        try {
          let files: FileContent[] = [];
          try {
            files = JSON.parse(filesInput);
            if (!Array.isArray(files)) throw new Error("Input is not an array.");
          } catch (error) {
            throw new Error(`Invalid JSON input: ${error instanceof Error ? error.message : String(error)}`);
          }

          const rankedGraph = await analyzeProject({ files, onProgress, logLevel: 'debug' });
          const scn = generateScn(rankedGraph);
          setScnOutput(scn);
          logger.info('Analysis complete.');
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          logger.error('Analysis failed:', message);
        } finally {
          setIsLoading(false);
          setProgress(null);
          logger.setLogHandler(null);
        }
      }, [filesInput, isInitialized]);

      return (
        <div className="h-screen w-screen flex flex-col bg-background text-foreground">
          <header className="flex-shrink-0 flex items-center justify-between p-4 border-b">
            <h1 className="text-xl font-bold tracking-tight">SCN-TS Web Demo</h1>
            <Button onClick={handleAnalyze} disabled={isLoading || !isInitialized} className="w-32 justify-center">
              {isLoading ? (
                <>
                  <Loader className="mr-2 h-4 w-4 animate-spin" />
                  <span>{progress ? `${Math.round(progress.percentage)}%` : 'Analyzing...'}</span>
                </>
              ) : (
                <>
                  <Play className="mr-2 h-4 w-4" />
                  <span>Analyze</span>
                </>
              )}
            </Button>
          </header>

          <main className="flex-grow grid grid-cols-1 lg:grid-cols-2 gap-4 p-4 overflow-hidden">
            <Card className="flex flex-col overflow-hidden">
              <CardHeader>
                <CardTitle className="flex justify-between items-center">
                  <span>Input Files (JSON)</span>
                  <span className="text-sm font-normal text-muted-foreground">{tokenCounts.input.toLocaleString()} tokens</span>
                </CardTitle>
              </CardHeader>
              <CardContent className="flex-grow">
                <Textarea
                  value={filesInput}
                  onChange={(e) => setFilesInput(e.currentTarget.value)}
                  className="h-full w-full font-mono text-xs resize-none"
                  placeholder="Paste an array of FileContent objects here..."
                />
              </CardContent>
            </Card>

            <Card className="flex flex-col overflow-hidden">
              <CardHeader>
                <CardTitle className="flex justify-between items-center">
                  <span>Output (SCN)</span>
                  <span className="text-sm font-normal text-muted-foreground">{tokenCounts.output.toLocaleString()} tokens</span>
                </CardTitle>
              </CardHeader>
              <CardContent className="flex-grow overflow-auto">
                <pre className="text-xs whitespace-pre-wrap font-mono h-full w-full">
                  <code className="h-full w-full">
                    {scnOutput || (isLoading ? "Generating..." : "Output will appear here.")}
                  </code>
                </pre>
              </CardContent>
            </Card>
          </main>

          <footer className="flex-shrink-0 h-[200px] border-t">
            <LogViewer logs={logs} />
          </footer>
        </div>
      );
    }


    export default App;
approved: true
